{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PythonDocs","text":"<p>Mis apuntes en espa\u00f1ol acerca del lenguaje Python y algunos de sus m\u00f3dulos y paquetes.</p>"},{"location":"#basicos-de-python","title":"B\u00e1sicos de Python","text":"<p>Aqu\u00ed se describen los aspectos b\u00e1sicos del lenguaje, algunos m\u00f3dulos est\u00e1ndar, etc.</p> <ol> <li>Comenzando con Python</li> <li>Variables y Asignaciones</li> <li>Expresiones y Operadores</li> <li>Tipos de Datos</li> <li>Control de Flujo</li> <li>Funciones</li> <li>Modulos</li> <li>Paquetes</li> <li>Entornos Virtuales: VENV</li> <li>Fechas y Horario</li> <li>Manejo de Archivos</li> <li> <p>Errores y Excepciones</p> </li> <li> <p>Programacion Funcional</p> </li> <li> <p>Decoradores</p> </li> <li> <p>Clases I - Definicion y Propiedades</p> </li> <li>Clases II: Decoradores, Abstracciones y M\u00e9todos Especiales</li> <li> <p>Clases III: Principios SOLID</p> </li> <li> <p>Procesos</p> </li> <li>Hilos</li> <li> <p>Intercambio</p> </li> <li> <p>Enlaces</p> </li> </ol>"},{"location":"#modulos-de-python","title":"M\u00f3dulos de Python","text":"<p>Exploraci\u00f3n de algunos m\u00f3dulos est\u00e1ndar del lenguaje Python.</p> <ul> <li>PathLib - Rutas de archivo</li> <li>SYS - Par\u00e1metros y funciones del sistema</li> <li>OS - Comandos del sistema operativo</li> <li>Tempfile - Archivos y directorios temporales</li> <li>RE - Expresiones Regulares (REGEX)</li> <li>Asyncio - Ejecuci\u00f3n Asincr\u00f3nica</li> <li>Logging - Reportes de errores</li> <li>Unittest - Tests Unitarios</li> </ul>"},{"location":"#paquetes-de-python","title":"Paquetes de Python","text":"<p>Breves tutoriales de paquetes varios implementados en Python: bibliotecas, frameworks, etc. Estos normalmente se asignan al sistema en forma de \"paquetes\".</p> <ul> <li>PyYAML - Soporte para archivos YAML</li> <li>Python i18n - Traducciones I18N</li> <li>Numba - Compilacion con Machine Learning</li> <li>FFMPEG - Wrapper para Python</li> <li>PsUtil - Informaci\u00f3n del Sistema</li> </ul>"},{"location":"contenido/1-comenzando/","title":"Comenzando con Python","text":""},{"location":"contenido/1-comenzando/#archivos-y-ejecucion","title":"Archivos y Ejecuci\u00f3n","text":"<p>Los programas escritos en lenguaje Python se guardan en archivos de texto con extensi\u00f3n <code>.py</code>.</p> <p>Para ejecutar las rutinas mediante int\u00e9rprete desde la consola  se usa el comando <code>python</code>:</p> <p>ejecutar rutina Python<pre><code>python  nombre_archivo.py\npython3 nombre_archivo.py \n</code></pre> La versi\u00f3n m\u00e1s usada actualmente de Python es la versi\u00f3n 3; sin embargo todav\u00eda existe c\u00f3digo legacy (no mantenible) en la versi\u00f3n 2. Seg\u00fan el sistema operativo y la versi\u00f3n de Python instalada puede requerirse un comando o el otro.</p> <p>Abreviaci\u00f3n comando</p> <p>Desde la versi\u00f3n 3.10 se a\u00f1adi\u00f3 el comando <code>py</code> como abreviaci\u00f3n del comando del int\u00e9rprete:</p> ejecutar rutina Python - abreviado<pre><code>py nombre_archivo.py\n</code></pre>"},{"location":"contenido/1-comenzando/#escribir-en-pantalla","title":"Escribir en pantalla","text":"<p>El primer programa m\u00e1s habitual es el 'HelloWorld!', un programa que escribe un mensaje en consola. En Python los mensajes se escriben en pantalla con la funci\u00f3n <code>print()</code>:</p> Hola mundo<pre><code>print(\"\u00a1Hola Mundo!\")\nprint('Mi primera rutina en Python')\n</code></pre> <p>Python verifica la indentaci\u00f3n (es decir, los espacios a izquierda) de las instrucciones para determinar las jerarqu\u00edas y los controles de flujo dentro de los programas (esto se ver\u00e1 m\u00e1s adelante). Por ello debe tenerse cuidado de no dejar distintos espacios a izquierda de las instrucciones excepto cuando estas lo requieren. </p> <p>Ejemplo: un error debido a un indentado no consistente Error indentado<pre><code>print(\"\u00a1Hola Mundo!\")\n  print('Mi primera rutina en Python') # da IndentationError\n</code></pre></p>"},{"location":"contenido/1-comenzando/#comentarios","title":"Comentarios","text":"<p>Los comentarios de una l\u00ednea son precedidos por el s\u00edmbolo numeral (#). Comentarios simples<pre><code># Comentario, una linea\n</code></pre> Los comentarios de m\u00faltiples l\u00edneas empiezan precedidos con tres comillas y terminan en tres comillas (<code>\u201c\u201d\u201d\u201d</code>): </p> <p>Comentarios multil\u00ednea - comillas<pre><code>\"\"\"\nUn comentario, \nvarias lineas\n\"\"\"\n</code></pre> Usar triple comilla simple (<code>'''</code>) antes y despu\u00e9s de los comentarios tambi\u00e9n sirve para documentar:</p> Comentarios multil\u00ednea - comillas simples<pre><code>'''\nUn comentario, \nvarias lineas\n'''\n</code></pre>"},{"location":"contenido/1-comenzando/#documentacion-markdown","title":"Documentaci\u00f3n - MarkDown","text":"<p>MarkDown facilita crear codigos de texto remarcados seg\u00fan el lenguaje usado. Es un formato muy utilizado para documentar  c\u00f3digo de software en archivos con extensi\u00f3n <code>.md</code>.</p> <p>Usando triple comilla inclinada rodeando el bloque de c\u00f3digo y la palabra <code>python</code> (o <code>py</code>) como se muestra: </p> <p>C\u00f3digo en MarkDown - formato<pre><code>  ```python\n  # C\u00f3digo Python\n  # ...\n  ```\n</code></pre> entonces el int\u00e9rprete de MarkDown da estilo al bloque:</p> <p>C\u00f3digo en MarkDown - resultado<pre><code># C\u00f3digo Python\n# ...\n</code></pre> Este documento presente usa extensivamente esta propiedad.</p>"},{"location":"contenido/1-comenzando/#scripts-ejecutables","title":"Scripts ejecutables","text":"<p>Para convertir los archivos de Python en scripts ejecutables se puede incluir dentro del mismo archivo de programa un 'shebang' de modo an\u00e1logo al usado en los scripts de Bash: Rutinas ejecutables<pre><code>#!/usr/bin/env python   # ruta al interprete Python\nprint(\"\u00a1Hola Mundo!\")\n</code></pre> Este realiza el llamado al int\u00e9rprete de Python desde el mismo archivo. El shebang debe apuntar a un int\u00e9rprete de Python instalado en el sistema para que el script funcione.</p> <p>De este modo se puede ejecutar la rutina del archivo desde la consola directamente, poniendo punto y barra adelante del nombre: Autoejecuci\u00f3n<pre><code>./nombre_archivo.py\n</code></pre> Tambi\u00e9n se podr\u00e1 ejecutar la rutina con doble click sobre el archivo; sin embargo esto puede no abrir la terminal (o cerrarla muy r\u00e1pidamente).</p> <p>Importante:</p> <p>Es posible que se requiera darle permisos de ejecuci\u00f3n al archivo. Esto puede hacerse desde la terminal con el comando chmod o bien afectando las propiedades con clik derecho en el entorno gr\u00e1fico del sistema operativo.</p> <p>Asignar permisos de ejecucion desde la terminal: Habilitar autoejecuci\u00f3n<pre><code>chmod +x nombre_archivo.py\n</code></pre></p>"},{"location":"contenido/1-comenzando/#uso-en-consola","title":"Uso en Consola","text":"<p>Las instrucciones de Python se puede ejecutar escribiendo en la terminal en tiempo real. Para ello se invoca al int\u00e9rprete de Pyhton desde la terminal usada:</p> Uso en consola<pre><code>python\npy\n</code></pre> <p>Entonces se imprime la informaci\u00f3n de la actual versi\u00f3n de Python y del sistema operativo actual. Cada nueva linea de la terminal comienza con <code>`&gt;&gt;&gt;</code> indicando que el int\u00e9rprete de Python est\u00e1 abierto y las instrucciones se cierran pulsando la tecla <code>ENTER</code>.</p> Uso en consola - Instruccion a instruccion<pre><code>&gt;&gt;&gt; instrucccion_1\n&gt;&gt;&gt; instruccion_2\n&gt;&gt;&gt; ....\n</code></pre> <p>Ejemplo: definir una variable en vivo y sumarle 1</p> <p><pre><code>&gt;&gt;&gt; x=3   # asignacion\n&gt;&gt;&gt; x+1   # incremento\n</code></pre> Resultado en pantalla: <pre><code>&gt;&gt;&gt; x=3\n&gt;&gt;&gt; x+1\n4\n</code></pre></p> <p>Para salir del int\u00e9rprete hay que escribir <code>exit()</code> \u00f3 <code>Ctrl + Z</code> (en Linux)</p> Uso en consola - Salida<pre><code>&gt;&gt;&gt; exit()\n</code></pre>"},{"location":"contenido/1-comenzando/#compilacion","title":"Compilaci\u00f3n","text":"<p>Con el fin de crear archivos ejecutables hay varias herramientas para compilar el c\u00f3digo, es decir para crear archivos ejecutables. Algunas de ellas son:</p> <ul> <li>py2exe;</li> <li>pyinstaller;</li> <li>Codon;</li> <li>etc.</li> </ul> <p>Cada una de ellas tiene sus propiedades, distintos tipos de licencia, distintos sistemas operativos de destino, etc.</p> <p>Uso interpretado</p> <p>Si bien es posible crear los ejecutables en base a c\u00f3digo Python lo m\u00e1s habitual es el uso por interpretado.</p>"},{"location":"contenido/10-manejo_archivos/","title":"Manejo de Archivos","text":""},{"location":"contenido/10-manejo_archivos/#apertura","title":"Apertura","text":"<p>Asumimos que los archivos est\u00e1n ubicados en el directorio del ejecutable o script. Para trabajar con  un archivo podemos hacer:</p> Apertura archivos - cierre autom\u00e1tico<pre><code>with open(\u201c&lt;ruta_archivo&gt;\u201d, \u201c&lt;modo_apertura&gt;\u201d) as  &lt;descriptor_archivo&gt;:\n    # Rutina de archivo\n    #...\n\n# Cierre autom\u00e1tico de archivo\n</code></pre> <p>El fin del indentado es interpretado como el cierre del archivo. Esto es as\u00ed por haber utilizado la palabra <code>with</code> antecediendo la apertura. Si en cambio se prefiere hacer el cierre manualmente se puede hacer:</p> <p>Apertura archivos - cierre manual<pre><code>&lt;descriptor_archivo&gt; = open(\u201c&lt;ruta_archivo&gt;\u201d, \u201c&lt;modo_apertura&gt;\u201d) \n# Rutina de archivo\n# ...\n&lt;descriptor_archivo&gt;.close()  # cierre manual\n</code></pre> En este caso no se agrega indentado.</p> <p>El asignar una variable descriptora para el archivo permite usar los m\u00e9todos de Python para la manipulaci\u00f3n de archivos, esto se ver\u00e1 m\u00e1s adelante. </p> <p>Cierre de archivos</p> <p>El cierre de archivo es importante para asegurar el guardado de datos en el archivo, el cual puede fallar si el archivo no se cierra correctamente. Tambi\u00e9n permite liberar recursos del sistema operativo que, de otra manera, qeuedar\u00edan ocupados hasta el siguiente reinicio.</p> <p>Cierre autom\u00e1tico</p> <p>Muchos desarrolladores consideran una buena pr\u00e1ctica el uso de la cl\u00e1usula <code>with</code> para de esa manera asegurar el cierre de archivo tras su acceso. </p>"},{"location":"contenido/10-manejo_archivos/#modos-de-apertura","title":"Modos de Apertura","text":"<p>El modo de apertura del archivo puede ser:</p> Modo apertura Descripcion r read: leer w write: escribir a append: a\u00f1adir al final x creaci\u00f3n exclusiva: s\u00f3lo crea el archivo si \u00e9ste no existe <p>Si se a\u00f1ade el signo m\u00e1s (<code>+</code>) al modo de apertura se incluye la lectura \u00f3 modificacion, seg\u00fan corresponda. Por ejemplo <code>\"w+\"</code> permite escribir y tambi\u00e9n leer, en tanto que <code>r+</code> permite leer y modificar.</p> <p>File pointer</p> <p>Los descriptores de archivo incluyen un puntero o apuntador de archivo (file pointer) interno el cual apunta a alguno de los bytes o caracteres internos del archivo, funcionando como un \u00edndice. La posici\u00f3n de dicho apuntador depender\u00e1 del modo de apertura elegido, de las operaciones posteriores de lectura o de escritura, etc.</p> <p>La tabla completa con los permisos y la posici\u00f3n del apuntador es la siguiente:</p> Permisos  y propiedades r r+ w w+ a a+ leer escribir escribir tras buscar crear borrar position at comienzo posici\u00f3n al final <p>Apertura binaria</p> <p>A\u00f1adiendo la letra <code>b</code> a las opciones de apertura se indica la modalidad binaria de lectura o escritura, es decir los datos se leen y escriben en binario. Por ejemplo, para leer archivos binarios y poder modificarlos la etiqueta correspondiente es <code>\"rb+\"</code>.  Los archivos binarios reprensentan cualquier tipo de contenido que no sea texto y pueden representar imagenes, audio, video, etc.</p>"},{"location":"contenido/10-manejo_archivos/#metodos-del-descriptor-de-archivos","title":"M\u00e9todos del descriptor de archivos","text":""},{"location":"contenido/10-manejo_archivos/#close","title":"<code>close()</code>","text":"<p>Este m\u00e9todo es el usado para el cierre manual del archivo. Uso: </p> Cierre manual<pre><code>ruta = \"texto.txt\u201d\narchivo =  open(ruta, \"r\") \n# Rutina\n# ...\narchivo.close()    # necesario / prudente\n</code></pre> <p>Si se hace la apertura con el comando with el cierre manual no es necesario.</p> Cierre manual redundante<pre><code>ruta = \"texto.txt\u201d\nwith open(ruta, \"r\") as archivo: \n  # Rutina\n  # ...\n  archivo.close()    # redundante\n</code></pre>"},{"location":"contenido/10-manejo_archivos/#read","title":"<code>read()</code>","text":"<p>El m\u00e9todo <code>read()</code> permite leer total o parcialmente el contenido del archivo.</p> <p>read() - Leer todo<pre><code>ruta = \"texto.txt\"\nwith open(ruta, \"r\") as archivo: \n  print( archivo.read() )   # lee TODO el contenido como texto\n</code></pre> Al m\u00e9todo se le puede indicar la cantidad de caracteres a leer cada vez entre los par\u00e9ntesis:</p> read() - Leer N caracteres<pre><code>ruta = \"texto.txt\"\nwith open(ruta, \"r\") as archivo:  # modo lectura\n  print( archivo.read(20) )   # lee los primeros 20 caracteres  \n  print( archivo.read(20) )   # lee los siguientes 20 caracteres\n</code></pre> <p>N\u00f3tese que cada nueva operaci\u00f3n de lectura comienza donde termin\u00f3 la anterior. Esto tiene que ver con el \"puntero de archivo\" que guarda dentro del descriptor de archivo esa informaci\u00f3n.</p>"},{"location":"contenido/10-manejo_archivos/#seek","title":"<code>seek()</code>","text":"<p>El m\u00e9todo <code>seek()</code> permite elegir el indice desde donde deben comenzar las operaciones de lectura o escritura. Afecta al file pointer interno.</p> seek() - argumentos<pre><code>archivo.seek(offset, whence)\n</code></pre> <p>Este m\u00e9todo tiene dos argumentos: <code>offset</code> indica la posici\u00f3n relativa del puntero interno en tanto que <code>whence</code> es el punto de referencia.</p> valor <code>whence</code> Referencia 0 Comienzo de archivo (valor predefinido) 1 Posici\u00f3n actual 2 Final de archivo <p>Por ejemplo, si se desea leer el contenido desde el caracter N\u00ba20 en adelante (repasar ejemplo previo) se puede hacer:</p> <p>seek() - Buscar caracter N-\u00e9simo<pre><code>ruta = \"texto.txt\u201d\nwith open(ruta, \"r\") as archivo:  # modo lectura\n  archivo.seek(20)            # modificacion del puntero del archivo  - equivale a 'seek(20,0)' \n  print( archivo.read() )   # lee los siguientes caracteres\n</code></pre> Este mismo m\u00e9todo permite reiniciar las operaciones de lectura sin necesidad de reapertura del archivo, colocando el \u00edndice cero:</p> seek() - Reiniciar lectura<pre><code>  #....\n  archivo.seek(0)            # puntero del archivo al comienzo de datos - equivale a 'seek(0,0)' \n  print( archivo.read() )   # lee los siguientes caracteres\n</code></pre> <p>Tambi\u00e9n se puede buscar el fin de archivo con ayuda de esta funci\u00f3n:</p> seek() - Fin archivo<pre><code>  archivo.seek(0, 2)   # \u00daltimo car\u00e1cter \n</code></pre> <p>Restricciones de seek()</p> <p>Cuando los archivos est\u00e1n abiertos en modo texto, la mayor\u00eda de las combinaciones de  <code>offset</code> y <code>whence</code> lanzan error.</p> <p>En cambio, dichas combinaciones s\u00ed se permiten cuando se abren los archivos en modo binario, donde la posici\u00f3n relativa <code>offset</code> representa cu\u00e1ntos bytes se debe avanzar o retroceder.</p>"},{"location":"contenido/10-manejo_archivos/#readline","title":"<code>readline()</code>","text":"<p>Este m\u00e9todo lee un rengl\u00f3n a la vez y le a\u00f1ade al final un signo de fin de carrera (<code>\\n</code> en ASCII). Uso:</p> Leer<pre><code>ruta = \"texto.txt\u201d\nwith open(ruta, \"r\") as archivo:\n  print( archivo.readline() )   # lee primer rengl\u00f3n  \n  print( archivo.readline() )   # lee segundo rengl\u00f3n\n</code></pre> <p>Cada rengl\u00f3n le\u00eddo se devuelve en formato <code>str</code> (string) y a cada uno se le agrega un car\u00e1cter de fin de l\u00ednea (<code>\\n</code>). </p> <p>Si se alcanza el final del archivo la funci\u00f3n <code>readline()</code> devuelve un string completamente vac\u00edo.</p> <p>Contador de renglones</p> <p>Se pueden contar los renglones de archivo con ayuda de un bucle <code>while</code>, el cual se abre cuando se detecta el string vac\u00edo:</p> Ejemplo: contador renglones<pre><code>ruta = \"texto.txt\"\nwith open(ruta, \"r\") as archivo:  # modo lectura\n  contenido = True\n  n = 0\n  while contenido:\n    renglon = archivo.readline()\n    print(f\"{renglon}\")\n    if not renglon:\n      contenido = False\n    else:\n      n += 1\n  print(f\"N\u00ba renglones: {n}\")\n</code></pre>"},{"location":"contenido/10-manejo_archivos/#readlines","title":"<code>readlines()</code>","text":"<p>Este m\u00e9todo es similar al anterior pero lee todos los renglones del archivo juntos y los devuelve agrupados en una lista. Ejemplo uso:</p> <p><pre><code>ruta = \"texto.txt\u201d\nopen(ruta, \"r\") as archivo:\n  lista_renglones = archivo.readlines()    # lee todos los renglones como lista \n  for renglon in lista_renglones:\n    print(renglon)      # presentaci\u00f3n: un rengl\u00f3n por vez\n</code></pre> Este m\u00e9todo tambien a\u00f1ade un fin de carrera (<code>\\n</code>) a cada rengl\u00f3n.</p>"},{"location":"contenido/10-manejo_archivos/#readable","title":"<code>readable()</code>","text":"<p>Verifica la posibilidad de leer o no un archivo. Es afectado por el modo de apertura elegido. Ejemplos:</p> Verificar legibilidad<pre><code>ruta = \"texto.txt\u201d\nopen(ruta, \"w\") as archivo:\n  legible = archivo.readable()    # devuelve 'False'\n#...\nopen(ruta, \"w+\") as archivo:\n  legible = archivo.readable()    # devuelve 'True'\n</code></pre>"},{"location":"contenido/10-manejo_archivos/#write","title":"<code>write()</code>","text":"<p>Este m\u00e9todo reescribe (o a\u00f1ade) contenido al archivo. Es afectado tanto por el modo de apertura de archivo como por el puntero del archivo (ver m\u00e9todo <code>seek()</code>).</p> Reemplazo al comienzo - modo 'r+'<pre><code>ruta = \"texto.txt\u201d\narchivo = open(ruta, \"r+\")  # modo lectura con a\u00f1adido\nagregado = \"renglon a\u00f1adido\"\narchivo.write( agregado )   # el contenido reemplaza al primer renglon\narchivo.close()\n</code></pre> Reemplazo al final - modo 'a'<pre><code>ruta = \"texto.txt\u201d\narchivo = open(ruta, \"a\")  # modo a\u00f1adido ('append')\nagregado = \"renglon a\u00f1adido\"\narchivo.write( agregado )   # el contenido se agrega al final del archivo\narchivo.close()\n</code></pre> Sobreescritura total - modo 'w'<pre><code>ruta = \"texto.txt\u201d\narchivo = open(ruta, \"w\")  # modo escritura estricta (tambien se puede hacer con \"w+\")\nnuevo_contenido = \"Mi nuevo texto\"\narchivo.write( nuevo_contenido )   # se borra TODO y se escribe el nuevo contenido\narchivo.close()\n</code></pre> <p>Caracteres escritos</p> <p><code>write()</code> tiene un valor de retorno num\u00e9rico que representa el n\u00famero de caracteres a\u00f1adidos al archivo.</p>"},{"location":"contenido/10-manejo_archivos/#writable","title":"<code>writable()</code>","text":"<p>Verifica que el archivo est\u00e9 en condiciones de ser escrito. Es afectado por los modos de apertura. </p> Verificar permisos de escritura<pre><code>archivo = open(ruta, \"r\")  # modo lectura con modificacion\nprint(archivo.writable() )    # da 'False'\n\narchivo = open(ruta, \"r+\")  # modo lectura con modificacion\nprint(archivo.writable() )    # da 'True'\n</code></pre>"},{"location":"contenido/10-manejo_archivos/#encoding","title":"<code>encoding</code>","text":"<p>La funci\u00f3n <code>open()</code> tiene un argumento opcional llamado <code>encoding</code> el cual permite elegir la codificaci\u00f3n para leer y escribir archivos.</p> Codificaci\u00f3n de archivos<pre><code>with open(\"archivo_utf8.txt\",\"w\", encoding=\"utf-8\") as archivo:\n    archivo.write( \"Hola UTF-8\")\n\nwith open(\"archivo_utf16.txt\",\"w\", encoding=\"utf-16\") as archivo:\n    archivo.write( \"Hola UTF-16\")\n\nwith open(\"archivo_utf32.txt\",\"w\", encoding=\"utf-32\") as archivo:\n    archivo.write( \"Hola UTF-32\")\n</code></pre>"},{"location":"contenido/10-manejo_archivos/#archivos-json","title":"Archivos JSON","text":"<p>Los archivos JSON (JavaScript Object Notation) son muy utilizados para guardar informaci\u00f3n en el formato de  los \"objetos\" de JavaScript, muy similar a los diccionarios de Python.</p>"},{"location":"contenido/10-manejo_archivos/#importacion","title":"Importaci\u00f3n","text":"<p>Python tiene el m\u00f3dulo dedicado json, el cual debe importarse para su uso: Importaci\u00f3n de m\u00f3dulo JSON<pre><code>import json\n</code></pre> Los archivos JSON deben estar codificados en formato <code>UTF-8</code>, <code>UTF-16</code> o <code>UTF-32</code>.</p>"},{"location":"contenido/10-manejo_archivos/#apertura-y-cierre","title":"Apertura y cierre","text":"<p>La operacion de apertura se hace con la funci\u00f3n <code>open()</code>, igual que con otros tipos de archivo. El cierre de archivo se hace con el m\u00e9todo <code>close()</code>*.</p> Apertura y cierre de JSON<pre><code># crear archvio\nruta = \"./datos.json\"\narchivo_json = open(ruta,\"w+\") \n# ....\narchivo_json.close()  \n</code></pre>"},{"location":"contenido/10-manejo_archivos/#guardado-de-diccionario","title":"Guardado de diccionario","text":"<p>La escritura de archivo se hace con la funci\u00f3n <code>dump()</code> del m\u00f3dulo json. Esta funci\u00f3n da la opci\u00f3n de a\u00f1adir un n\u00famero de espacios para el indentado a la salida. Si no se indica todo el contenido se guarda en un \u00fanico rengl\u00f3n</p> Guardado de diccionarios<pre><code># nombre de archivo de salida\nruta = 'data.json'\n\n#crear diccionario (\"objeto\" de JavaScript)\ndiccionario = {\n    \"Nombre\": \"Aitor\",\n    \"Apellido\":\"Tilla\",\n    \"Edad\": 38,\n    }\n\n# apertura archivo de salida\nwith open(ruta, 'w') as archivo_json:\n    # escribir archivo\n    json.dump(diccionario, archivo_json, indent=4)\n</code></pre> <p>N\u00f3tese que el archivo de salida JSON debe ser creado primero con la funci\u00f3n <code>open()</code> en modo escritura. La funci\u00f3n <code>dump()</code> requiere el descriptor de archivo para funcionar.</p>"},{"location":"contenido/10-manejo_archivos/#lectura-de-diccionario","title":"Lectura de diccionario","text":"<p>La lectura de los datos de archivo JSON se hace con la funci\u00f3n <code>load()</code> del m\u00f3dulo json. Esta lectura se hace tras la apertura del archivo con la funci\u00f3n <code>open()</code>.</p> Lectura de diccionarios<pre><code># nombre de archivo de entrada\nruta = 'data.json'\n\n#leer diccionario desde archivo JSON\nwith open(ruta) as archivo:\n    mi_data = json.load( archivo )  #lectura del diccionario desde JSON\n</code></pre>"},{"location":"contenido/10-manejo_archivos/#conversion-de-tipo-de-datos","title":"Conversion de tipo de datos","text":"<p>El m\u00f3dulo JSON incluye funciones para convertir diccionarios (objetos JSON) en textos simples y viceversa. Para ello se usan las funciones <code>loads()</code> y <code>dumps()</code>: </p> Conversi\u00f3n de diccionarios<pre><code>import json\n\n# datos en diccionario, compatible con JSON \ndiccionario = { \n    \"language\": \"es\",\n    \"theme\" : \"light\",\n    \"date\" : \"Jan 19\"\n    }\n\n# conversion a texto\ntexto = json.dumps( diccionario , indent=4)\n\n# conversion a diccionario\ndiccionario_2 = json.loads(texto)\n</code></pre> <p>Repasar tipos datos: diccionarios</p>"},{"location":"contenido/10-manejo_archivos/#rewferencias","title":"Rewferencias","text":"<p>StackOverflow - Difference between modes... </p>"},{"location":"contenido/11-excepciones/","title":"Errores y Excepciones","text":""},{"location":"contenido/11-excepciones/#error-de-sintaxis","title":"Error de Sintaxis","text":"<p>Los errores de sintaxis (SyntaxError) son violaciones de las reglas de escritura del lenguaje. El int\u00e9rprete las detecta a medida que ejecuta las rutinas.</p>"},{"location":"contenido/11-excepciones/#excepcion","title":"Excepci\u00f3n","text":"<p>Las excepciones son los errores detectados en tiempo de ejecuci\u00f3n. Muchos de ellos no pueden prevenirse completamente por dise\u00f1o.</p> <p>Ejemplos de excepciones habituales:</p> Excepci\u00f3n Significado <code>Exception</code> error gen\u00e9rico (etiqueta comod\u00edn). <code>IndexError</code> elemento de una lista, tupla, etc. con indice indicado inexistente. <code>KeyError</code> clave de un diccionario inexistente. <code>NameError</code> variable no definida. <code>ZeroDivisionError</code> se dispara ante una division por cero. <code>RecursionError</code> recursividad infinita de las funciones, nunca se resuelve la funcion recursiva. <code>TypeError</code> tipo de datos incorrecto. Ejemplo: indexado con un string. <code>ValueError</code> valores imposibles de manejar o traducir. Ejemplo: convertir a entero una frase. <code>ModuleNotFoundError</code> no se encuentra el m\u00f3dulo requerido. <code>ImportError</code> no se encuentra el elemento requerido del m\u00f3dulo especificado. <p>Ejemplos de excepciones</p> TypeError<pre><code>valor = vector[\"10\"]    #indice 'str' en vez de 'int'\n</code></pre> ValueError<pre><code>numero = int(\"hola\")    # \u00bfqu\u00e9 n\u00famero ser\u00eda ese?\n</code></pre> IndexError<pre><code>W = [1, 2, 3]   # Lista de 3 elementos\nZ = W[4]        # Elemento N\u00ba5 inexistente\n</code></pre> ZeroDivisionError<pre><code>x = 4\ny = 0\nz = x / y       \n</code></pre>"},{"location":"contenido/11-excepciones/#sintaxis","title":"Sintaxis","text":""},{"location":"contenido/11-excepciones/#uso-basico-clausulas-try-y-except","title":"Uso b\u00e1sico - Clausulas <code>try</code> y <code>except</code>","text":"<p>Las excepciones pueden manejarse mediante la estructura <code>try</code>- <code>except</code>:</p> Excepci\u00f3n gen\u00e9rica<pre><code>try:\n    #c\u00f3digo a prueba\nexcept:\n    #se detiene el c\u00f3digo a prueba\n    #se ejecuta un c\u00f3digo alternativo\n</code></pre> <p>Cl\u00e1usula <code>raise</code></p> <p>Agregando la cl\u00e1usula <code>raise</code> al final de la rutina de excepci\u00f3n se puede abortar la ejecuci\u00f3n tras mostrar el reporte de erroir predeterminado raise<pre><code>try:\n    #c\u00f3digo a prueba\nexcept:\n    #se detiene el c\u00f3digo a prueba\n    #se ejecuta un c\u00f3digo alternativo\n    raise\n</code></pre></p>"},{"location":"contenido/11-excepciones/#codigo-condicional-clausula-else","title":"C\u00f3digo condicional - Clausula <code>else</code>","text":"<p>Se puede colocar c\u00f3digo extra pasada la parte vulnerable del programa con la cl\u00e1usula <code>else</code>. Este c\u00f3digo s\u00f3lo se ejecuta si la ejecuci\u00f3n de la rutina vulnerable fue exitosa.</p> C\u00f3digo condicional<pre><code>try:\n    #c\u00f3digo a prueba\nexcept:\n    #se detiene el c\u00f3digo a prueba\n    #se ejecuta un c\u00f3digo alternativo\nelse:\n    #si no ocurri\u00f3 una excepci\u00f3n en \u201ctry\u201d\n    #se ejecuta c\u00f3digo adicional \n</code></pre>"},{"location":"contenido/11-excepciones/#codigo-de-cierre-clausula-finaly","title":"C\u00f3digo de cierre - Clausula <code>finaly</code>","text":"<p>Si se requiere ejecutar un trozo de c\u00f3digo s\u00ed o s\u00ed, el cual es independiente de la existencia o no de excepciones previas, se usa la cl\u00e1usula <code>finaly</code>:</p> C\u00f3digo de cierre<pre><code>try:\n    #c\u00f3digo a prueba\nexcept:\n    #se detiene el c\u00f3digo a prueba\n    #se ejecuta un c\u00f3digo alternativo\nfinally:\n    #c\u00f3digo obligatorio (se ejecuta al finalizar)\n</code></pre>"},{"location":"contenido/11-excepciones/#excepciones-especificas","title":"Excepciones espec\u00edficas","text":"<p>Se pueden crear f\u00e1cilmente m\u00faltiples rutinas de excepciones para abordar distintos tipos de error posibles.S\u00f3lo hay que indicar el nombre de la excepci\u00f3n indicada justo despu\u00e9s de la cl\u00e1usula <code>except</code>:</p> Excepciones m\u00faltiples<pre><code>try:\n    #c\u00f3digo a prueba\n\n    # division por cero\n    x = 4\n    y = 0\n    z = x / y       \n\n    #  error de indice\n    W = [1, 2, 3]\n    Z = W[4]            \n\nexcept ValueError:\n    print(\"Valor err\u00f3neo \")\n\nexcept TypeError:\n    print(\"Tipo de datos err\u00f3neo\")\n\nexcept ZeroDivisionError:\n    print(\"Division por cero\")\n\nexcept IndexError:\n    print(\"Error de \u00edndice\")\n</code></pre>"},{"location":"contenido/11-excepciones/#excepciones-como-variable","title":"Excepciones como variable","text":"<p>Se puede usar el comod\u00edn <code>Except</code> para guardar el tipo de excepci\u00f3n producida como una variable con ayuda de la cl\u00e1usula <code>as</code>. Esto se muestra a continuaci\u00f3n:</p> <p>Captando excepci\u00f3n gen\u00e9rica<pre><code>try:\n    #c\u00f3digo a prueba\nexcept Exception as variable_excepcion:\n    print(f\"Excepci\u00f3n producida: {variable_excepcion}\")\n    print( type(variable_excepcion) )\n</code></pre> La variable creada es del mismo tipo que la excepci\u00f3n disparada e internamente guarda su mensaje descriptivo.</p> <p>Ejemplo: captando 'ZeroDivisionError'</p> Division por cero<pre><code>try:\n    #c\u00f3digo a prueba\n    x = 4\n    y = 0\n    z = x / y       # division por cero\n\nexcept Exception as ex:\n    print(f\"Excepci\u00f3n producida: '{ex}'\")\n    print( type(ex) )\n</code></pre> Salida por consola<pre><code>Excepci\u00f3n producida: 'division by zero'\n&lt;class 'ZeroDivisionError'&gt;\n</code></pre>"},{"location":"contenido/11-excepciones/#referencias","title":"Referencias","text":"<p>StackOverflow - C\u00f3mo determinar tipo de excepci\u00f3n</p>"},{"location":"contenido/12-clases/","title":"Clases","text":""},{"location":"contenido/12-clases/#programacion-orientada-a-objetos","title":"Programacion Orientada a Objetos","text":"<p>La POO trabaja con clases. Las clases son objetos que poseen atributos y funcionalidad: - La funcionalidad de la clase es representada por m\u00e9todos, que son funciones espec\u00edficas de la  clase.  - Los atributos son valores guardados de los par\u00e1metros, es decir son variables internas de la clase.</p> <p>Las clases se definen as\u00ed:</p> <pre><code>class &lt;nombre_clase&gt;:\n    def __init__(self, &lt;param1&gt;, &lt;param2&gt;, ...):\n        #inicializacion (obligatoria)\n        self.&lt;atributo1&gt; = &lt;param1&gt;     \n        self.&lt;atributo2&gt; = &lt;param2&gt;\n</code></pre> <p>La palabra self indica la instancia actual. Para utilizar los atributos de cada instancia de clase se a\u00f1aden los m\u00e9todos, que se definen as\u00ed:</p> <pre><code>class &lt;nombre_clase&gt;:\n    def __init__(self, &lt;param1&gt; , &lt;param2&gt;, ...):   \n        #inicializaci\u00f3n (obligatoria)\n        self. &lt;atributo1&gt; = &lt;param1&gt;        \n        self. &lt;atributo2&gt; = &lt;param2&gt;\n\n    def &lt;metodo1&gt;(self):\n        #c\u00f3digo 1\n    def &lt;metodo2&gt;(self):\n        #c\u00f3digo 2\n</code></pre> <p>Para crear instancias (variables con el formato y m\u00e9todos de la clase) se llama a la clase y se asignan valores a todos los par\u00e1metros en orden excepto a self (\u00e9ste se omite):</p> <pre><code>&lt;nombre_instancia&gt; = &lt;nombre_clase&gt;(&lt;valor_1&gt;,&lt;valor_2&gt;,...)\n</code></pre>"},{"location":"contenido/12-clases/#atributos-publicos-y-privados","title":"Atributos p\u00fablicos y privados","text":"<p>Los atributos de la clase son p\u00fablicos por defecto, es decir pueden ser accedidos directamente por su nombre:</p> <pre><code>&lt;nombre_instancia&gt;.&lt;atributo&gt; = &lt;valor&gt;\n&lt;variable&gt; = &lt;nombre_instancia&gt;.&lt;atributo&gt;\n</code></pre> <p>Los atributos pueden ser eliminados llamando al deleter 'del':</p> <pre><code>del &lt;nombre_instancia&gt;.&lt;atributo&gt; \n</code></pre> <p>Para hacer que los atributos de la clase sean \"privados\" se les antepone en su definici\u00f3n dos guiones bajos ( __ ):</p> <pre><code>class &lt;nombre_clase&gt;:\n    def __init__(self, &lt;param1&gt; , &lt;param2&gt;, ...):   \n        #inicializaci\u00f3n (obligatoria)\n        self.&lt;atributo1&gt;    = &lt;param1&gt;  # atributo p\u00fablico      \n        self.__&lt;atributo2&gt;  = &lt;param2&gt;  # atributo privado\n</code></pre> <p>Si se intenta acceder a un atributo privado desde afuera de los m\u00e9todos de la clase no se disparar\u00e1 un error; en cambio se crear\u00e1 un atributo alterno con el mismo nombre. Por este motivo hay que evitar a toda costa el intentar acceder a los atributos privados desde afuera. </p>"},{"location":"contenido/12-clases/#getters-y-setters","title":"'getters' y 'setters'","text":"<p>En Python se prefiere evitar los m\u00e9todos 'get' y  'set' para lectura y escritura de atributos, por ello lo habitual es declarar p\u00fablicos los atributos de inter\u00e9s para el acceso externo y dejar privados los atributos con data interna de los m\u00e9todos. </p> <p>Este h\u00e1bito contrasta con otros lenguajes donde s\u00ed se habit\u00faa crear metodos espec\u00edficos para leer y escribir la data interna (ejemplo JavaScript).</p>"},{"location":"contenido/12-clases/#metodos-privados","title":"Metodos privados","text":"<p>Es posible crear metodos privados defini\u00e9ndolos con dos giones adelante, igual que se hace con los atributos:</p> <pre><code>class &lt;nombre_clase&gt;:\n    def __init__(self, &lt;param1&gt; , &lt;param2&gt;, ...):   \n        #inicializaci\u00f3n (obligatoria)\n        # codigo inicializacion\n\n    def publico(self):\n        self.__privado(self)\n        # codigo publico\n\n    def __privado(self):\n        # codigo privado\n</code></pre> <p>Si se intenta acceder a un metodo privado desde afuera de la clase se producir\u00e1 un error. </p> <p>Los m\u00e9todos privados son \u00fatiles para hacer rutinas auxiliares de los m\u00e9todos p\u00fablicos de la clase.</p>"},{"location":"contenido/12-clases/#propiedades-de-las-clases","title":"Propiedades de las Clases","text":""},{"location":"contenido/12-clases/#herencia","title":"Herencia","text":"<p>Una clase puede servir de referencia para otras clases. Si la clase de referencia (superclase) tiene definidos una serie de atributos y de m\u00e9todos entonces la clase \"hija\" (subclase) tambi\u00e9n tendr\u00e1 definidos  esos mismos m\u00e9todos y atributos.</p> <p>Ejemplo:  <pre><code># Clase padre\nclass Superclase:\n    def __init__(self, valor):\n        self.valor_original = valor      # atributo\n\n    def metodo_original(self):      # metodo        \n        print(\"Soy el m\u00e9todo de la clase padre\")    \n\n# Clase hija\nclass Subclase( Superclase ):\n    def __init__(self, x, y):\n        self.valor_agregado = y     # atributo a\u00f1adido\n        super().__init__(x)         # m\u00e9todo para heredar atributos\n\n    def metodo_agregado(self):      # metodo de la subclase\n        print(\"Soy el m\u00e9todo exclusivo de la clase hija\") \n</code></pre> Los objetos creados con la clase hija Subclase tienen acceso a los m\u00e9todos de la clase padre Superclase:</p> <pre><code>instancia = Subclase( 4 , -2 )\ninstancia.metodo_original()\ninstancia.metodo_agregado()\nprint(f\"Valores: x={instancia.valor_original}, y={instancia.valor_agregado}\")\n</code></pre>"},{"location":"contenido/12-clases/#super","title":"super()","text":"<p>El m\u00e9todo super() permite llamar al constructor de la clase padre  desde la clase hija y as\u00ed poder heredar los atributos de \u00e9sta. Esto tambi\u00e9n puede hacerse mediante el nombre de la superclase:</p> <p><pre><code># Clase hija\nclass Subclase( Superclase ):\n    def __init__(self, x, y):\n        self.valor_agregado = y     # atributo a\u00f1adido\n        Superclase.__init__(x)      # m\u00e9todo para heredar atributos\n</code></pre> Si en la clase hija no se a\u00f1aden atributos no es necesario llamar al constructor (\u00e9ste se hereda):</p> <pre><code># Clase hija\nclass Subclase( Superclase ):\n    pass            # herencia autom\u00e1tica\n</code></pre>"},{"location":"contenido/12-clases/#isistance","title":"isistance()","text":"<p>La funci\u00f3n isisttance() verifica si hay relaci\u00f3n entre un objeto (instancia) y una clase especificada.</p> <p>Modo de uso: <pre><code>retorno = isinstance( objeto, clase )\n</code></pre></p> <p>En base al ejemplo previo: C es subclase de A y de ambas se crean instancias llamadas a y c:</p> <pre><code>a = A()\nc = C()\n\nprint(isinstance(c, C))     # 'True'\nprint(isinstance(a, A))     # 'True'\n\nprint(isinstance(c, A))     # 'True' (debido a la herencia)\nprint(isinstance(a, C))     # 'False'\n</code></pre>"},{"location":"contenido/12-clases/#issubclass","title":"issubclass()","text":"<p>La funci\u00f3n issubclass() verifica si hay relaci\u00f3n entre un objeto (instancia) y una clase especificada</p> <p>Modo de uso: <pre><code>retorno = issubclass( Subclase, Superclase)\n</code></pre></p> <p>En el ejemplo previo:</p> <pre><code>print(issubclass(C, A))     # 'True': C es subclase de A\nprint(issubclass(A, C))     # 'False': A es SUPERclase de C\n\nprint(issubclass(B, A))     # 'False': A y B NO est\u00e1n vinculados\n</code></pre>"},{"location":"contenido/12-clases/#herencia-multiple","title":"Herencia m\u00faltiple","text":"<p>Una misma subclase puede heredar m\u00e9todos y atributos de varias superclases al mismo tiempo.</p> <p>Ejemplo: <pre><code># Superclase 'A'\nclass A:\n    def __init__(self):\n        self.x = 0\n    def procedencia(self):\n        print(\"Este m\u00e9todo proviene de A\")\n\n\n# Superclase 'B'\nclass B:\n    def __init__(self):\n        self.y = 0\n    def procedencia(self):\n        print(\"Este m\u00e9todo proviene de B\")\n\n\n# Subclase 'C' , hija de A y B\nclass C(B, A):      \n    pass            # herencia autom\u00e1tica (no a\u00f1ade nada)\n</code></pre></p> <p>La clase C hereda atributos y m\u00e9todos de ambas clases padre. Si hay alg\u00fan m\u00e9todo o atributo con mobres coincidentes entre padres entonces la clase hija mantendr\u00e1 la versi\u00f3n del primer padre en asignarse.</p> <p><pre><code># Se crea un objeto de la subclase\ninstancia = C()\n\n# Los atributos de A y B son accesibles\ninstancia.x = 7\ninstancia.y = 10\n# Los m\u00e9todos heredados tienen igual nombre --&gt; se mantiene el primero\ninstancia.procedencia()     # Da: \"Este m\u00e9todo proviene de B\"\n</code></pre> En el ejemplo, el m\u00e9todo procedencia() existe tanto en A como en B. Como B se asign\u00f3 primero como clase padre su versi\u00f3n del m\u00e9todo prevalece. </p> <p>Si se deseara a\u00f1adir m\u00e1s atributos a la subclase y usar el m\u00e9todo super() est\u00e1 el problema de superposici\u00f3n de inicializadores. La alternativa es llamar a los inicializadores como m\u00e9todo de las superclases.</p> <p>Ejemplo:</p> <pre><code># Subclase 'C' , hija de A y B\nclass C(B, A):      \n    def __init__(self):     \n        B.__init__(self)    # Inicializador de superclase 'B'\n        A.__init__(self)    # Inicializador de superclase 'A'\n</code></pre>"},{"location":"contenido/12-clases/#mro-method-resolution-order","title":"mro() ('method resolution order')","text":"<p>El m\u00e9todo .mro() de las clases permite consultar el orden de prioridad de las superclases. La superclase m\u00e1s importante se indica primero.</p> <p><pre><code>print(Clase.mro())  # orden del m\u00e1s relevante al \u00faltimo\n</code></pre> En general las clases padre son las m\u00e1s importantes, luego vienen las clases abuelo, etc. Y ante igual jerarqu\u00eda se le da prioridad a la primera clase en indicarse.</p>"},{"location":"contenido/12-clases/#polimorfismo","title":"Polimorfismo","text":"<p>El polimorfismo es el potencial de la subclase para reescribir las propiedades heredadas de la superclase. </p> <p>Supongamos el caso de dos clases, una es hija de la otra y ambas definen un m\u00e9todo con igual nombre llamado calculo.</p> <p><pre><code>class Superclase:\n    def __init__(self, valor):\n        self.valor = valor\n    def calculo(self, x):               # Definicion de un m\u00e9todo\n        print(f\"{self.valor * x} \")     # Producto\n\n\nclass Subclase( Superclase ):\n    def calculo(self, x):               # reescritura del m\u00e9todo heredado\n        print(f\"{self.valor ** x} \")    # Potencia\n</code></pre> Obs\u00e9rvese como el m\u00e9todo calculo puede ser reescrito en la clase hija en tanto que para la clase padre mantiene su f\u00f3rmula original:  <pre><code>p = Superclase(4)\np.calculo(3)    # Producto: da 12\n\nq = Subclase(4)\nq.calculo(3)        # Potencia: da 64\n</code></pre></p> <p>Con el nombre de clase las instancias pueden acceder tanto a los m\u00e9todos de las clases padre como a los m\u00e9todos de las clases hijas.</p> <p>Sintaxis: <pre><code>Clase.metodo( instancia, argumentos)    \n</code></pre></p> <p>En el ejemplo previo:</p> <pre><code>p = Superclase(4)       # instancia de clase padre\nSuperclase.calculo(p, 3)    # Producto: da 12\nSubclase.calculo(p, 3)      # Potencia: da 64\n\nq = Subclase(4)         # instancia de clase hija\nSuperclase.calculo(q, 3)    # Producto: da 12\nSubclase.calculo(q, 3)      # Potencia: da 64\n</code></pre>"},{"location":"contenido/12-clases/#composicion","title":"Composici\u00f3n","text":"<p>Las clases se pueden componer unas con otras: </p> <pre><code># Clase interior\nclass Simple:\n    def __init__(self):\n        self.valor = 0\n\n    def metodo(self):\n        print(f\"Valor interno: {self.valor}\")\n\n# Clase exterior\nclass Compuesta:\n    def __init__(self):\n        self.objeto = Simple()\n</code></pre> <p>En este caso la estructura ylos atributos y m\u00e9todos ya no pueden solaparse unos con otros cuando hay herencia m\u00faltiple. Como contrapartida se complica la estructura de datos.</p> <pre><code>instancia = Compuesta()           # creaci\u00f3n objeto compuesto\ninstancia.objeto.valor = 15       # acceso a atributos internos \ninstancia.objeto.metodo()         # acceso a m\u00e9todos internos\n# instancia.metodo()              # da ERROR\n</code></pre> <p>Una desventaja de la composici\u00f3n es la eliminaci\u00f3n del objeto interno si el objeto externo se elimina.</p>"},{"location":"contenido/12-clases/#agregado-agregacion","title":"Agregado (\"agregacion\")","text":"<p>Esta opci\u00f3n es una alternativa superadora a la composici\u00f3n.  Esta consiste en crear la instancia de la clase interna primero y luego pasarla como argumento para crear la clase exterior:</p> <pre><code># clase interior\nclass Simple:\n    def __init__(self):\n        self.valor = 0\n\n    def metodo(self):\n        print(f\"Valor interno: {self.valor}\")\n\n# clase exterior\nclass Agregada:\n    def __init__(self, referencia):\n        self.objeto = referencia\n\n# objeto de la clase interna\ninstancia_simple = Simple()   \n# clase interna como argumento para la otra\ninstancia_agregada = Agregada(instancia_simple)\n# acceso a atributos y m\u00e9todos\ninstancia_agregada.objeto.valor = 15        \ninstancia_agregada.objeto.metodo()\n</code></pre> <p>Referencias</p> <p>https://stackoverflow.com/questions/2627002/whats-the-pythonic-way-to-use-getters-and-setters</p> <p>https://docs.hektorprofe.net/python/herencia-en-la-poo/herencia-multiple/</p> <p>https://barcelonageeks.com/python-oops-agregacion-y-composicion/</p>"},{"location":"contenido/13-decoradores_abstracciones/","title":"Clases II - Decoradores, Abstracciones y M\u00e9todos Especiales","text":""},{"location":"contenido/13-decoradores_abstracciones/#decoradores","title":"Decoradores","text":"<p>Los decoradores a\u00f1aden c\u00f3digo a una funcion especificada de forma externa. El c\u00f3digo a\u00f1adido pueden ir antes, despu\u00e9s o alrededor de la funci\u00f3n.</p> <p>M\u00e1s sobre los decoradores</p>"},{"location":"contenido/13-decoradores_abstracciones/#decorador-property","title":"Decorador 'Property'","text":"<p>El decorador <code>property</code> es un tipo reservado de decoradores que permite crear m\u00e9todos de acceso, escritura y eliminaci\u00f3n que comparten nombre y que no requerir\u00e1n el uso de par\u00e9ntesis.</p> <p>Ejemplo de definici\u00f3n:</p> <p>Uso decorador Property<pre><code>class Persona:\n    def __init__(self, nombre):\n        self.__myname = nombre      # atributo privado\n\n    # Decorador 'Property'\n    @property                   # metodo \"getter\": acceso\n    def nombre(self):               \n        return self.__myname        \n\n    @nombre.setter              # metodo \"setter\": escritura\n    def nombre(self, nuevo_nombre):     \n        self.__myname = nuevo_nombre   \n\n    @nombre.deleter             # metodo \"deleter\": eliminacion\n    def nombre(self):                   \n        del self.__myname\n</code></pre> De esta forma los m\u00e9todos creados se ven y se usan como si fuesen atributos p\u00fablicos:</p> uso m\u00e9todos 'property'<pre><code># creacion de instancia\nyo = Persona(\"Yoh\")\n\n# Los m\u00e9todos son accedidos como si fueran atributos\nname = yo.nombre        # lectura\nyo.nombre = \"Meh\"       # escritura\ndel yo.nombre           # eliminaci\u00f3n\n</code></pre>"},{"location":"contenido/13-decoradores_abstracciones/#abstraccion","title":"Abstracci\u00f3n","text":"<p>Consiste en ocultar los detalles innecesarios y mostrar solamente las funcionalidades necesarias.</p> <p>En la pr\u00e1ctica la abstracci\u00f3n se realiza encapsulando los atributos y funcionalidades espec\u00edficos  adentro de funcionalidades m\u00e1s generales y por tanto m\u00e1s sencillos de manejar.</p>"},{"location":"contenido/13-decoradores_abstracciones/#clases-abstractas","title":"Clases Abstractas","text":"<p>Las clases abstractas sirven como plantilla para crear otras clases. De \u00e9stas no pueden crearse instancias de una clase abstracta; para crear las instancias se necesita crear subclases de la clase abstracta.</p> <p>Para crear clases abstractas deben importarse la clase <code>ABC</code> y el decorador <code>abstractclassmethod</code> desde el m\u00f3dulo <code>abc</code>: <pre><code>from abc import ABC, abstractclassmethod\n</code></pre></p> <p>La clase <code>ABC</code> es una clase abstracta que sirve de referencia para crear las dem\u00e1s como subclases. Por otra parte el decorador <code>abstractclassmethod</code> permite crear m\u00e9todos abstractos, los cuales  deben usarse o redefinirse s\u00ed o s\u00ed respetando adem\u00e1s los argumentos de entrada indicados.</p> <p>Clase abstracta<pre><code># Superclase abstracta\nclass Persona(ABC):\n\n    # inicializador abstracto: se invoca o se reemplaza\n    @abstractclassmethod\n    def __init__(self, nombre, edad, actividad):\n        self.nombre = nombre\n        self.edad   = edad  \n        self.actividad = actividad\n\n    #metodo abstracto vac\u00edo: debe redefinirse por las subclases SI O SI\n    @abstractclassmethod\n    def hacer_actividad(self):\n        pass                    # no hace nada             \n\n    # metodo opcional con comportamiento ya definido\n    def presentarse(self):\n        print(f\"Me llamo {self.nombre} y tengo {self.edad} a\u00f1os\")\n</code></pre> Lo interesante de crear un m\u00e9todo abstracto es que \u00e9ste obliga a las subclases a asignarle un comportamiento (polimorfismo) so pena de arrojar error.</p> Subclases de clase abstracta<pre><code># Subclases de la clase abstracta\nclass Estudiante(Persona):\n    def __init__(self, nombre, edad, actividad):\n        # uso inicializador abstracto\n        super().__init__(nombre,edad, actividad)\n\n    #polimorfismo sobre metodo abstracto (obligatorio)\n    def hacer_actividad(self):\n        print(f\"Estoy estudiando: {self.actividad}\")\n\n\nclass Trabajador(Persona):\n    def __init__(self, nombre, edad, actividad):\n        # uso inicializador abstracto\n        super().__init__(nombre,edad, actividad)    \n\n    #polimorfismo sobre metodo abstracto (obligatorio)\n    def hacer_actividad(self):\n        print(f\"Estoy trabajando en: {self.actividad}\")\n</code></pre> <p>Las clases derivadas de la clase abstracta se usan normalmente: Uso de subclases<pre><code>#instancias de las clases 'hijas'\nyo = Estudiante(\"Meh\",\"35\", \"developing\")  \nyo.presentarse() \nyo.hacer_actividad()    # uso metodo modificado\n\ntu = Trabajador(\"Tuh\",\"40\", \"SCRUM Mastering\")   \ntu.presentarse()\ntu.hacer_actividad()    # uso metodo modificado\n</code></pre></p> <p>Error: instancias directas</p> <p>La clase abstracta no admite instancias directas: <pre><code># instancia de clase abstracta\nyo = Persona(\"Meh\",\"35\")    # da ERROR\n</code></pre></p>"},{"location":"contenido/13-decoradores_abstracciones/#metodos-especiales-dunder","title":"Metodos Especiales ('dunder')","text":"<p>Los m\u00e9todos especiales son m\u00e9todos predefinidos del lenguaje Python para definir el comportamiento de las clases ante determinadas condiciones. Los m\u00e9todos especiales van marcados doble guion a ambos lados de su nombre.</p> <p>En este ejemplo se muestran algunos de los m\u00e9todos especiales m\u00e1s usados: </p> M\u00e9todos especiales<pre><code>class Persona:\n    # Inicializador de instancias\n    def __init__(self, nombre,edad):     \n        self.nombre = nombre\n        self.edad = edad\n\n    # Conversion a texto todo el contenido\n    def __str__(self):      \n        return f'Persona(nombre={self.nombre}), edad={self.edad}'\n\n    # Crea un formato para representar la clase como texto\n    def __repr__(self):     \n        return f\"Persona('{self.nombre}','{self.edad}')\"\n\n    # Metodos para la sobrecarga de operadores\n    # Ejemplo: suma de clases\n    def __add__(self, otro):        \n        nuevo_valor= self.edad + otro.edad  \n        return Persona(self.nombre+otro.nombre, nuevo_valor)\n</code></pre> <p>Ejemplo de uso:</p> <pre><code># Creacion objeto (instancia)\nyo = Persona('Sam', 138)\n\n# lectura del objeto como texto\ntexto = yo\nprint(texto)               \n\n# representacion del objeto en formato texto\nrepre = repr(yo)\nprint(repre)\n\n# Reconstruccion del objeto desde texto\nresultado = eval(repre)     # funcion  eval()\nprint(resultado.nombre)\nprint(resultado.edad)\n\n# \"Suma\" de clases \ntu = Persona('Ana', 89)\ntu_y_yo = tu + yo\nprint(tu_y_yo)\n</code></pre>"},{"location":"contenido/14-SOLID/","title":"Clases III - Principios SOLID","text":""},{"location":"contenido/14-SOLID/#principios-solid","title":"Principios SOLID","text":"<p>Los principios SOLID son una gu\u00eda de principios cuya aplicaci\u00f3n busca lograr las siguientes ventajas:</p> <ul> <li>1 - Mantenibilidad</li> <li>2 - Reusabilidad</li> <li>3 - Legibilidad</li> <li>4 - Extensibilidad</li> </ul> <p>SOLID son las siglas de los siguientes principios:</p> <ul> <li>SRP - Principio de Responsabilidad \u00danica</li> <li>OCP - Principio de Abierto/Cerrado</li> <li>LSP - Principio de Sustitucion de Liskov</li> <li>ISP - Principio de Segregacion de Interfaz</li> <li>DIP - Principio de Inversion de Dependencias </li> </ul> <p>La aplicaci\u00f3n de estos principios ayuda a mejorar la calidad del c\u00f3digo; sin embargo no es una tarea trivial y debe sopesarse en cada proyecto sus ventajas e inconvenientes.</p> <p>A continuacion se explica cada uno de estos principios.</p>"},{"location":"contenido/14-SOLID/#srp-principio-de-responsabilidad-unica","title":"SRP - Principio de Responsabilidad Unica","text":"<p>Cada clase debe tener una \u00fanica responsabilidad o tarea. Si se necesitan varias responsabilidades o tareas \u00e9stas deben repartirse en varias clases.</p> <p>Ejemplo: un auto. - Una clase \"Tanque\"  que registra el nivel de combustible del auto y gestiona la recarga.  - una clase  \"Auto\" que gestiona la posici\u00f3n y el movimiento del mismo consumiendo combustible del tanque.</p> <p>En este contexto \"Tanque\" es superclase de \"Auto\".</p> <p>Una misma clase puede tener varios metodos pero \u00e9stos deben estar asociados a la misma funcionalidad. En el ejemplo: \"Tanque\" no controla ni la posicion ni el movimiento del auto, en tanto que \"Auto\" no gestiona la carga de combustible.</p>"},{"location":"contenido/14-SOLID/#ocp-principio-de-abiertocerrado","title":"OCP - Principio de Abierto/Cerrado","text":"<p>Las entidades de software (clases, funciones) deben ser \"Abiertas para extension, cerradas para modificacion\".</p> <p>Ejemplo: una familia de clases para gestionar notificaciones remotas.</p> <p>La clase \"Notificador\" (superclase) crea un m\u00e9todo para manejar mensajes de notificacion cuyo comportamiento interno no est\u00e1 definido:</p> <pre><code>class Notificador:\n    def __init__(self, usuario, mensaje):\n        self.usuario = usuario          # objeto con datos del usuario\n        self.mensaje = mensaje\n\n\n    def Notificar(self):                # Metodo gen\u00e9rico\n        raise NotImplementedError       # error por comportamiento no definido\n</code></pre> <p>Las subclases se encargan de adaptar el envio de notificaciones en base a distintas v\u00edas de comunicacion: mail, SMS, etc. usando polimorfismo: </p> <pre><code>class NotificadorEmail( Notificador )\n    def Notificar(self):\n        print(f\"Enviando MAIL a {self.usuario.email}\")\n\nclass NotificadorSMS( Notificador )\n    def Notificar(self):\n        print(f\"Enviando SMS a {self.usuario.sms}\")\n\n# (otros)\n</code></pre> <p>De esta manera en vez de reescribir el m\u00e9todo de la clase original se crean clases hijas con el comportamiento deseado para cada situaci\u00f3n.</p>"},{"location":"contenido/14-SOLID/#lsp-principio-de-sustitucion-de-liskov","title":"LSP - Principio de Sustituci\u00f3n de Liskov","text":"<p>Toda subclase hereda todas las propiedades de su superclase. Pero esto puede introducir conflictos l\u00f3gicos bajo ciertas circunstancias.</p> <p>Ejemplo: capacidad de vuelo de las aves.</p> <pre><code>class Ave:\n    def volar(self):\n        return \"Puedo volar\"        # asumimos una propiedad general\n\nclass Avestruz(Ave):\n    def volar(self):\n        return \"NO puedo volar\"     # hay un conflicto de herencia\n</code></pre> <p>La soluci\u00f3n a este problema consiste en crear distintas clases intermedias alternativas entre s\u00ed que se repartan las propiedades conflictivas: </p> <pre><code>class Ave:\n    pass\n\nclass AveVoladora(Ave)\n    def volar(self):\n        return \"Puedo volar\"        \n\nclass AveNoVoladora(Ave)\n    pass   \n\nclass Avestruz(AveNoVoladora):\n    pass                        # No se hereda la propiedad de vuelo\n</code></pre>"},{"location":"contenido/14-SOLID/#isp-principio-de-segregacion-de-interfaz","title":"ISP - Principio de Segregacion de Interfaz","text":"<p>\"Ningun usuario debe ser obligado a usar interfaces que no necesite\". Hay que eliminar las dependencias que no se necesiten.</p> <p>Python no usa la creacion de interfases, como sucede con otros lenguajes. En Python las interfases son impl\u00edcitas.</p> <p>Ejemplo: dos clases llamadas 'Humano' y 'Robot' que representan las actividades de conjunto: comer, dormir y trabajar.</p> <pre><code># MAL\n# Clase abstracta gen\u00e9rica describiendo multiples actividades\nclass Actividades(ABC):\n    def trabajar(self):\n        print(\"Trabajando\")\n\n    def comer(self):\n        print(\"Comiendo\")\n\n    def dormir(self):\n        print(\"Durmiendo\")\n\n# Los humanos trabajan, comen y duermen\nclass Humano( Actividades ):\n\n# ERROR:\n# Los robots no comen ni duermen pero heredan estas actividades\nclass Robot( Actividades ):\n</code></pre> <p>Para aplicar este principio primero se crean las clases abstractas para declarar cada m\u00e9todo utilizable por las clases: <pre><code>from abc import ABC, abstractclassmethod\n\nclass Trabajador(ABC):\n    @abstractclassmethod\n    def trabajar(self):\n        pass\n\nclass Comedor(ABC):\n    @abstractclassmethod\n    def comer(self):\n        pass\n\nclass Durmiente(ABC):\n    @abstractclassmethod\n    def dormir(self):\n        pass\n</code></pre></p> <p>Cada clase s\u00f3lo usa las superclases abstractas que necesita y redefine sus m\u00e9todos:</p> <p><pre><code># Los humanos trabajan, comen y duermen --&gt; heredan todos\nclass Humano(Trabajador, Comedor, Durmiente):\n    def comer(self):\n        print(\"El humano est\u00e1 comiendo\")\n\n    def trabajar(self):\n        print(\"El humano est\u00e1 trabajando\")\n\n    def dormir(self):\n        print(\"El humano est\u00e1 durmiendo\")\n\n\n# Los robots no comen ni duermen --&gt; No heredan lo que no necesitan\nclass Robot(Trabajador):\n    def trabajar(self):\n        print(\"El ROBOT est\u00e1 trabajando\")\n</code></pre> De esta manera cada clase s\u00f3lo tiene acceso a los m\u00e9todos que tienen sentido para ella.</p> <p><pre><code># instancias de prueba\nhumano = Humano()\nrobot  = Robot()\n\n# m\u00e9todos accesibles para cada objeto\nrobot.trabajar()\n\nhumano.comer()\nhumano.trabajar()\nhumano.dormir()\n\n# m\u00e9todos no habilitados\n# robot.comer()         # da error (no est\u00e1 definido)\n# robot.dormir()         # da error (no est\u00e1 definido)\n</code></pre> En resumen, creando varios m\u00e9todos abstractos en clases separadas se previenen problemas de herencia.</p>"},{"location":"contenido/14-SOLID/#dip-principio-de-inversion-de-dependencias","title":"DIP - Principio de Inversion de Dependencias","text":"<ul> <li>Los modulos de alto nivel no deben depender de los modulos de bajo nivel. Ambos deben depender de abstracciones;</li> <li>Los detalles deben depender de las abstracciones y no al rev\u00e9s. </li> </ul> <p>En general, las clases de alto nivel se encargar\u00e1n de las generalidades en tanto que las clases de bajo nivel se dedicar\u00e1n a tareas espec\u00edficas.</p> <p>Ejemplo: una clase para un corrector ortogr\u00e1fico que depende de una clase de bajo nivel representando un diccionario.</p> <pre><code># MAL: 'CorrectorOrtografico' (alto nivel) depende de 'Diccionario' (bajo nivel)\n\n# clase bajo nivel\nclass Diccionario:\n    def verificar_palabra(self, palabra):\n        pass \n\n# clase alto nivel \nclass CorrectorOrtografico:\n    def __init__(self):\n        # composicion con una clase de menor nivel\n        self.diccionario = Diccionario()\n\n    def corregir_texto(self, texto):\n        pass\n\n\n# Uso de la clase de alto nivel\ncorrector = CorrectorOrtografico(Diccionario())\n</code></pre> <p>La soluci\u00f3n basada en el principio DIP consiste en crear una clase abstracta que sirva de base para  las clases aplicadas.</p> <pre><code>from abc import ABC, abstractmethod\n\n# clase abstracta de referencia\nclass VerificadorOrtografico(ABC):\n    @abstractmethod\n    def verificar_palabra(self, palabra):\n        pass\n\n\n# TODAS las otras clases se basan en la clase abstracta\n\n# clase bajo nivel\nclass Diccionario(VerificadorOrtografico):\n    def verificar_palabra(self, palabra):\n        pass\n\n\n# clase alto nivel (extra)\nclass ServicioWeb(VerificadorOrtografico):\n    def verificar_palabra(self, palabra):\n        pass\n\n\n# clase alto nivel\nclass CorrectorOrtografico:\n    def __init__(self, verificador: VerificadorOrtografico):\n        # agregacion con una clase abstracta\n        # el argumento est\u00e1 \"moldeado\" por una clase abstracta y por ello aceptar\u00e1 a cualquiera de sus clases hijas\n        self.verificador = verificador\n\n    def corregir_texto(self, texto):\n        pass\n\n\n# Uso de la clase de alto nivel\ncorrector = CorrectorOrtografico(Diccionario())\ncorrector = CorrectorOrtografico(ServicioWeb())\n</code></pre>"},{"location":"contenido/14-SOLID/#referencias","title":"Referencias","text":"<p>Soy Dalto - Curso de POO desde Cero (Completo)</p>"},{"location":"contenido/15-programacion_funcional/","title":"Programacion Funcional","text":""},{"location":"contenido/15-programacion_funcional/#listas-por-comprension-comprehension","title":"Listas por comprensi\u00f3n (comprehension)","text":"<p>las listas por comprensi\u00f3n se basan en el uso de variables calculadas a partir de una iteraci\u00f3n. Algunos ejemplos de listas creadas a partir de un bucle for pueden ser:</p> Listas por comprensi\u00f3n<pre><code>lista_ascendente  = [ i for i in range(&lt;maximo&gt;)]\nlista_cuadrado    = [ i * i  for i in range(&lt;maximo&gt;)]\nlista_ambas       = [ (i, i  * i ) for i in range(&lt;maximo&gt;)]\n</code></pre>"},{"location":"contenido/15-programacion_funcional/#funciones-lambda","title":"Funciones Lambda","text":"<p>Las funciones lambda son funciones an\u00f3nimas, las cuales se se definen as\u00ed:</p> <p>funcion lambda - sin nombre<pre><code>lambda v1 , v2:  expresion\n</code></pre> Esta forma de definirlas es \u00fatil para definir manejadores (handlers), es decir funciones que se ejecutan ante eventos espec\u00edficos del programa.</p> <p>Tip: manejadores (handlers)</p> Asignaci\u00f3n de handlers - funci\u00f3n com\u00fan<pre><code># definicion\ndef nombre_funcion(x):\n    return expresion(x)\n\n# asignacion\nhandler_evento = nombre_funcion\n</code></pre> <p>Con el uso de funciones lambda, esta rutina se reduce a:</p> Asignaci\u00f3n de handlers - funcion lambda<pre><code># defincion y asignacion en un solo pao\nhandler_evento = lambda v1 , v2:  expresion\n</code></pre> <p>Funciones flecha</p> <p>Las funciones lambda son an\u00e1logas a las funciones flecha de JavaScript y se usan de modo sumilar.</p> <p>Otro uso pr\u00e1ctico de las funciones simplificadas es crear funciones que s\u00f3lo se usar\u00e1n en una \u00fanica linea de c\u00f3digo, ahorrando la definici\u00f3n y asiganci\u00f3n de nombre habitual. Este modo de uso es muy habitual dentro de funciones <code>map()</code>, <code>reduce()</code>, etc, las cuales se explican m\u00e1s adelante.</p> <p>Si se requiere reutilizaci\u00f3n, a las funciones lambda se les puede asignar una variable para referenciarlas, el cual servir\u00e1 como nombre de funci\u00f3n:</p> <p>funcion lambda - con nombre<pre><code>variable_lambda = lambda v1 , v2:  expresion\n</code></pre> Y se llaman como una funci\u00f3n normal:</p> funcion lambda - llamado<pre><code>retorno = variable_lambda(valor_1,valor_2)\n</code></pre> <p>funci\u00f3n lambda: multiplicaci\u00f3n</p> <p>definici\u00f3n<pre><code>multiplicar = lambda a, b : a*b     \n</code></pre> uso<pre><code>resultado = multiplicar(2, 8)\n</code></pre></p> <p>Tip: funciones con argumentos preasignados</p> <p>Con las funciones lambda se puede crear variantes alternativas de otras funciones, por ejemplo asign\u00e1ndole  valores a algunos argumentos de entrada. Por ejemplo: crear varias funciones que calculan distintas potencias de un n\u00famero de entrada a partir de una funci\u00f3n gen\u00e9rica.</p> Alias de funciones<pre><code># funci\u00f3n con dos argumentos\ndef potencia(x,y):\n    return x**y\n\n# alias funcion, un argumento prefijado\ncuadrado    = lambda n: potencia(n, 2)      # y = 2\ncubo        = lambda n: potencia(n, 3)      # y = 3\n</code></pre> llamado y tipo<pre><code># uso\nprint( cuadrado(3)  )   # 3\u00b2 = 9\nprint( cubo(3)  )       # 3\u00b3 = 27\n\n# tipo\nprint(type(cuadrado ))       # &lt;class 'function'&gt;\nprint(type(cubo     ))       # &lt;class 'function'&gt;\n</code></pre> <p>Info</p> <p>N\u00f3tese que las funciones lambda son reconocidas por el int\u00e9rprete de Python como si fueran funciones normales.</p>"},{"location":"contenido/15-programacion_funcional/#funciones-de-orden-superior","title":"Funciones de Orden Superior","text":"<p>Son funciones capaces de ejecutar a otras funciones especificadas por el usuario. Estas funciones son indicadas por su nombre como argumento de la funcion de orden superior.</p> funcion de orden superior<pre><code>def funcion_superior (valor_1, valor_2, funcion_usuario):\n    # codigo\n    # ...\n    funcion_usuario(parametros)\n    # ...\n</code></pre> ejemplo<pre><code># Funcion orden superior\ndef incrementar_4 (x, f):\n    # 'f' es una funcion de entrada\n    return f(x) + 4\n\n# Funcion externa\ndef triplicar(x):\n    return x*3\n\n# Uso\nx = 7\ny = incrementar_4(x, triplicar)\nprint(y)    # Da (x)*3+4 = 25\n</code></pre>"},{"location":"contenido/15-programacion_funcional/#closures","title":"Closures","text":"<p>Las  'closures' son funciones de orden superior que dan como retorno una funci\u00f3n definida internamente. </p> Closures - Sintaxis<pre><code>def nombre_closure():\n    def funcion_interna(argumentos):\n        # rutina\n        return retorno\n\n    return funcion_interna\n</code></pre> Ejemplo closure<pre><code>#definicion \ndef sumar_diez():\n    def add(valor):\n        return valor + 10\n    return add  #funcion interna como retorno\n\n#uso\nclosure_sumar = sumar_diez()\nprint(closure_sumar(7))     # da 10 + 7 = 17\n</code></pre> <p>Una utilidad posible de las closures en englobar varias funciones internas alternativas y poder elegir una u otra dependiendo de un argumento.</p> <p>Otra utilidad posible es la creaci\u00f3n de decoradores, los cuales agregan caracter\u00edsticas a las funciones. M\u00e1s sobre los decoradores de Python.</p>"},{"location":"contenido/15-programacion_funcional/#map","title":"Map","text":"<p>La funci\u00f3n <code>map()</code> es una funcion de orden superior que facilita el procesamiento de datos iterables  (particularmente: listas) por una funci\u00f3n especificada, \"mapeando\" cada elemento de los datos de entrada con los argumentos de la funcion y evitando as\u00ed el uso de bucles y la asignacion elemento a elemento.</p> <p>Sintaxis: <pre><code>objeto_resultado = map(funcion, data_entrada_1, data_entrada_2, ...)\n</code></pre></p> <p>El retorno de la funcion map() es un objeto de clase <code>map</code> (una instancia). Con la funci\u00f3n <code>list()</code> se convierte dicho objeto en una lista de valores, recuperando as\u00ed los resultados de la funci\u00f3n interna. </p> map() - procesamiento de listas<pre><code>objeto_resultado = map(funcion, lista_entrada)\nresultado = list(objeto_resultado)\n</code></pre> <p>Ejemplo: elevar al cuadado todos los elementos de un vector</p> map() - ejemplo uso<pre><code>def potencia_2 (x):\n    return x**2\n\nvector = [2, 5, 14, 3]\nobjeto = map(potencia_2, vector)\ncuadrado = list(objeto)\n</code></pre> <p>La funcion <code>map()</code> admite multiples listas de entrada</p> map() - m\u00faltiples iterables<pre><code>def multiplicar(x,y):\n    return x*y\n\nvector = [2, 5, 14, 3]\nobjeto = map(multiplicar, vector, vector)\ncuadrado = list(objeto)\n</code></pre> <p><code>map()</code> acepta funciones lambda como argumento. Ejemplo:</p> map() - uso lambdas<pre><code>vector = [2, 5, 14, 3]\n\ncuadrado = list(map(lambda numero: numero **2 , vector) )\n</code></pre>"},{"location":"contenido/15-programacion_funcional/#filter","title":"Filter","text":"<p><code>filter()</code> es una funci\u00f3n que filtra de la lista de entrada los valores que cumplen con una condici\u00f3n l\u00f3gica definida por una funci\u00f3n especificada.  </p> <p>Sintaxis: filter() - sintaxis<pre><code>objeto_filtrados = filter(funcion_logica, data_entrada)\n</code></pre> Nuevamente la salida es un objeto de la clase <code>filter</code> y para leer la lista de elementos filtrados hay que recurrir a la funcion <code>list()</code>.</p> <p>Ejemplo: filtrar valores numericos mayores a diez de un vector</p> ejemplo: valores mayores a 10<pre><code>def mayor_a_10(x):\n    return True if x &gt; 10 else False  \n\nvector = [2, 5, -1, 48,-9,-25, 14, 3]\nobjeto= filter(mayor_a_10, vector)\nfiltrados = list(objeto)\n</code></pre> <p><code>filter()</code> tambi\u00e9n acepta funciones lambda como argumento. </p>"},{"location":"contenido/15-programacion_funcional/#reduce","title":"Reduce","text":"<p><code>reduce()</code> opera con todos los elementos de una lista de entrada, aplic\u00e1ndoles una funci\u00f3n especificada de manera acumulativa. Esto permite trabajar con un n\u00famero no predeterminado de argumentos agrupados dentro de una lista de entrada. Para ser utilizada debe ser importada previamente desde el m\u00f3dulo functools: Importaci\u00f3n de reduce()<pre><code>from functools import reduce\n</code></pre> Ejemplo: una productoria (producto sucesivo) de n\u00fameros englobados en una lista</p> <p>ejemplo: reduce() para hacer productoria<pre><code>def producto(x, y): \n    return x*y\n\nvector = [2, 5, -1, -3]\nproductoria = reduce(producto, vector)\n# 'productoria' es 2*5*(-1)*(-3) = 30\n</code></pre> Como el retorno de la funci\u00f3n <code>reduce()</code> es un valor no hace falta hacer conversiones de tipo adicionales.</p>"},{"location":"contenido/15-programacion_funcional/#partial","title":"Partial","text":"<p>La funci\u00f3n <code>partial()</code> permite asignar valores prefijados a una funci\u00f3n como argumentos. Devuelve como retorno un objeto de clase 'partial' el cual incluye toda la informaci\u00f3n agregada y que puede utilizarse como si fuera una funci\u00f3n lambda. De esta forma con <code>partial()</code> se puede crear una o varias funciones simplificadas.</p> <p>La funci\u00f3n <code>partial()</code> debe importarse desde el m\u00f3dulo functools:</p> Importaci\u00f3n de partial()<pre><code>from functools import partial\n</code></pre> <p>El formato general de esta funci\u00f3n es:</p> <p>Sintaxis de partial()<pre><code>objeto_partial = partial( nombre_funcion, arg1 = valor_1, arg2 = valor_2, ...)\n</code></pre> En caso de no indicarse los nombres de los argumentos \u00e9stos se asignar\u00e1n en orden de definici\u00f3n.</p> <p>Los objetos partial se usan igual que cualquier funci\u00f3n:</p> Uso de partial()<pre><code>valor = objeto_partial(argunentos)\n</code></pre> <p>Ejemplo N\u00aa1: cuadrado y cubo con partial()</p> <p>Ejemplo N\u00ba1: crear varias funciones que calculan distintas potencias de un n\u00famero de entrada.</p> <p><pre><code># funci\u00f3n general, dos par\u00e1metros \ndef potencia(x, exponente):\n    return x**exponente\n\n\n# se crean objetos 'partial' para casos particulares\ncuadrado = partial( potencia, exponente = 2 )\ncubo     = partial( potencia, exponente = 3 ) \n</code></pre> Estas funciones se usan f\u00e1cilmente invoc\u00e1ndolas por su nombre:</p> <pre><code>x = 3   # valor de entrada\n\nprint( cuadrado(x))     # 3\u00b2 = 9\nprint( cubo    (x))     # 3\u00b3 = 27\n\nprint(type(cubo))  # devuelve \" &lt;class 'functools.partial'&gt; \"\n</code></pre> <p>Ejemplo N\u00aa2: potencias con partial()</p> <p>En este ejemplo se crea una lista de funciones que calculan distintas potencias de un n\u00famero de entrada.</p> <p>definicion de partials<pre><code># funci\u00f3n general, dos par\u00e1metros \ndef potencia(x, exponente):\n    return x**exponente\n\n# lista de funciones lambdas\npotencias = []\nfor i in range(10):\n    # se fija el exponente\n    p = partial( potencia, exponente = i )\n    potencias.append(p)\n</code></pre> De este modo el \u00edndice de la funci\u00f3n lambda elegida representa el exponente elegido:</p> uso de partials<pre><code>x = 3   # valor de entrada\n\nprint( potencias[0](x) )        # 3\u2070 = 1\nprint( potencias[1](x) )        # 3\u00b9 = 3\nprint( potencias[2](x) )        # 3\u00b2 = 9\nprint( potencias[3](x) )        # 3\u00b3 = 27\nprint( potencias[4](x) )        # 3\u2074 = 81\n# ...\n</code></pre>"},{"location":"contenido/2-variables_asignaciones/","title":"Variables y Asignaciones","text":""},{"location":"contenido/2-variables_asignaciones/#tipos-de-variables","title":"Tipos de Variables","text":"<p>Las variables se crean al asignarles valor. Hay cuatro grandes tipos de variables:</p> Funci\u00f3n Uso <code>int</code> N\u00fameros enteros. <code>float</code> N\u00fameros flotantes. La parte decimal se indica con un punto. <code>string</code> 'Cadena de caracteres': secuencias de caracteres alfanum\u00e9ricos, lo m\u00e1s cercano al formato texto simple. <code>bool</code> Valores l\u00f3gicos booleanos. Dos opciones: <code>True</code> y <code>False</code>. <p>No hay valor l\u00edmite para las  variables num\u00e9ricas. Python distingue entre may\u00fasculas y min\u00fasculas a la hora de definir variables. </p> <p>Es convenci\u00f3n en Python que todas  las letras en los nombres de variables sean enteramente en min\u00fasculas y si est\u00e1n formados por varias palabras \u00e9stas se unan mediante guiones bajos (<code>_</code>). Pueden a\u00f1adirse n\u00fameros en los nombres pero no al comienzo.</p> <p>Tipado din\u00e1mico</p> <p>Python tiene tipado d\u00e9bil y din\u00e1mico:  las variables pueden cambiar de tipo durante la ejecuci\u00f3n, por ejemplo de <code>int</code> a <code>string</code>, de <code>string</code> a <code>float</code>, etc. a medida que se guardan nuevos valores.</p> <p>funci\u00f3n <code>type()</code></p> <p>El tipo de datos de una variable puede averiguarse con la funci\u00f3n <code>type()</code>.</p> Funci\u00f3n type()<pre><code>type(16)      # 'int'\ntype(1.27)    # 'float'\ntype(\"hola\")    # 'str'\n</code></pre> <p>Tip: n\u00fameros complejos</p> <p>Python incluye la posibilidad de trabajar con n\u00fameros complejos indicados como:  Formato<pre><code>&lt;complejo&gt; = &lt;real&gt; + &lt;imag&gt;j \n</code></pre> , donde tanto la parte real como la imaginaria pueden ser tanto <code>int</code> como <code>float</code>. (Aunque t\u00e9cnicamente los complejos en Python son una clase predefinida) Ejemplo<pre><code>n = 3 + 4j \n</code></pre></p>"},{"location":"contenido/2-variables_asignaciones/#asignaciones","title":"Asignaciones","text":"<p>Las asignaciones se realizan con el operador '='</p> Asignacion<pre><code>&lt;nombre_variable&gt; = &lt;valor&gt;\n</code></pre> <p>No hay car\u00e1cter de fin de instrucci\u00f3n visible, sino que se interpreta como tal el fin de rengl\u00f3n.</p> <p>Los espacios en blanco a ambos lados del signo <code>=</code> son buena pr\u00e1ctica en este lenguaje.</p> Ejemplos: asignaciones<pre><code>entero = 16      \nflotante = 1.27\nmensaje = \u201cHola mundo\u201d   #(tambi\u00e9n pueden usarse comillas simples)\n</code></pre> <p>Tip: asignacion multiple</p> <p>Se puede crear y asignar valor a m\u00faltiples variables en un solo rengl\u00f3n.  <pre><code>A, B, C = 1.6, 1 , \u201cHola mundo\u201d\nA, *otros, ultimo = 1.6, 1 , \u201cHola mundo\u201d, 14 , 8.9 , \u201cchanchito\u201d  \n#ver \u201cdesempaquetado de listas\u201d\n</code></pre> Tambien se puede asignar el mismo valor a varias variables en simult\u00e1neo: <pre><code>A = B = C = 7\n</code></pre></p>"},{"location":"contenido/2-variables_asignaciones/#indexacion-de-strings","title":"Indexaci\u00f3n de strings","text":"<p>En Python el primer valor de las cadenas de caracteres es el cero.  Para conocer la longitud de los string se usa la funci\u00f3n <code>len()</code>:</p> <p>Longitud de strings<pre><code>longitud = len(texto)\n</code></pre> Si la longitud del vector es n entonces su \u00faltimo elemento ser\u00e1 el n\u00famero (n-1). Para acceder a un elemento puntual se utiliza los corchetes ( <code>[]</code> ):</p> indice<pre><code>letra = texto[indice]\n</code></pre> <p>Si el indice cae afuera del string (indice &gt; n-1 )el programa da error de memoria y cancela la ejecuci\u00f3n. Sin embargo, en Python se tolera el uso de \u00edndices negativos mientras el m\u00f3dulo del \u00edndice sea menor a a la longitud de la cadena.</p> Ejemplo: indice fuera de rango<pre><code>texto = \"Hola mundo\"\nn= len(texto)         # n = 10 (diez letras)\n\nletra = texto[ 0]      # letra 'H'  \nletra = texto[ 9]      # letra 'o'  \nletra = texto[10]     # Error: fuera de rango \n\nletra = texto[-10]    # letra 'H' \nletra = texto[-11]    # Error: fuera de rango \n</code></pre> <p>Tip: indices y listas</p> <p>Este manejo de \u00edndices tambi\u00e9n se usa en los 'vectores' de Python, que son llamados 'listas' (o 'list'). Ver listas de Python.</p>"},{"location":"contenido/2-variables_asignaciones/#rebanado-slicing","title":"Rebanado (Slicing)","text":"<p>El rebanado consiste en seleccionar una parte del vector o string en base a \u00edndices num\u00e9ricos. Algunas formas de usar el rebanado son:</p> Rebanado<pre><code>vector[ inicio : ]  # copia desde el \u00edndice inicial hasta el final;\nvector[ : final ]   # copia desde el elemento cero hasta (final-1 );\nvector[ inicio : final ] #copia desde indice inicial hasta (final-1) ;\nvector[ inicio : final : paso ] #copia entre valores de \u00edndices pero salteando elementos definidos por 'paso' (valor de incremento);\nvector[ : ]     # copia todo;\n</code></pre> <p>Para invertir el orden de un vector se puede hacer:</p> Inversion de vector<pre><code>vector[:: -1]     # copia todo, incremento -1 --&gt; inversion del vector\n</code></pre>"},{"location":"contenido/2-variables_asignaciones/#conversion-de-variables","title":"Conversion de variables","text":"<p>A veces es necesario convertir los valores de una variable a un tipo de variable distinto. Otras veces se necesita asegurar que el tipo de variable es el requerido para una aplicaci\u00f3n y no otro. Para estos casos existen funciones en Python encargadas de la conversion de variables, estas son:</p> Funci\u00f3n Uso <code>str( )</code> Convierte a texto <code>int( )</code> Convierte a entero <code>float( )</code> Convierte a flotante <code>bool( )</code> Convierte a valor l\u00f3gico (booleano) <p>Las funciones son rutinas reutilizables con nombre, las cuales se usan as\u00ed: Uso funciones<pre><code>variable_salida = nombre_funcion( variable_entrada )\n</code></pre></p> Ejemplos: conversion de tipo<pre><code>pi = 3.1416   # numero flotante ('float')\n\ntexto = str( pi )     # '3.1416'\nentero = int(pi)      # '3'\nflotante = float(texto)       # '3.1416'\n</code></pre> <p>Las conversiones de un tipo a otro no siempre dan resultados evidentes. Como ejemplo, se muestra el resultado de convertir a valores l\u00f3gicos v\u00eda la funcion <code>bool()</code>:</p> <p>Conversi\u00f3n a booleanos<pre><code># entrada: enteros\nprint( bool( 2) )  # True\nprint( bool( 1) )  # True\nprint( bool( 0) )  # False\nprint( bool(-1) )  # True\n\n# entrada: caracteres y texto\nprint( bool(\"\")  )  # False\nprint( bool(\" \") )  # False\nprint( bool(\"a\") )  # True\n\n# entrada: flotantes\nprint(  bool(3.14) ) # True\nprint(  bool(0.0)  ) # False\n</code></pre> Hay que tener en cuenta que no todas las conversiones pueden realizarse, pudiendo dar lugar a la interrupci\u00f3n del programa. A continuacion se muestran algunos ejemplos: <pre><code># Ejemplo N\u00ba1\nentero = int( \"10\" )    # uso correcto\nentero = int( \"hola\" )  # ERROR: \u00bfqu\u00e9 numero equivale a \"hola\"?\n\n# Ejemplo N\u00ba2\nentero = int('3.1416')   # ERROR: se necesita pasar a flotante primero\nentero = int(float('3.1416'))   # correcto\n</code></pre></p>"},{"location":"contenido/2-variables_asignaciones/#tipado-de-variables","title":"Tipado de variables","text":"<p>Python permite 'tipar' (preasignar un tipo) a las variables. Esto permitir\u00e1 que el int\u00e9rprete pueda detectar inconsistencias al asignar valores a las variables.</p> <p>La forma de tipar los datos es usando los dos puntos y el nombre del tipo de datos. </p> <p>Formato: Tipado de variables<pre><code>entero   :  int\nflotante :  float\ntexto    :  str\nlogica   :  bool\n</code></pre></p> <p>Reducci\u00f3n de bugs por tipado</p> <p>El tipado manual en Python es suave: no impedir\u00e1 la ejecuci\u00f3n del programa ni tampoco la abortar\u00e1 al llegar a las asignaciones de valor no compatibles por tipos. En cambio \u00e9stas asignaciones ser\u00e1n remarcadas por el entorno de desarrollo, permitiendo que el desarrollador corrija el c\u00f3digo de ser necesario durante su escritura y ayudando a prevenir bugs (errores durante la ejecuci\u00f3n del programa) los cuales pueden ser dif\u00edciles de identificar sin el uso del tipado.</p> <p>Ejemplo aplicado: indexado de un string</p> <p><pre><code>indice: int             # tipado \ntexto = \"A la grande le puse Cuca\"\n\nindice = 10             # asignacion correcta\nletra = texto[indice]   # indexado correcto --&gt; letra 'e'\n\nindice = \"Simon\"        # tipo incorrecto --&gt; el int\u00e9rprete marca el error\nletra = texto[indice]   # fallo de programa\n</code></pre> N\u00f3tese como el tipado de la variable indice ayuda a prever el fallo de programa al asignarle un texto como valor, mas no impide su ejecuci\u00f3n </p>"},{"location":"contenido/2-variables_asignaciones/#metodos","title":"M\u00e9todos","text":"<p>Los m\u00e9todos son operaciones comunes que afectan a las variables. Son similares a las funciones  pero est\u00e1n dedicados a los elementos. Los m\u00e9todos se utilizan as\u00ed: Uso de m\u00e9todos<pre><code>&lt;variable&gt;.&lt;metodo&gt;(&lt;argumento1&gt;, &lt;argumento2&gt;, ...)\n</code></pre> donde los argumentos son valores de entrada que el m\u00e9todo utiliza para procesar y dar su resultado. Los argumentos pueden ser opcionales \u00fa obligatorios, dependiendo de cada m\u00e9todo y de la informacion que da cada argumento.</p> <p>Cada tipo de variable tiene sus propios m\u00e9todos predefinidos. En particular, las variables de tipo string tienen muchos m\u00e9todos dedicados para manejarlas. Algunos de sus m\u00e9todos m\u00e1s usados son:</p> M\u00e9todo (string) Uso <code>find( seq )</code> Indica la primera ubicacion de la secuencia indicada <code>replace( seq1, seq2 )</code> Reemplaza una secuencia por otra. <code>title()</code> Formatea como t\u00edtulo. <code>index()</code> Indica posici\u00f3n de  comienzo de la secuencia buscada. <code>isalnum()</code> Verifica si solo hay valores numericos (devuelve <code>True</code> o <code>False</code>). <code>isalpha()</code> Verifica si solo hay letras (devuelve <code>True</code> o <code>False</code>). <code>isdecimal()</code> Verifica si solo hay decimales (devuelve <code>True</code> o <code>False</code>). <code>isdig()</code> Verifica si solo hay d\u00edgitos (devuelve <code>True</code> o <code>False</code>). <code>islower()</code> Verifica si solo hay min\u00fasculas (devuelve <code>True</code> o <code>False</code>). <code>isupper()</code> Verifica si solo hay may\u00fasculas (devuelve <code>True</code> o <code>False</code>). <code>capitalize()</code> Devuelve el texto con primera letra  may\u00fascula y lo dem\u00e1s en minusculas. <code>lower()</code> Devuelve el texto en min\u00fasculas. <code>upper()</code> Devuelve el texto en may\u00fasculas. <code>strip()</code> Elimina del texto espacios en blanco a derecha y a izquierda. <code>lstrip()</code> Elimina del texto espacios en blanco a izquierda. <code>rstrip()</code> Elimina del texto espacios en blanco a derecha. <code>split( seq )</code> Divide el texto al detectar un car\u00e1cter o secuencia indicada. Devuelve una \"lista\" (arreglo) de strings. El caracter o secuencia <code>seq</code> se elimina del resultado. <p>La mayor\u00eda de estos m\u00e9todos mencionados no requiere argumentos obligatorios, aunque muchos de ellos implementan argumentos opcionales. </p> <p>Una excepci\u00f3n a la regla es el m\u00e9todo <code>split()</code> : <pre><code>lista_strings = texto_original.split( caracter_secuencia )\n</code></pre> Ejemplo de uso:</p> <p>Ejemplo: m\u00e9todo <code>split()</code></p> <pre><code>original = \"tengo 2 naranjas.\"\n# da una lista (arreglo) de strings\nnuevo = original.split(\"2\") # da [\"tengo \", \" naranjas.\"]\n# se separan los dos textos de la lista\nparte_1 = nuevo[0]  # \"tengo \"\nparte_2 = nuevo[1]  # \" naranjas.\"\n</code></pre> <p>Otra excepci\u00f3n es el m\u00e9todo <code>replace()</code>: <pre><code>nuevo = texto_original.replace(subcadena_a_reemplazar, texto_reemplazo, numero_reemplazos)\n</code></pre></p> <p>Ejemplo: m\u00e9todo <code>replace()</code></p> <pre><code>original = \"tengo 2 naranjas y 2 manzanas.\"\nnuevo = texto_original.replace(\"2\", \"dos\", 0 ) # no hace nada\nnuevo = texto_original.replace(\"2\", \"dos\", 1 ) # s\u00f3lo reemplaza el primer \"2\" por \"dos\"\nnuevo = texto_original.replace(\"2\", \"dos\", 2 ) # reemplaza ambos \"2\" por \"dos\"\n</code></pre>"},{"location":"contenido/2-variables_asignaciones/#entrada-de-datos-de-usuario","title":"Entrada de datos de usuario","text":"<p>Para que el usuario pueda ingresar datos se usa la funci\u00f3n <code>input()</code>:</p> input()<pre><code>texto_variable = input (mensaje_consola)\n</code></pre> <p>Ejemplo: lectura entero<pre><code>num = input(\u201cIngrese un n\u00famero: \u201d)    # 'string'\nnumero = int(num)                     # 'int'\n</code></pre> El retorno de <code>input()</code> es un <code>string</code>. Para convertir strings en entero puede usarse la funci\u00f3n <code>int()</code> , es tanto que para convertir strings en flotante se puede usar la funci\u00f3n <code>float()</code>. </p> <p>Importante: booleanos</p> <p>La funci\u00f3n <code>bool()</code> devuelve el valor l\u00f3gico <code>False</code> si su entrada es cero \u00f3 un string vac\u00edo, en caso contrario da <code>True</code>.</p>"},{"location":"contenido/2-variables_asignaciones/#salida-de-datos-a-pantalla","title":"Salida de datos a pantalla","text":"<p>La funci\u00f3n <code>print()</code> permite escribir en pantalla todos los tipos de variables del lenguaje sin importar su tipo. Adem\u00e1s elige autom\u00e1ticamente el formato m\u00e1s id\u00f3neo para la mayor\u00eda de los casos: si la variable es un entero se imprime un entero; si es un numero flotante se escribe como un numero flotante, si es un texto se escribe como un <code>string</code>, etc.</p> <p>Para imprimir el valor de una variable en pantalla simplemente se indica su nombre como argumento: variable en pantalla<pre><code>print(nombre_variable)\n</code></pre> Si se necesita hacer lo mismo con m\u00faltiples variables en un mismo rengl\u00f3n se escriben todas en orden, separadas por comas: multiples variables en pantalla<pre><code>print(&lt;variable1&gt;, &lt;variable2&gt;, &lt;variable3&gt;, &lt;...&gt; )\n</code></pre> <code>print()</code> concatena todos los argumentos que se le da al momento de la llamada.</p> <p>Es posible combinar textos fijos con variables, nuevamente esto se realiza separando textos y variables con comas.</p> <p>Ejemplo aplicado: texto fijo y variables</p> <pre><code>numero = 17\nprint(\"Valor num\u00e9rico: \", numero )\n</code></pre> <p>Hay una alternativa con mejor desempe\u00f1o en lo referente a la ejecuci\u00f3n llamada <code>f-string</code>, se explica a continuaci\u00f3n.</p>"},{"location":"contenido/2-variables_asignaciones/#f-strings","title":"F-Strings","text":"<p>Los formatted-strings son variables de texto que son afectadas por otras variables. Este es el formato: formato f-strings<pre><code>texto_variable = f'&lt;texto&gt; {&lt;variable&gt;}'\n</code></pre> Se comienza el string con una letra 'f', se abren comillas simples \u00f3 dobles y dentro de ellas se escriben los textos y las variables, estas \u00faltimas entre llaves. Puede haber m\u00faltiples segmentos de texto y m\u00faltiples variables, siempre y cuando cada variable tenga sus propias llaves:</p> formato f-strings - varias variables<pre><code>texto_variable  = f'&lt;texto1&gt; {&lt;variable1&gt;} &lt;texto2&gt; {&lt;variable2&gt;} &lt;...&gt;'\n</code></pre> <p>Los f-strings son muy usados adentro de  <code>print()</code> directamente:</p> salida a consola<pre><code>numero = 17\nprint(f\"Valor de la variable: {numero}\")  # \"Valor de la variable: 17\"\n</code></pre> <p>Colocando dos puntos y un n\u00famero se reservan espacios para el valor de una variable, los cuales se devan vac\u00edos en caso de ser necesario:</p> f-strings - espacios reservados<pre><code>numero = 17\nprint(f\"Valor de la variable: {numero:10}\") # diez espacios reservados para el n\u00famero\n</code></pre> <p>Para los n\u00fameros flotantes, colocar un numero tras un punto permite elegir cu\u00e1ntos decimales usar para representar el valor:</p> <p>f-strings - n\u00ba decimales<pre><code>flotante = 13.5136717\nprint(f\"Flotante: {flotante:.1}\")   # Muestra 'Flotante: 1e+01'\nprint(f\"Flotante: {flotante:.2}\")   # Muestra 'Flotante: 1.4e+01'\nprint(f\"Flotante: {flotante:.3}\")   # Muestra 'Flotante: 13.5'\nprint(f\"Flotante: {flotante:.4}\")   # Muestra 'Flotante: 13.51'\n</code></pre> Este mecanismo es combinable con la reserva de espacios vista previamente:</p> <p>Ejemplo: f-strings con espacios y decimales</p> <p><pre><code>flotante = 13.5136717\ntexto = f\"Flotante:{flotante:7.4}\" # seis espacios reservados para el numero, cuatro cifras\n\nprint(texto)  # da 'Flotante:  13.51'  \n</code></pre> N\u00f3tese que en el ejemplo previo hay una variable de cuatro cifras , un punto y siete espacios, por ello se autocompletar\u00e1 con dos espacios vac\u00edos. </p> <p>Para m\u00e1s opciones de formato ver el manual de entrada y salida de Python</p>"},{"location":"contenido/3-expresiones_operadores/","title":"Expresiones y Operadores","text":""},{"location":"contenido/3-expresiones_operadores/#expresiones","title":"Expresiones","text":"<p>Las expresiones son un conjunto de operandos (variables y valores) y operadores que al evaluarse dan un valor. Las expresiones se eval\u00faan de izquierda a derecha y respetando la jerarqu\u00eda de las operaciones. </p>"},{"location":"contenido/3-expresiones_operadores/#operadores","title":"Operadores","text":""},{"location":"contenido/3-expresiones_operadores/#operadores-aritmeticos","title":"Operadores Aritm\u00e9ticos","text":"<p>A continuaci\u00f3n se muestran los operadores aritm\u00e9ticos de Python, los cuales sirven para trabajar con n\u00fameros enteros y flotantes.</p> Operador S\u00edmbolo Suma + Resta - Multiplicaci\u00f3n * Division / Division entera // Exponente ** M\u00f3dulo % <p>Modo de uso: Formato operaciones aritm\u00e9ticas<pre><code>resultado = numero_1  &lt;operador&gt; numero_2\n</code></pre></p> Ejemplo: uso operaciones aritm\u00e9ticas<pre><code>n = 7 + 3   #  '10'  \nn = 7 - 3   #  '4'\nn = 7 * 3   #  '21'\nn = 7 / 3   #  '2.3333333333333335'\nn = 7 // 3  #  '2'\nn = 7 % 3   #  '1'\n</code></pre> <p>Tip: operadores aritm\u00e9ticos sobre strings</p> <p>Algunos operadores de Python permiten trabajar con <code>strings</code>: textos, frases, etc:</p> <ul> <li>El operador + tambi\u00e9n puede usarse para concatenar cadenas de texto (<code>strings</code>). </li> <li>Con el operador * se puede concatenar la misma frase un n\u00famero fijo de veces</li> </ul> Ejemplo: aritmetica sobre strings<pre><code>texto = \"hola_\"\ntexto + texto     # 'hola_hola_'\ntexto * 3         # 'hola_hola_hola_'\n</code></pre>"},{"location":"contenido/3-expresiones_operadores/#jerarquia-de-las-operaciones-aritmeticas","title":"Jerarqu\u00eda de las operaciones aritmeticas","text":"<p>Las operaciones aritm\u00e9ticas tienen una jerarqu\u00eda de aplicacion por defecto. Este es el orden de jerarqu\u00eda de las operaciones, de las primeras en aplicarse a las \u00faltimas: </p> <ol> <li>Par\u00e9ntesis </li> <li>Exponente </li> <li>Multiplicaci\u00f3n </li> <li>Divisi\u00f3n  </li> <li>Adici\u00f3n </li> <li>Sustracci\u00f3n</li> </ol> <p>Nemot\u00e9cnico jerarqu\u00edas: PEMDAS</p>"},{"location":"contenido/3-expresiones_operadores/#operadores-de-asignacion","title":"Operadores de Asignaci\u00f3n","text":"<p>Combinan operaciones aritm\u00e9ticas con la asignaci\u00f3n (=) a continuaci\u00f3n. A la variable de entrada se la afecta con el operador aritm\u00e9tico indicado y una variable o valor adicional.</p> <p>Ejemplo:  <pre><code>edad += 3\n</code></pre> equivale a: </p> <pre><code>edad = edad + 3\n</code></pre>"},{"location":"contenido/3-expresiones_operadores/#operadores-logicos","title":"Operadores L\u00f3gicos","text":"<p>Los operadores l\u00f3gicos trabajan con valores y variables booleanos. </p> <p>Modo de uso: Formato operaciones l\u00f3gicas<pre><code>resultado = valor_logico_1 &lt;operador&gt; valor_logico_2\n</code></pre> Los operadores disponibles son los siguientes:</p> Operador S\u00edmbolo Salida en 'True' Y (AND) and Ambas entradas son 'True' O (OR) or Al menos una entrada es 'True' NO (NOT) not Entrada 'False' O exclusiva (XOR) ^ Entradas distintas Anexo: tablas de verdad <p>Los resultados de cada operador l\u00f3gico se describen habitualmente con las tablas de verdad,  donde el emoji \u2705 es <code>True</code> y la celda vac\u00eda es <code>False</code>.:</p> entrada salida NOT \u2705 \u2705 entrada X entrada Y salida AND \u2705 \u2705 \u2705 \u2705 \u2705 entrada X entrada Y salida OR \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 entrada X entrada Y salida XOR \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 <p>Las tablas de verdad  son est\u00e1ndar: no dependen del lenguaje de implementaci\u00f3n</p>"},{"location":"contenido/3-expresiones_operadores/#jerarquia-de-operaciones-logicas","title":"Jerarqu\u00eda de operaciones l\u00f3gicas","text":"<p>Esta es la jerarqu\u00eda de mayor a menor: 1. not  2. and  3. or</p>"},{"location":"contenido/3-expresiones_operadores/#operadores-relacionales","title":"Operadores Relacionales","text":"<p>Los operadores relacionales permiten comparar n\u00fameros enteros y flotantes. </p> <p>Los operadores disponibles en Python son:</p> Operador S\u00edmbolo mayor &gt; menor &lt; igual == mayor o igual &gt;= menor o igual &lt;= distinto a != <p>Tip: operadores relacionales sobre strings</p> <p>El operador <code>==</code> sirve para comparar si dos <code>strings</code> (caracteres, frases, etc) son id\u00e9nticos. Los otros operadores tambi\u00e9n pueden usarse para comparar strings por longitud y por contenido de caracteres. </p> Ejemplo: comparando strings<pre><code>print('B'  &lt; 'A')   # False\nprint('B'  &gt;= 'A')  # True\nprint('ABC' &gt; 'A')  # True\nprint('ABC' == 'A') # False\nprint('ABC' &lt;= 'A') # False\n</code></pre>"},{"location":"contenido/4-tipos_datos/","title":"Tipos de Datos","text":""},{"location":"contenido/4-tipos_datos/#tipos-predefinidos","title":"Tipos predefinidos","text":"<p>Python tiene sus propios tipos de datos predefinidos para facilitar el manejo y la organizacion de la data guardada en las variables, agrup\u00e1ndolas en estructuras m\u00e1s grandes y con diferentes propiedades. </p> <p>El tipo de datos de una variable o estructura puede consultarse con la funci\u00f3n type():</p> <p>tipo de datos<pre><code>type( elemento)   # retorna el tipo de datos\n</code></pre> A continuacion se explican los tipos de datos est\u00e1ndar de Python.</p>"},{"location":"contenido/4-tipos_datos/#listas-list","title":"Listas (<code>list</code>)","text":"<p>Estructura de datos para almacenar m\u00faltiples valores en secuencia. Se delimita con los corchetes ( <code>[]</code> ). Los elementos se separan con comas. Se habit\u00faa dejar un espacio entre cada coma y su elemento siguiente.</p> Formato de listas<pre><code>lista = [elemento_1, elemento_2,  ...]\n</code></pre> <p>Los datos pueden ser de distintos tipos y pueden ser modificados tanto en valor como en tipo. </p> <p>Ejemplo:</p> <p><pre><code>Listado = [1, \u201chola\u201d, 78.3]\n</code></pre> Para acceder a un elemento de la lista en base a su indice \u00e9ste se indica entre corchetes: <pre><code>elemento = lista[indice]\n</code></pre> El primer \u00edndice tiene valor cero. Si el \u00edndice iguala o supera la longitud de la lista da error. Dicha longitud de la lista se puede obtener con la funci\u00f3n <code>len()</code> (viene del ingl\u00e9s length): <pre><code>longitud = len(lista)\n</code></pre></p> <p>Indices negativos</p> <p>Se pueden usar indices negativos hasta la longitud m\u00e1xima: \u00edndice <code>-1</code> es el \u00faltimo valor, \u00edndice <code>-2</code> es el pen\u00faltimo elemento, etc.</p> <p>Ejemplo: si una lista tiene 10 elementos entonces el rango de \u00edndices permitidos va de -10 a 9.</p> <p>Las listas pueden crearse vac\u00edas para ser completadas m\u00e1s tarde: <pre><code>lista = []\n</code></pre></p> <p>Las listas pueden ser definidas tambi\u00e9n usando la funci\u00f3n <code>list()</code>. Esta funcion tambi\u00e9n permite convertir otros tipos de datos a lista.</p> <p>Ejemplo aplicacion: Matrices</p> <p>Para hacer una matriz de valores se la puede construir en base a una lista que contenga a m\u00faltiples listas internas  separadas con comas.  Ejemplo: matriz 2 x 3<pre><code>matriz=[ [v11, v12, v13] ,  [v21, v22, v23] ]   # lista de listas de valores\n</code></pre></p>"},{"location":"contenido/4-tipos_datos/#metodos-de-las-listas","title":"M\u00e9todos de las listas","text":"<p>Para a\u00f1adir un nuevo elemento al final de la lista podemos usar el m\u00e9todo <code>append()</code>: <pre><code>lista.append(elemento)\n</code></pre> Si buscamos a\u00f1adir un elemento en una posici\u00f3n particular podemos hacerlo indicando un valor indice dentro del m\u00e9todo <code>insert()</code>:</p> <pre><code>lista.insert(indice , elemento)\n</code></pre> <p>Para eliminar un elemento puede usarse el m\u00e9todo <code>remove()</code>.\u00c9ste elimina la primera aparici\u00f3n del m\u00e9todo indicado. Si el elemento indicado no existe el m\u00e9todo devuelve error. <pre><code>lista.remove(elemento)\n</code></pre></p> <p>Para eliminar un elemento por \u00edndice y poder retornarlo se usa el m\u00e9todo <code>pop()</code>.Si el elemento indicado no existe el m\u00e9todo devuelve error.</p> <pre><code>elemento = lista.pop( )           # elimina  el \u00faltimo elemento\nelemento = lista.pop( indice )    # elimina el elemento por indice\n</code></pre> <p>La b\u00fasqueda de la posici\u00f3n de un elemento se hacer con el m\u00e9todo <code>index()</code>,el cual presupone que el elemento existe : <pre><code>indice = lista.index(elemento)\n</code></pre></p> <p>Tip: operador <code>in</code></p> <p>Para verificar la existencia de un elemento en la lista se puede usar el operador <code>in</code> el cual devuelve un valor booleano.</p> <p><pre><code>existe_elemento = elemento in lista     # valor l\u00f3gico: 'True' o 'False'\n</code></pre> Combinando este operador con el uso de condicionales se puede prevenir errores de ejecuci\u00f3n por intentar afectar elementos inexistentes.</p> <p>Ejemplo de uso: eliminar elemento</p> <p>1\u00ba aparicion<pre><code>if elemento in lista:\n    indice = lista.index(elemento) \n    lista.remove(elemento)\n</code></pre> por indice<pre><code>if indice &lt; len(lista):\n    elemento = lista.pop(indice) \n</code></pre></p> <p>Reescribir una posicion particular de la lista: <pre><code>lista[indice]  = nuevo_valor\n</code></pre></p> <p>Contar repeticiones de un elemento: m\u00e9todo <code>count()</code> <pre><code>lista.count(elemento):\n</code></pre></p> <p>Concatenar una segunda lista al final de la primera: m\u00e9todo <code>extend()</code></p> <pre><code>lista_1.extend(lista_2)\n</code></pre> <p>Invertir el orden de los elementos (cambios persistentes): m\u00e9todo <code>reverse()</code> <pre><code>lista.reverse()\n</code></pre></p> <p>Eliminar todo el contenido de la lista:</p> <pre><code>lista.clear()\n</code></pre> <p>Ordenar los elementos (cambios persistentes): m\u00e9todo <code>sort()</code> <pre><code>lista.sort()  # Orden ascendente por defecto\nlista.sort( reverse = True)  # Orden descendente\nlista.sort( key = funcion_ordenamiento)  # Criterios personalizables mediante una funcion lambda\n</code></pre></p> <p>Los argumentos de entrada <code>reverse</code> y <code>key</code> permiten alterar el orden y el criterio de ordenamiento de la funci\u00f3n: </p> <ul> <li><code>reverse</code>: booleano que permite invertir el orden. Es <code>False</code> por defecto.   </li> <li><code>key</code>: funci\u00f3n para especificar el criterio de ordenamiento de los elementos. Esta funci\u00f3n debe aceptar un solo elemento de la lista como entrada. Por defecto es <code>None</code>.</li> </ul> <p>Ejemplos de uso:</p> <p>Ejemplos: ordenar una lista de strings con <code>sort()</code></p> ordenamiento alfab\u00e9tico<pre><code>lista = [\"aaa\",  \"cccc\", \"bb\"]\nlista.sort()\nprint(lista)        # '['aaa', 'bb', 'cccc']'\n</code></pre> ordenamiento alfab\u00e9tico inverso<pre><code>lista = [\"aaa\",  \"cccc\", \"bb\"]\nlista.sort(reverse = True)\nprint(lista)        # '['cccc', 'bb', 'aaa']'\n</code></pre> ordenamiento por longitud de caracteres<pre><code>lista = [\"aaa\", \"bb\", \"c\"]\nlista.sort(key=len)     # hace 'len( elemento)' \nprint(lista)        # '['c', 'bb', 'aaa']'\n</code></pre>"},{"location":"contenido/4-tipos_datos/#copia-y-referencia-de-listas","title":"Copia y referencia de listas","text":"<p>Python permite apuntar a una lista preexistente con una simple asignaci\u00f3n: </p> Apuntador a lista<pre><code>referencia = lista\n</code></pre> <p>Si los elementos de la lista original son modificados entonces estos cambios se ver\u00e1n replicados en la lista de salida.</p> <p>Ejemeplo: cambios sobre lista</p> <pre><code># creacion de lista original\noriginal = [ 1, \"hola\", True]\n\n# la nueva lista muestra el mismo contenido que la oiginal \nreferencia = original            #  referencia\nprint(referencia)       # '[1, 'hola', True]'\n\n# al modificar la lista original la lista de salida cambia tambi\u00e9n\noriginal[1] = \"chau\"\nprint(referencia)            # '[1, 'chau', True]'\n</code></pre> <p>Si se requiere independizar una lista de la otra y as\u00ed prevenir cambios imprevistos se recurre a la copia.</p> <p>Tip: copia de listas</p> <p>Las listas tienen varias opciones para la copia de los valores. Una de ellas es el m\u00e9todo <code>copy()</code>:</p> <p>m\u00e9todo copy()<pre><code>copia = original.copy()\n</code></pre> funci\u00f3n list()<pre><code>copia = list(original)\n</code></pre> slicing y comprensi\u00f3n<pre><code>copia = original[:]             # copia por slicing\ncopia = [i for i in original]   # copia por comprension\n</code></pre></p> <p>Copia superficial y copia profunda</p> <p>Los m\u00e9todos de copia descritos previamente son de copia superficial. Esto significa que se copian los valores de las variables internas, pero en caso de haber listas u otros tipos de datos en el interior \u00e9stos se pasar\u00e1n por referencia y por tanto ser\u00e1n susceptibles a cambios.</p> <p>La alternativa es la copia profunda, la cual copia recursivamente todo el contenido interno de la lista creando as\u00ed una r\u00e9plica totalmente independiente del original.</p> <p>En Python se implement\u00f3 para tal fin la funci\u00f3n <code>deepcopy()</code>:</p> funci\u00f3n deepcopy<pre><code>from copy import deepcopy   # importacion de la funcion\ncopia = deepcopy(original)   # copia profunda\n</code></pre>"},{"location":"contenido/4-tipos_datos/#tuplas-tuple","title":"Tuplas (<code>tuple</code>)","text":"<p>Similar a las listas pero inmutables. Las tuplas se indican con par\u00e9ntesis ( <code>()</code> ) :</p> Definicion de tuplas<pre><code>tupla = (elemento_1, elemento_2, ...)\n</code></pre> <p>Las tuplas tambi\u00e9n pueden definirse mediante la funci\u00f3n <code>tuple()</code>.</p> <p>conversi\u00f3n de lista a tupla</p> <pre><code>lista = [3, \"a\", False]     # 'list'\ntupla = tuple( lista )      # 'tuple'\n</code></pre> <p>Los m\u00e9todos m\u00e1s habituales para trabajar con tuplas son <code>count()</code> e <code>index()</code>, este \u00faltimo combinado con el operador <code>in</code>.</p>"},{"location":"contenido/4-tipos_datos/#conjuntos-set","title":"Conjuntos (<code>set</code>)","text":"<p>Son una colecci\u00f3n de elementos no repetidos  y no ordenados. Para definirlos se usa la funci\u00f3n <code>set()</code> la cual descarta los elementos repetidos :</p> <pre><code>conjunto = set( lista_elementos  )\n</code></pre> <p>Los conjuntos tambi\u00e9n pueden ser inicializados con llaves ( <code>{}</code> ):</p> <pre><code>conjunto = {elemento_1, elemento_2, ...}\n</code></pre> <p>Los elementos de los sets no pueden ser consultados por \u00edndice. </p> <p>Sets de strings</p> <p><code>set()</code> trata las variables string como si fueran vectores de letras y por ello las descompone, devolviendo el conjunto de letras. </p> <p>Ejemplo: <pre><code>conjunto = {\"hola\"}         # '{'hola'}'\nconjunto = set(\"hola\")      #'{'l', 'o', 'h', 'a'}' \n</code></pre> Para mantener los strings integros estos pueden agruparse dentro de una lista mediante corchetes: <pre><code>conjunto = set( [\"hola\"] )    # '{'hola'}'\n</code></pre></p>"},{"location":"contenido/4-tipos_datos/#metodos-de-los-sets","title":"M\u00e9todos de los Sets","text":"<p>Para a\u00f1adir y quitar elementos se puede usar los m\u00e9todos <code>add()</code> y <code>remove()</code>: <pre><code>set_1.add(elemento)\nset_1.remove(elemento)\n</code></pre></p> <p>Los conjuntos no pueden ser consultados por \u00edndice. Para vaciar por completo el conjunto se usa el m\u00e9todo  <code>clear()</code>:</p> <p><pre><code>set_1.clear()\n</code></pre> Para crear un conjunto que re\u00fana elementos de otros dos se puede usar el m\u00e9todo <code>union()</code></p> <pre><code>nuevo_set = set_1.union( set_2 )\n</code></pre> <p>Con el m\u00e9todo <code>difference()</code> se puede listar todos aquellos elementos del primer conjunto que no est\u00e9n compartidos con el segundo:</p> <pre><code>set_no_compartidos = set_1.difference(set_2)\n</code></pre>"},{"location":"contenido/4-tipos_datos/#operadores-de-los-sets","title":"Operadores de los Sets","text":"<p>Los conjuntos se pueden relacionar tambi\u00e9n con operadores:</p> Operacion Retorno Elementos Simbolo Uni\u00f3n todos <code>|</code> Intersecci\u00f3n comunes <code>&amp;</code> Diferencia no repetidos (del set izquierdo) <code>-</code> Diferencia Sim\u00e9trica no repetidos (ambos sets) <code>^</code> <p>Ejemplo aplicado: operaciones sobre sets</p> Ejemplo aplicado: operaciones sobre sets<pre><code># conjuntos de ejemplo\nset_1 = {\"A\", \"B\", \"C\" , 1}\nset_2 = {\"A\", 1, \"X\"}\n\n# operaciones\nunion                = set_1 | set_2    # {1, 'C', 'B', 'X', 'A'}\ninterseccion         = set_1 &amp; set_2    # {1, 'A'}\ndiferencia           = set_1 - set_2    # {'C', 'B'}\ndiferencia_simetrica = set_1 ^ set_2    # {'C', 'B', 'X'}\n</code></pre>"},{"location":"contenido/4-tipos_datos/#diccionarios-dict","title":"Diccionarios (<code>dict</code>)","text":"<p>Son colecciones de pares clave-valor. Los diccionarios se definen con llaves ( <code>{}</code>) , el formato es el que sigue: Formato diccionario<pre><code>diccionario = {clave_1: valor_1, clave_2: valor_2, ... }\n</code></pre></p> <p>Las claves deben ser \u00fanicas e inmutables, y sirven para acceder a su valor asociado. Deben ser de tipo <code>string</code>. Los valores pueden ser de cualquier tipo. Los pares clave-valor s\u00ed pueden ser modificados, a\u00f1adidos y eliminados (son mutables).</p> <p>Ejemplo: definicion de diccionario</p> valor \u00fanico<pre><code>diccionario = {\"A\": 45, \"B\": 30}\n</code></pre> <p>M\u00faltiples valores</p> <p>Una misma clave puede tener m\u00faltiples valores agrupados en un tipo de datos acorde: una lista, una tupla, un set, un diccionario interno, etc.</p> valores m\u00faliples<pre><code>diccionario = {\"A\": {45, 30}}   # hace A = {45,30} (set)\ndiccionario = {\"A\": {45, 30} , \"A\": 5} # hace A=5 \n</code></pre>"},{"location":"contenido/4-tipos_datos/#metodos-y-operadores","title":"M\u00e9todos y operadores","text":"<p>Para acceder a un valor del diccionario se lo busca por su clave, la cual debe ser preexistente: <pre><code>valor = diccionario[clave]      # si la clave no existe da error\n</code></pre> Otra forma es usar el m\u00e9todo <code>get()</code>, el cual es m\u00e1s seguro :  <pre><code>diccionario.get(clave)  # si no se encuentra la clave se devuelve 'None'\n</code></pre></p> <p>Para a\u00f1adir o modificar un par clave - valor se hace una asignaci\u00f3n: <pre><code>diccionario[ nueva_clave ] = nuevo_valor\n</code></pre> Para eliminar una clave se usa el operador <code>del</code> (delete): <pre><code>del diccionario[clave]\n</code></pre></p> <p>La lectura de todas las claves de un diccionario se puede usar el m\u00e9todo <code>keys()</code>: <pre><code>claves = diccionario.keys()\n</code></pre> En tanto que las lectura de los valores se realiza con el m\u00e9todo <code>values()</code>: <pre><code>valores = diccionario.values()\n</code></pre></p> <p>La lectura de a pares clave-valor se hace con el m\u00e9todo <code>items()</code>: <pre><code>objeto_items = diccionario.items()   # objeto 'dict_items'\nlista_items = list(objeto_items)          # conversion a lista de tuplas clave-valor\n</code></pre> donde cada par se engloba en una tupla y el conjunto se agrupa en una lista.</p> <p>Con el operador <code>in</code> podemos chequear la existencia de una clave particular \u00f3 de un valor: <pre><code>existe_clave = clave in diccionario             # verificacion de clave directa\nexiste_valor = valor in diccionario.values()    # lectura de valores previa\n</code></pre></p> <p>Para crear un nuevo diccionario con claves pero todas con valor <code>None</code> existe el m\u00e9todo <code>fromkeys()</code>: <pre><code>diccionario = dict.fromkeys([clave_1, clave_2, ...] ) \n</code></pre></p>"},{"location":"contenido/4-tipos_datos/#tipado-de-datos","title":"Tipado de datos","text":"<p>Los datos aqu\u00ed analizados pueden ser tipados para ayudar a prevenir y corregir errores por incompatibilidad de tipos. </p>"},{"location":"contenido/4-tipos_datos/#datos-simples","title":"Datos simples","text":"<p>La notaci\u00f3n b\u00e1sica es igual a la del tipado de variables :</p> <p>Notaci\u00f3n general:</p> Tipado simple<pre><code>&lt;dato&gt;: &lt;tipo_dato&gt;\n</code></pre> <p>Los datos y variables internas tambi\u00e9n se pueden tipar. Para ello se a\u00f1ade el uso de corchetes para delimitar los tipos de variables internas.</p> Tipado de variables<pre><code>&lt;dato&gt;: &lt;tipo_dato&gt;[ &lt;tipo_variable1&gt;, &lt;tipo_variable2&gt;, ...]\n</code></pre> <p>Ejemplos</p> Tipado elemental<pre><code>lista_textos:       list\ntupla_enteros:      tuple\nconjunto_textos:    set\ndiccionario:        dict     \n</code></pre> Tipado de variables: listas, tuplas y conjuntos<pre><code>lista_textos:       list[  str ] # lista de cadenas de caracteres\ntupla_enteros:      tuple[ int ] # tupla de numeros enteros\nconjunto_textos:    set[   str ] # set de cadenas de caracteres\n</code></pre> Tipado de variables: diccionario<pre><code>diccionario: dict[str, int]     # clave texto, valor entero\ndiccionario = {\n    \"primero\": 4,     # correcto\n    \"segundo\": 7.5,   # error: tipo valor flotante\n        27   : 10 ,    # error: tipo clave entera\n    }\n</code></pre>"},{"location":"contenido/4-tipos_datos/#datos-compuestos","title":"Datos compuestos","text":"<p>El tipado tambi\u00e9n se puede usar para datos compuestos (), agrupando los tipos mediante corchetes. </p> <p>Ejemplo de uso: tipado de diccionario</p> <p>En este ejemplo se da tipado a un diccionario con claves de texto y listas de enteros como valor</p> <pre><code># tipado\ndiccionario_listas_enteros: dict[  str, list[int]  ]\n\n# uso\ndiccionario_listas_enteros = { \n    \"hola\": [1, 2, 7],          # correcto\n    \"chau\": [4,\"b\", 1],         # error:  string en la lista de valor \n    \"adios\": (4, 6) ,           # error: tupla como valor       \n    }\n</code></pre> <p>El tipado detallado para datos puede ser un desaf\u00edo debido a la variedad de datos y variables internos, especialmente cuando los datos son compuestos.</p> <p>Recordar: tipado d\u00e9bil</p> <p>Al igual que en el caso de las variables, el tipado manual es d\u00e9bil y no impide la ejecuci\u00f3n del programa en caso de encontrarse inconsistencias.</p>"},{"location":"contenido/4-tipos_datos/#funciones-para-datos","title":"Funciones para datos","text":""},{"location":"contenido/4-tipos_datos/#enumerar-elementos-enumerate","title":"Enumerar elementos - <code>enumerate()</code>","text":"<p>La funci\u00f3n <code>enumerate()</code> permite enumerar los elementos de una lista ,pero los convierte tambi\u00e9n a tupla. Require el uso de la funci\u00f3n <code>list()</code> para recuperar la data.</p> enumerate()<pre><code>lista = [1, \"hola\", True]\n\nobjeto = enumerate(lista) # tipo 'enumerate'\nenumerados = list(objeto) # conversion a lista\n\n# da '[(0, 1), (1, 'hola'), (2, True)]'\n</code></pre> <p>El \u00edndice inicial es <code>0</code> salvo indicaci\u00f3n contraria. El valor elegido de \u00edndice inicial se pasa como segundo valor de entrada para la funci\u00f3n <code>enumerate()</code>: </p> enumerate()<pre><code>lista = [1, \"hola\", True]\nindice_inicial = 27\n\nobjeto = enumerate(lista, indice_inicial )  # tipo 'enumerate'\nenumerados = list(objeto)   # conversion a lista\n\n# da '[(27, 1), (28, 'hola'), (29, True)]'\n</code></pre> <p>El resultado final  es una lista de tuplas que incluyen cada una un par indice-elemento. Ambos datos pueden extraerse f\u00e1cilmente con la cl\u00e1usula <code>for</code>:</p> Extraccion de valores<pre><code>for indice, elemento in enumerados:\n    print(f\"Indice: {indice}; elemento: {elemento}\")\n\n# texto en pantalla\n# 'Indice: 27; elemento: 1'\n# 'Indice: 28; elemento: hola'\n# 'Indice: 29; elemento: True'\n</code></pre> <p>M\u00e1s sobre la cl\u00e1usula <code>for</code>: control de flujo </p>"},{"location":"contenido/4-tipos_datos/#ordenamiento-de-datos-sorted","title":"Ordenamiento de datos - <code>sorted()</code>","text":"<p>La funci\u00f3n <code>sorted()</code> ordena los elementos de listas y diccionarios, por defecto de manera ascendente / alfab\u00e9tica. </p> <p>Ordenamiento de listas - sorted()<pre><code>lista_ordenada = sorted( lista                )   # orden ascendente\nlista_ordenada = sorted( lista, reverse=True  )   # orden descendente\nlista_ordenada = sorted( lista, key = funcion_ordenamiento )   # criterio de ordenamiento definido por funci\u00f3n\n</code></pre> Esta funci\u00f3n es muy similar al m\u00e9todo <code>sort()</code> de las listas, de hecho tiene los mismos argumentos de entrada (<code>reverse</code> y <code>key</code>). El resultado es una lista con los elementos.</p> <p>Esta funci\u00f3n tambi\u00e9n sirve para ordenar diccionarios:</p> Ordenamiento de diccionario - por clave<pre><code>lista_ordenada = sorted( diccionario                )   # orden ascendente\nlista_ordenada = sorted( diccionario, reverse=True  )   # orden descendente\nlista_ordenada = sorted( diccionario, key = funcion_ordenamiento )   # criterio de ordenamiento definido por funci\u00f3n\n</code></pre> <p>La funci\u00f3n presupone que el ordenamiento es por clave. Si en cambio se busca ordenar los elementos por valores hay que usar el m\u00e9todo <code>values()</code>:</p> Ordenamiento de diccionario - por valor<pre><code>lista_ordenada = sorted( diccionario.values()                )   # orden ascendente\nlista_ordenada = sorted( diccionario.values(), reverse=True  )   # orden descendente\nlista_ordenada = sorted( diccionario.values(), key = funcion_ordenamiento )   # criterio de ordenamiento definido por funci\u00f3n\n</code></pre> <p>El resultado en estos casos es una lista de tuplas con los pares clave-valor.</p>"},{"location":"contenido/4-tipos_datos/#lectura-desde-archivo-eval","title":"Lectura desde archivo - <code>eval()</code>","text":"<p>Para poder convertir a diccionario una variable <code>str</code> (por ejemplo, una lectura desde un archivo de texto) se usa la funci\u00f3n <code>eval()</code>:</p> Funci\u00f3n eval()<pre><code>diccionario = eval(texto)\n</code></pre> <p>Claves repetidas</p> <p>Hay que tener cuidado de no repetir las claves porque sino se pierden los valores m\u00e1s antiguos.</p> <p>Archivos JSON</p> <p>Los archivos JSON est\u00e1n dedicados al guardado de pares clave-valor. Los diccionarios pueden guardarse y leerse en estos archivos con ayuda del m\u00f3dulo <code>json</code>. Ir al tutorial sobre JSON</p>"},{"location":"contenido/5-control_flujo/","title":"Control de Flujo","text":""},{"location":"contenido/5-control_flujo/#saltos-condicionales-y-bucles","title":"Saltos condicionales y bucles","text":"<p>El control de flujo se realiza mediante saltos condicionales (cl\u00e1usulas <code>if</code>, <code>else</code>, etc) y mediante bucles condicionales (<code>while</code>, <code>for</code>).</p>"},{"location":"contenido/5-control_flujo/#saltos-condicionales","title":"Saltos Condicionales","text":""},{"location":"contenido/5-control_flujo/#clausula-if-si","title":"Clausula <code>if</code> (\"si\")","text":"<p>Ejecuta un trozo de c\u00f3digo solamente si el primer condicional es verdadero (retorna 'True').</p> condicional if<pre><code>if condicion:\n    # SI condicion == 'True':\n    # c\u00f3digo_condicional\n</code></pre>"},{"location":"contenido/5-control_flujo/#clausula-else-sino","title":"Cl\u00e1usula <code>else</code> (\"sino\"  )","text":"<p>Permite agregar rutinas que se ejecutan si las condiciones pevias no se cumplen.</p> condicional if-else<pre><code>if condicion:\n    # SI condicion == 'True':\n    # c\u00f3digo_condicional\nelse:\n    # SI condicion ==  'False':\n    # codigo_alternativo\n</code></pre>"},{"location":"contenido/5-control_flujo/#clausula-elif-sino-si","title":"Cl\u00e1usula <code>elif</code> (\"sino si\")","text":"<p>Permite agregar rutinas con condicionales  alternativos a la primera condici\u00f3n. condicional if-elif-else<pre><code>if condicion_1:\n    # SI condicion_1 == 'True':\n    # c\u00f3digo_condicional\nelif condicion_2:\n    # SI condicion_1 ==  'False' Y condicion_2 == 'True':\n    # codigo_condicional_alternativo\nelse:\n    # SI condicion_1 ==  'False' Y condicion_2 == 'False':\n    # codigo_alternativo_defecto\n</code></pre></p> <p>Puede haber m\u00faltiples cl\u00e1usulas elif pero s\u00f3lo una else y una sola if.</p> <p>Dos puntos</p> <p>Prestar atenci\u00f3n a los dos puntos ( <code>:</code> ), los cuales marcan el final de cada condicional.</p> <p>Indentaci\u00f3n</p> <p>Hay que respetar la indentaci\u00f3n que impone Python para que el programa funcione, de otro modo el programa se interrumpe. </p> <p>Es habitual en Python usar cuatro espacios para el tabulado; </p> <p>Hay una forma resumida para escribir la clausula if - else en un solo reng\u00f3n, esta es: <pre><code>instruccion1 if &lt;condicion&gt; else instruccion2\n</code></pre></p>"},{"location":"contenido/5-control_flujo/#bucles-condicionales","title":"Bucles condicionales","text":""},{"location":"contenido/5-control_flujo/#ciclos-while-mientras","title":"Ciclos <code>while</code> (\"mientras\")","text":"<p>Estructura de control que repite una instrucci\u00f3n o rutina mientras su condici\u00f3n de control se cumpla. Este tipo de bucles no tiene un numero predeterminado de iteraciones. Si la condici\u00f3n siempre es verdadera entonces el bucle ser\u00e1 infinito. Verificar que la condici\u00f3n de control se haga falsa eventualmente para permitir la salida del bucle es responsabilidad del programador. Formato:</p> bucle while<pre><code>while condicion:    # 'mientras condici\u00f3n == True:'\n    # rutina\n    # actualizacion variable control\n</code></pre> <p>Para forzar la interrupci\u00f3n la ejecuci\u00f3n de un bucle se puede usar la orden <code>break</code>, esto se hace dentro de un condicional interno del bucle. </p> <p>Si en cambio el bucle es infinito (<code>while True</code>) es indispensable incluir la orden <code>break</code> con un condicional acorde:</p> bucle while-True<pre><code>while True: # 'mientras SIEMPRE'\n    # rutina\n    # actualizacion variable control\n    if condicion_escape:\n        break\n</code></pre> <p>El bucle while puede ser usado en conjunci\u00f3n con el condicional <code>else</code> lo cual permite ejecutar una rutina alterna al bucle:</p> bucle while-else<pre><code>while condicion:    # 'mientras condici\u00f3n == True:'\n    # rutina\n    # actualizacion variable control\nelse:               # 'sino:'\n    #rutina alterna\n</code></pre> <p>Hint: cancelar ejecuci\u00f3n</p> <p>Si se ejecuta un prograam con un bucle infinito es posible interrumpirlo apretando \u2018Ctrl\u2019 + \u2018C\u2019</p>"},{"location":"contenido/5-control_flujo/#ciclos-for-para","title":"Ciclos <code>for</code> (\"para\")","text":"<p>Estructura de control que repite una instrucci\u00f3n o rutina un n\u00famero predefinido de veces. El fin del bucle se indica con el indentado, por tanto debe respetarse. Formato habitual:</p> bucle for - range()<pre><code>for indice in range(inicio, fin, incremento):\n    # Instruccion1\n    # Instruccion2\n    # \u2026\n</code></pre> <p>La variable <code>indice</code> es la variable que mantiene el conteo de las repeticiones. Tener en cuenta que el valor <code>fin</code> no se alcanza, sino que el bucle se interrumpe justo un ciclo antes. Si <code>inicio</code> es cero (<code>0</code>) no hace falta indicarlo. Y si el <code>incremento</code> es unitario (<code>1</code>) entonces tampoco hace falta indicarlo.</p> <p>Ejemplo: contar hasta tres<pre><code>for i in range(4):\n    # i: variable indice\n    print(i)        # da los n\u00fameros del cero al tres.\n</code></pre> N\u00f3tese el uso de una funci\u00f3n dentro del bucle llamada <code>range()</code>. \u00c9sta es una funci\u00f3n que retorna una lista (<code>list</code>) con los valores enteros entre los n\u00fameros <code>inicio</code> y <code>fin</code> (sin incluir este \u00faltimo) y con el <code>incremento</code> indicado. Ejemplos:</p> funci\u00f3n range() - completa<pre><code>inicio = 3\nfin = 12\nincremento = 2 \nlista_enteros = range(inicio, fin, incremento) # '[3, 5, 7, 9, 11]'\n</code></pre> funci\u00f3n range() - m\u00ednimo<pre><code>fin = 5\nlista_enteros = range( fin) # '[0, 1, 2, 3, 4]'\n</code></pre> <p>A diferencia de otros lenguajes de programaci\u00f3n, Python implementa el bucle <code>for</code> en base a recorrer un vector de elementos, una 'lista'. Esto permite implementar bucles <code>for</code> que no requieran el uso de variables indice sino que usan directamente los elementos internos, sean del tipo que sean. Formato: </p> bucle for - lista<pre><code>lista_elementos: list\nfor elemento in lista_elementos:\n    # Instruccion1\n    # Instruccion2\n    # \u2026\n</code></pre> <p>El bucle for puede aplicarse sobre strings, listas, tuplas y diccionarios:  </p> Ejemplo: recorrer string<pre><code>texto = \"hola mundo\"\nfor letra in texto:     #'texto' es 'str'\n    print(letra)        # muestra una letra a la vez\n</code></pre> <p>Listas y tuplas muestran un comportamiento an\u00e1logo (un elemento por iteraci\u00f3n), en tanto que los diccionarios podr\u00edan recorrerse as\u00ed:</p> <p>recorrer claves de diccionario<pre><code>for clave in diccionario:\n    print(clave)\n</code></pre> muestra las claves del diccionario una por una, en tanto que para mostrar los valores se puede usar el m\u00e9todo <code>values()</code>:</p> <p>recorrer valores de diccionario<pre><code>for valor in diccionario.values():\n    print(valor)\n</code></pre> Para consultar ambos elementos de a pares se puede recurrir al m\u00e9todo <code>items()</code> :</p> recorrer pares clave-valor de diccionario<pre><code>for clave, valor in diccionario.items():\n    print(clave, valor)\n</code></pre> <p><code>break</code> y <code>continue</code></p> <p>Para interrumpir el bucle antes de tiempo se puede usar la orden <code>break</code> asociada a un condicional. Como contrapartida de <code>break</code> existe la orden <code>continue</code> (similar al <code>goto</code> de C) sin embargo su uso es considerado actualmente como una mala pr\u00e1ctica.</p>"},{"location":"contenido/6-funciones/","title":"Funciones","text":""},{"location":"contenido/6-funciones/#funciones_1","title":"Funciones","text":"<p>Una funci\u00f3n es un bloque de c\u00f3digo reutilizable que ejecuta una sola tarea espec\u00edfica. </p>"},{"location":"contenido/6-funciones/#llamada","title":"Llamada","text":"<p>Para llamar a una funci\u00f3n (es decir, para usarla) se la invoca por su nombre:</p> <p>Llamada a funci\u00f3n<pre><code>variable_salida = funcion( valor_entrada)\n</code></pre> La funci\u00f3n puede disponer o no de un valor de salida , como puede requerir o no valores de entrada. Un ejemplo de funci\u00f3n sin valor de retorno es la funci\u00f3n <code>print()</code> , en tanto que una funcion que a menudo se usa sin argumentos de entradas es <code>input()</code>.</p>"},{"location":"contenido/6-funciones/#definicion","title":"Definicion","text":"<p>La definici\u00f3n de la funci\u00f3n es la especificaci\u00f3n del nombre de la funci\u00f3n y de su rutina interna,es decir su c\u00f3digo interior, el cual se ejecutar\u00e1 cada vez que la funci\u00f3n sea llamada.</p> <p>Formato de definici\u00f3n en Python:</p> Formato de definici\u00f3n<pre><code># definicion de funcion, sin valores de entrada\ndef nombre_funcion():\n    # C\u00f3digo funci\u00f3n\n    # ....\n    # final de c\u00f3digo\n\n\n# C\u00f3digo programa principal\n# ....\nnombre_funcion()         # llamada a la funci\u00f3n\n</code></pre> <p>En Python las funciones se definen antes de su primer llamado.</p> <p>Gu\u00eda de estilos</p> <p>Es una buena pr\u00e1ctica de estilo dejar dos renglones vac\u00edos debajo de cada definici\u00f3n de las funciones. Esto ayuda a interpretar visualmente hasta d\u00f3nde llega el c\u00f3digo de cada funci\u00f3n.</p>"},{"location":"contenido/6-funciones/#argumentos","title":"Argumentos","text":"<p>Los argumentos son los valores que se le asignan a los par\u00e1metros de entrada al llamar a una funci\u00f3n.</p> <p>argumentos de funciones<pre><code>nombre_funcion(valor_1, valor_2, ...) # funcion con argumentos de entrada asignados\n</code></pre> Si la funci\u00f3n tiene par\u00e1metros de entrada , es decir variables que afectar\u00e1n al resultado de la funci\u00f3n estos se indican entre los par\u00e9ntesis y separados por comas: </p> formato de definici\u00f3n - con argumentos de entrada<pre><code># definicion de funcion, con valores de entrada\ndef nombre_funcion(parametro_1, parametro_2, ...):\n    # C\u00f3digo funci\u00f3n\n    # ....\n    # final de c\u00f3digo\n\n\n# C\u00f3digo programa principal\n# ....\nnombre_funcion(valor_1, valor_2, ...)      # llamada a la funci\u00f3n\n</code></pre>"},{"location":"contenido/6-funciones/#xargs","title":"xargs","text":"<p>La funci\u00f3n puede aceptar un n\u00famero indefinido de par\u00e1metros (x-args) con ayuda del asterisco (<code>*</code>) :</p> argumentos indefinidos (x-args)<pre><code>def nombre_funcion( *variables ):\n    for valor in variables:\n        # C\u00f3digo funci\u00f3n\n        # ....\n        # final de c\u00f3digo\n</code></pre> <p>Esto crea una tupla interna que engloba a todos los argumentos sin nombre que se pasen por la entrada.</p> <p>T\u00f3mese por ejemplo una funci\u00f3n que muestra en pantalla los datos de entrada:</p> <p>x-args - variables entrada<pre><code>def funcion(*variables):\n    print(variables)\n    for v in variables:\n        print(f\"{v}\")\n\n\nfuncion(1, 3, 8, 4)  \n</code></pre> El resultado ser\u00e1 x-args - resultado<pre><code>(1, 3, 8, 4, 'hola')  \n1\n3\n8\n4\nhola \n</code></pre> En este caso se agrupan todos los valores de entrada juntos dentro de una tupla. Por otra parte, si a la entrada se mandan datos (listas, diccionarios, etc):</p> <p>x-args - datos entrada<pre><code>def funcion(*variables):\n    print(variables)\n\n\nfuncion( [1, 3, 8, 4] , {\"hola\":10, \"chau\":-7} )     \n# da '([1, 3, 8, 4], {'hola': 10, 'chau': -7})'   \n</code></pre> El resultado ser\u00e1 esta vez: x-args - resultado<pre><code>([1, 3, 8, 4], {'hola': 10, 'chau': -7})\n[1, 3, 8, 4]\n{'hola': 10, 'chau': -7}\n</code></pre> Se observa que se crea una tupla interna donde el primer valor es la lista de entrada y el segundo es el diccionario.</p>"},{"location":"contenido/6-funciones/#kargs","title":"kargs","text":"<p>Para cargar par\u00e1metros de diccionario como argumento (keyword args,o  kwargs) se usa el doble asterisco:</p> keyword args (k-args)<pre><code>def nombre_funcion( **diccionario_entrada ):\n    # C\u00f3digo funci\u00f3n\n    # ....\n    # final de c\u00f3digo\n</code></pre> <p>Por ejemplo, si a una funci\u00f3n se le pasa como argumentos:</p> k-args<pre><code>def funcion( **diccionario_entrada):\n    print(diccionario_entrada)\n    print(diccionario_entrada.keys())       \n    print(diccionario_entrada.values())\n\n\nfuncion(hola=10, chau=-7, saludo=\"Buenos dias\")\n#  da:\n# '{'hola': 10, 'chau': -7, 'saludo': 'Buenos dias'}'\n# 'dict_keys(['hola', 'chau', 'saludo'])'\n# 'dict_values([10, -7, 'Buenos dias'])'\n</code></pre> <p>la funci\u00f3n construye entonces un dicconario interno al que le incorporan los strings como claves y los valores asignados como valores de claves.</p> <p>Argumentos con nombre</p> <p>Los argumentos de este tipo de funciones deben explicitarse al llamar a la funci\u00f3n, porque no hay un orden predefinido de argumentos como en otras funciones. Es decir, los argumentos s\u00ed o s\u00ed deben pasarse como pares clave-valor tal como se mostr\u00f3</p> <p>Nombres de argumentos</p> <p>Los argumentos de entrada tienen las mismas restricciones de sintaxis que los nombres de variables. De hecho, los k-args est\u00e1n pensados para ser usados internamente como variables.</p> Errores de entrada<pre><code>funcion(\"Buenos dias\"=10 )  # ERROR: no se admiten strings como nombre de argumento\nfuncion(yo soy Sam = 5)     # ERROR: los nombres de argumentos no aceptan espacios en blanco\n</code></pre>"},{"location":"contenido/6-funciones/#valores-predefinidos","title":"valores predefinidos","text":"<p>A las funciones se les puede dar valores de entrada por defecto, de modo de poder omitir argumentos al llamarlas:</p> <p>Valores predefinidos<pre><code>def nombre_funcion( variable_1=valor_1 ,variable_2=valor_2 ):\n    #codigo\n</code></pre> Tambi\u00e9n se las puede llamar con el orden de los argumentos cambiado mediante asignaciones:</p> Valores predefinidos - cambio de orden de entrada<pre><code>retorno = nombre_funcion( variable_2=valor_2, variable_1=valor_1 )\n</code></pre>"},{"location":"contenido/6-funciones/#valor-de-retorno","title":"Valor de retorno","text":"<p>Las funciones pueden tener un valor de retorno, es decir un valor de salida. Este se incluye al final de la definici\u00f3n de la funci\u00f3n con la sentencia return:</p> formato de definici\u00f3n - con valor de retorno<pre><code>def nombre_funcion():\n    # C\u00f3digo funci\u00f3n\n    # ....\n    # final de c\u00f3digo\n    return valor_retorno  # asignacion de retorno\n\n\n# C\u00f3digo programa principal\n# ....\nretorno = nombre_funcion()    # llamada a la funci\u00f3n\n</code></pre> <p>La sentencia <code>return</code> marca el final de la ejecuci\u00f3n de la funci\u00f3n, por tanto si hay c\u00f3digo posterior a esta sentencia no se ejecutar\u00e1.</p> <p>El valor por defecto del retorno de las funciones es <code>None</code>.  El valor de retorno en Python puede ser pr\u00e1cticamente de cualquier tipo: un booleano, un string, un numero,una lista, un diccionario, un objeto de una clase especificada, etc. El el caso de no requerirse un valor de retorno el uso de <code>return</code> es opcional, tal como se muestra en los ejemplos previos </p> <p>En la terminal, si el valor de retorno se asigna a una variable entonces no se muestra en pantalla. S\u00f3lo se lo muestra si se pasa a la funci\u00f3n <code>print()</code>.</p>"},{"location":"contenido/6-funciones/#alcance-de-una-variable-scope","title":"Alcance de una variable (Scope)","text":"<p>Indica d\u00f3nde se puede usar una variable. Dos opciones:local y global.</p> <p>Las variables globales son definidas en el programa principal y son visibles s\u00f3lo en el programa principal. Para poder acceder a una variable global desde dentro de una funci\u00f3n se usa la palabra clave <code>global</code> : </p> Variables globales<pre><code>nombre_variable_global = 0      #creacion \n\ndef nombre_funcion():\n    # ...\n    global nombre_variable_global       # declaraci\u00f3n\n    valor = nombre_variable_global      # lectura\n    nombre_variable_global = 1          # modificaci\u00f3n\n</code></pre> <p>Las variables locales se definen dentro de las funciones y son de uso exclusivo de la funci\u00f3n que las crea.</p> <p>Ejemplo:  <pre><code># definicion de funcion, sin valores de entrada\ndef triplicar_x( ):\n    # variable local: a \n    a = 3\n    print(a) \n    # acceso a variable global x\n    global x \n    x = x * a \n\n\n# C\u00f3digo programa principal\n# variable global: x \nx = 7\ntriplicar_x( )  # '3'       \nprint(x)        # '21'\nprint(a)        # ERROR: variable local no visible desde afuera de la funcion\n</code></pre></p> <p>Uso de variables globales</p> <p>El uso de variablews globales se considera una mala pr\u00e1ctica y es mejor evitarlo siempre que sea posible.</p>"},{"location":"contenido/6-funciones/#tipado-en-las-funciones","title":"Tipado en las funciones","text":"<p>Las funciones de Python admiten tipado de sus argumentos de entrada y del valor de retorno  para detectar inconsistencias y prevenir posibles errores.</p> <p>La asignacion del tipo de datos de los argumentos se realiza con el operador dos puntos (<code>:</code>), en tanto que la asignaci\u00f3n del tipo de salida se realiza con el operador flecha (<code>-&gt;</code>)</p> <p>Ejemplo: calcular potencias enteras de un numero flotante Tipado de funciones<pre><code>def potencia(a: float, b: int) -&gt; float:    # retorno flotante\n    return a**b\n\n\nx = 2.73\ny = 3\nvalor = potencia(x, y)   \n</code></pre></p>"},{"location":"contenido/6-funciones/#funciones-recursivas","title":"Funciones Recursivas","text":"<p>La recursi\u00f3n consiste en definir algo en funci\u00f3n de si mismo. </p> <p>Las funciones recursivas son funciones que se llaman a s\u00ed mismas un numero limitado de veces (caso recursivo), cuidando de incluir las condiciones iniciales que permitan resolver la funci\u00f3n y detengan la invocaci\u00f3n de s\u00ed mismas (caso base).</p> <p>Ejemplos cl\u00e1sicos de algoritmos recursivos:</p> Serie de Fibonacci<pre><code>fib(n) = fib(n-1) + fib(n-2)    caso recursivo\nfib(1)=1 , fib(0)=0             caso base\n</code></pre> Factorial<pre><code>n!=n * (n-1)!   caso recursivo\n1! =0!=1        caso base\n</code></pre> <p>Las funciones recursivas sirven como alternativa al uso de bucles y a veces permiten resolver algoritmos de forma m\u00e1s simple; sin embargo suelen ocupar mayor uso de memoria por la necesidad de llamarse a s\u00ed misma m\u00faltiples veces para resolver el algoritmo.</p> <p>Ejemplo aplicado: factorial</p> <p>El factorial se calcula f\u00e1cilmente con una funci\u00f3n recursiva:</p> Factorial recursivo<pre><code># definicion de funcion recursiva\ndef factorial(n):\n    n = int(n)    \n    if n &gt; 1:\n        m = n * factorial(n-1)  # caso recursivo\n    else:\n        m = 1       # caso base\n    return m\n\n\n# Ejemplo de uso\nfor i in range(5):\n    print(f\"factorial de {i}: {factorial(i)}\")\n</code></pre>"},{"location":"contenido/6-funciones/#funcion-main","title":"Funci\u00f3n <code>Main()</code>","text":"<p>Python no requiere indicar explicitamente una funci\u00f3n principal (main) sino que presupone que la funci\u00f3n principal es la rutina del archivo invocado por el usuario o el sistema operativo. En cambio, las rutinas presentes en otros archivos ser\u00e1n consideradas por el int\u00e9rprete de Python como funciones \u00f3 rutinas secundarias.</p> <p>Para ejecutar una rutina \u00fanicamente en el programa principal (es decir, si se invoca directamente al archivo que las contiene ) se puede englobar la rutina con el siguiente condicional:</p> <p>Rutina exclusiva de main()<pre><code>if __name__ == \"__main__\" :\n    #rutina de la funcion main\n</code></pre> Esta forma es \u00fatil para crear demos y tests dentro de los archivos donde se crean funcionalidades, clases, etc. de modo que s\u00f3lo se ejecuten los demos cuando se los llama directamente.</p>"},{"location":"contenido/6-funciones/#argumentos-de-main","title":"Argumentos de <code>Main()</code>","text":"<p>Para leer los argumentos (valores) que se pasan al invocar el programa desde la terminal se puede usar el m\u00f3dulo <code>sys</code> y leer la variable <code>argv</code>, la cual es una lista con todos los argumentos en formato texto</p> argument values (argv)<pre><code>from sys import argv      #importacion del m\u00f3dulo del sistema\n\nlista_valores = argv        # lista de argumentos\n\nargumento_0 = argv[0]   # ruta del programa\nargumento_1 = argv[1]   # 1\u00ba argumento de entrada\nargumento_2 = argv[2]   # 2\u00ba argumento de entrada\n# ....\n</code></pre> <p>argv[0]</p> <p>Tener en cuenta que el primer valor de todos (<code>argv[0]</code>) es la ruta relativa del archivo del programa.</p> <p>Ejemplo 1: nombre y argumentos</p> <p>Un archivo 'entrada.py' con el c\u00f3digo:</p> <p><pre><code>import sys\n\nnumero_argumentos = len(sys.argv)\n\nfor i in range(numero_argumentos):\n    print(i , sys.argv[i])\n</code></pre> y al llamarlo con la terminal (ej: Bash)  as\u00ed:</p> <p><pre><code>py entrada.py hola 25 'hasta luego'\n</code></pre> dar\u00e1 como resultado la siguiente lista de argumentos numerados:</p> <p>Texto de salida<pre><code>0 entrada.py\n1 hola\n2 25\n3 hasta luego\n</code></pre> Se observa que el primer argumento coincide con el nombre del archivo de programa.</p> <p>Ejemplo 2: ruta y argumentos</p> <p>Si la rutina previa est\u00e1 alojada en un subdirectorio llamado 'carpeta':</p> Texto de salida<pre><code>py carpeta/entrada.py hola 30 'hasta luego'\n</code></pre> <p>dar\u00e1 como resultado esta vez:</p> <p>Texto de salida<pre><code>0 carpeta/entrada.py\n1 hola\n2 30\n3 hasta luego\n</code></pre> Se verifica entonces que el primer argumento es la ruta relativa del archivo de programa.</p> <p>M\u00e1s informaci\u00f3n sobre los argumentos de <code>main()</code>: m\u00f3dulo <code>sys</code></p>"},{"location":"contenido/8-entorno_virtual/","title":"Entorno virtual: m\u00f3dulo VENV","text":""},{"location":"contenido/8-entorno_virtual/#entornos-virtuales","title":"Entornos virtuales","text":"<p>Los entornos virtuales son instalaciones locales de los paquetes que permiten un mejor control de los paquetes y sus versiones, minimizando el riesgo de incompatibilidades entre paquetes, evitar problemas debidos a la actualizaci\u00f3n descuidada de los mismos, etc.</p> <p>Los entornos virtuales funcionan creando una version alterada de la variable PATH del sistema operativo en la que agragan al comienzo la ruta local con los paquetes del entorno. De esta manera el programa buscar\u00e1 sus dependencias primero en la ruta del entorno virtual y s\u00f3lo si no encuentra los paquetes all\u00ed los busca en la instalacion global. De esta manera la versi\u00f3n local de cada paquete tendr\u00e1 prioridad sobre la version global.</p>"},{"location":"contenido/8-entorno_virtual/#venv","title":"VENV","text":"<p>VENV es la herramienta integrada de Python para trabajar con entornos virtuales.</p>"},{"location":"contenido/8-entorno_virtual/#creacion-entorno-virtual","title":"Creacion entorno virtual","text":"<p>Se elige la ruta de un directorio donde se crear\u00e1 el entorno virtual: Creaci\u00f3n de entorno virtual<pre><code>py -m venv ruta_directorio\n</code></pre> Dentro del directorio elegido se crear\u00e1n todos los archivos y directorios auxiliares necesarios para empezar a trabajar. En ellos se guardar\u00e1 el ejecutable de Python y se guardar\u00e1n los paquetes a a\u00f1adirse al proyecto.</p>"},{"location":"contenido/8-entorno_virtual/#activacion-entorno-virtual","title":"Activacion entorno virtual","text":"<p>La activaci\u00f3n del entorno virtual consiste en colocar al comienzo de la variable PATH la ruta del entorno virtual creado. De esta manera el sistema operativo dar\u00e1 prioridad a los ejecutables y paquetes del entorno virtual respecto a sus equivalentes globales.</p> <p>El comando de activaci\u00f3n depender\u00e1 de la terminal usada.</p> Activaci\u00f3n - Bash (Linux and MacOs)<pre><code>source ruta_directorio/bin/activate  # Linux y MacOs\nsource ruta_directorio/Scripts/activate  # Windows\n</code></pre> <p>Activaci\u00f3n - CMD<pre><code>venv\\Scripts\\activate.bat\n</code></pre> </p> <p>Activaci\u00f3n - PowerShell<pre><code>venv\\Scripts\\Activate.ps1\n</code></pre> El entorno virtual permanecer\u00e1 activado hasta que se cierre la terminal o se desactive expl\u00edcitamente con el comando <code>deactivate</code>.</p>"},{"location":"contenido/8-entorno_virtual/#instalar-paquetes-manualmente","title":"Instalar paquetes manualmente","text":"<p>Los paquetes se instalan con el comando habitual: Instalar paquete Python<pre><code>pip install nombre_paquete\n</code></pre> Hay que asegurarse primero que el entorno virtual est\u00e9 activado.</p> <p>La lista de paquetes disponibles se realiza con el comando list: Listar paquetes<pre><code>pip list\n</code></pre> La lista puede guardarse en archivo: Guardar lista de paquetes<pre><code>pip list &gt; nombre_archivo.txt\n</code></pre></p>"},{"location":"contenido/8-entorno_virtual/#anotar-e-instalar-dependencias","title":"Anotar e instalar dependencias","text":"<p>La versi\u00f3n actual de los paquetes se puede guardar en formato texto con el comando freeze: Registrar paquetes<pre><code># paquetes actuales y su versi\u00f3n actual\npip freeze &gt; requirements.txt\n</code></pre> En el ejemplo se guardan todos los nombres de paquete y sus versiones en el archivo de texto requirementsd.txt. Esta lista creada sirve para automatizar la descarga e instalaci\u00f3n de todos los paquetes necesarios con un \u00fanico comando: Instalar lista de paquetes<pre><code># instalacion desde archivo\npip  install -r requirements.txt\n</code></pre> En el contexto de un entorno virtual se minimiza la lista de paquetes a instalar, mejorando el control sobre el proyecto y evitando instalar dependencias in\u00fatiles para el proyecto actual.</p>"},{"location":"contenido/8-entorno_virtual/#desactivar-entorno-virtual","title":"Desactivar entorno virtual","text":"<p>El entorno virtual se desactiva f\u00e1cilmente con el comando deactivate: Desactivar entorno<pre><code>deactivate\n</code></pre> De esta manera se retoma el uso de los paquetes globales de manera inmediata.</p>"},{"location":"contenido/8-entorno_virtual/#eliminar-entorno-virtual","title":"Eliminar entorno virtual","text":"<p>El entorno virtual se elimina borrando los directorios auxiliares del entorno:</p> Eliminar entorno<pre><code>deactivate\nrm -r ruta_directorio  # eliminacion recursiva\n</code></pre> <p>Eliminar entorno</p> <p>Prestar atenci\u00f3n a que el c\u00f3digo est\u00e9 afuera del directorio del entorno virtual antes de eliminarlo. </p>"},{"location":"contenido/8-entorno_virtual/#alternativas-a-venv","title":"Alternativas a VENV","text":"<p>Existen alternativas para crear entornos virtuales. Algunas de ellas son:</p> <ul> <li>VirtualEnv</li> <li>PIPENV</li> <li>Poetry</li> </ul>"},{"location":"contenido/8-entorno_virtual/#referencias","title":"Referencias","text":"<p>Documentaci\u00f3n oficial - VENV</p> <p>PythonLand - How to Create, Activate, Deactivate, And Delete</p>"},{"location":"contenido/9-fechas/","title":"Fechas y Horario","text":""},{"location":"contenido/9-fechas/#datetime","title":"Datetime","text":"<p>El m\u00f3dulo datetime est\u00e1 dedicado al trabajo con fechas y horarios. Para usarlo se necesita importarlo.</p> <p><pre><code>import datetime\n</code></pre> Al igual que en otros m\u00f3dulos se puede importar unicamente los elementos necesarios del mismo.</p>"},{"location":"contenido/9-fechas/#lectura-de-fechas","title":"Lectura de fechas","text":"<p>El objeto datetime maneja fechas y horarios en un \u00fanico objeto. </p> <pre><code>from datetime import datetime\n</code></pre> <p>Este objeto dispone del m\u00e9todo <code>now()</code> para consultar fecha y hora del sistema:</p> <pre><code>ahora = datetime.now()  #lectura fecha y hora actual (hora local)\nprint(ahora)\n</code></pre> <p>El objeto incluye variables internas (\"atributos\") con los par\u00e1metros temporales de la fecha y hora. \u00c9stos son de solo lectura. </p> <pre><code>print(ahora.year)\nprint(ahora.month)\nprint(ahora.day)\nprint(ahora.hour)\nprint(ahora.minute)\nprint(ahora.second)\n# (no hay campo para los milisegundos)\nprint(ahora.microsecond)\n</code></pre>"},{"location":"contenido/9-fechas/#metodos-de-lectura","title":"M\u00e9todos de lectura","text":"<p>El objeto datetime posee varios m\u00e9todos de lectura para extraer fecha, hora \u00f3 ambas juntas. Estos m\u00e9todos son <code>timestamp()</code>, <code>date()</code> y <code>time()</code>:</p> <p>Metodos de lectura<pre><code># M\u00e9todos de lectura disponibles\nprint(ahora.timestamp() )   # Fecha y hora en formato POSIX\nprint(ahora.date())         # Fecha\nprint(ahora.time())         # Hora\n</code></pre> El tiempo POSIX, tambien llamado tiempo UNIX, es el tiempo en segundos transcurrido desde el 1\u00ba de enero de 1970.</p>"},{"location":"contenido/9-fechas/#asignacion-de-fechas","title":"Asignacion de fechas","text":"<p>Si se necesita crear un objeto con fecha y hora particular  hay que cargarlos en la funci\u00f3n <code>datetime()</code> para crear un objeto nuevo. Los argumentos de esta funci\u00f3n  son los par\u00e1metros temporales en orden: a\u00f1o, mes , d\u00eda, hora , minuto , segundo, microsegundo: </p> <p><pre><code># conversion de fechas\nprimer_dia = datetime(2023,1,1)         #obligatorio: a\u00f1o, mes, dia\nprimer_dia = datetime(2023,1,1,3,6,9)   # opcionales: hora, minuto, segundo, etc    \nprint(primer_dia)\n</code></pre> Los par\u00e1metros de la hora son opcionales, en tanto que los par\u00e1metros de la fecha son obligatorios.</p>"},{"location":"contenido/9-fechas/#intervalos-de-tiempo","title":"Intervalos de tiempo","text":"<p>Con los objetos datetime se pueden calcular intervalos de tiempo con una simple resta entre objetos. En el ejemplo: tiempo transcurrido desde el \u00faltimo 1 de enero.</p> <pre><code>ahora = datetime.now()\nprimer_dia_anio = datetime(ahora.year,1,1)\n# Tiempo pasado desde el 1 de enero\ndiferencia_temporal = ahora - primer_dia_anio\nprint(diferencia_temporal)\n</code></pre>"},{"location":"contenido/9-fechas/#date","title":"<code>date()</code>","text":"<p>La funci\u00f3n <code>date()</code> permite manejar fechas prefijadas:</p> <pre><code>from datetime import date\n\nfecha_actual = date(2023,12,25)  # fecha especificada: Navidad\n\nprint(fecha_actual )\nprint(fecha_actual.year )\nprint(fecha_actual.month )\nprint(fecha_actual.day )\n</code></pre> <p>Con esta funci\u00f3n se puede leer tambi\u00e9n  la hora del sistema directamente con ayuda del m\u00e9todo <code>today()</code>:</p> <pre><code>from datetime import date\n\nfecha_actual = date.today()      # fecha de hoy\n\nprint(fecha_actual )\n</code></pre>"},{"location":"contenido/9-fechas/#time","title":"<code>time()</code>","text":"<p>La funci\u00f3n <code>time()</code> sirve para trabajar con horarios prefijados: </p> <p><pre><code>from datetime import time\n\nhora_actual = time(17, 10, 6)       # asignacion manual\n\nprint(hora_actual)\nprint(hora_actual.hour)\nprint(hora_actual.minute)\nprint(hora_actual.second)\n# print(hora_actual.microsecond)      # no se usa\n</code></pre> Esta funci\u00f3n no es capaz de leer la hora del sistema directamente, sino que lo hace a trav\u00e9s del objeto datetime() y su m\u00e9todo <code>now()</code>:</p> <pre><code>from datetime import datetime\n\nahora = datetime.now()  #lectura fecha y hora actual (hora local)\n\nprint(ahora.time())         # Hora\n</code></pre>"},{"location":"contenido/9-fechas/#timedelta","title":"<code>timedelta()</code>","text":"<p>La funci\u00f3n <code>timedelta()</code> crea objetos que permiten calcular tiempos entre fechas especificadas como argumento.</p> <pre><code>from datetime import timedelta\n#tiempos\ninicio = timedelta(0, 0, 0)\nfin    = timedelta(0, 2, 1, 7)\n# diferencia temporal\nprint(fin - inicio)     \n</code></pre> <p>Argumentos no ordenados</p> <p><code>timedelta()</code> no tiene ordenados los argumentos. Para imponerlos se pueden asignar cada par\u00e1metro con su plabra reservada , las cuales recorren el rango de los microsegundos hasta las semanas: <pre><code>instante = timedelta(\n    weeks        = 1,\n    days         = 3, \n    hours        = 2, \n    minutes      = 14, \n    seconds      = 7, \n    milliseconds = 900,\n    microseconds = 815\n    )\n</code></pre></p>"},{"location":"contenido/decoradores/","title":"Decoradores","text":"<p>Los decoradores son funciones auxiliares que permiten agregar c\u00f3digo tanto antes como despu\u00e9s de la funci\u00f3n que se les indique. \u00c9stos permite implementar modificaciones a las funciones sin modificar su c\u00f3digo interno.</p>"},{"location":"contenido/decoradores/#definicion-formato-funcion","title":"Definici\u00f3n - Formato funci\u00f3n","text":""},{"location":"contenido/decoradores/#idea-basica","title":"Idea b\u00e1sica","text":"<p>Los decoradores suelen definirse mediante funciones, de forma que \u00e9stas  engloben unas dentro de otras formando una closure. Este es el formato b\u00e1sico de definici\u00f3n:</p> Definici\u00f3n de decoradores<pre><code>def nombre_decorador(funcion_entrada):\n    def funcion_envolvente()\n        # rutina previa\n        funcion_entrada()\n        # rutina posterior\n\n    return funcion_envolvente\n</code></pre>"},{"location":"contenido/decoradores/#funciones-con-argumentos","title":"Funciones con argumentos","text":"<p>En la definici\u00f3n previa se asumi\u00f3 que la funci\u00f3n no requiere argumentos de entrada. Los argumentos pueden pasarse de manera gen\u00e9rica con ayuda de los xargs y kargs:</p> Definici\u00f3n de decoradores - Funciones con argumentos<pre><code>def nombre_decorador(funcion_entrada):\n    def funcion_envolvente(*args, **kwargs):\n        # rutina previa\n        funcion_entrada(*args, **kwargs)\n        # rutina posterior\n\n    return funcion_envolvente\n</code></pre> <p>Lo habitual es usar esta segunda forma, por su practicidad y sencillez.</p>"},{"location":"contenido/decoradores/#decoradores-con-argumentos","title":"Decoradores con argumentos","text":"<p>Los decoradores pueden aceptar argumentos de entrada, para ello hay que agregar una  funci\u00f3n adicional envolviendo a la closure:</p> Definici\u00f3n de decoradores - Decorador con argumentos<pre><code>def nombre_decorador(argumento_decorador):\n    def _nombre_decorador(funcion_entrada):\n        def funcion_envolvente(*args, **kwargs):\n            # rutina previa\n            funcion_entrada(*args, **kwargs)\n            # rutina posterior\n\n        return funcion_envolvente\n    return _nombre_decorador\n</code></pre> <p>Esta funci\u00f3n externa es la que acepta los argumentos de entrada del decorador. </p>"},{"location":"contenido/decoradores/#uso-de-decoradores","title":"Uso de decoradores","text":""},{"location":"contenido/decoradores/#asignacion","title":"Asignaci\u00f3n","text":"<p>El decorador se asigna justo antes de definir la funci\u00f3n de inter\u00e9s con su nombre precedido de un asterisco (<code>@</code>):</p> Asignaci\u00f3n de decoradores<pre><code>@nombre_decorador       # asignaci\u00f3n\ndef nombre_funcion():\n    # rutina\n    return\n</code></pre>"},{"location":"contenido/decoradores/#asignacion-con-argumentos","title":"Asignaci\u00f3n con argumentos","text":"<p>Para agregarle argumentos al decorador simplemente se le agrega el valor de entrada entre par\u00e9ntesis:</p> Asignaci\u00f3n de decoradores - Con argumentos<pre><code>@nombre_decorador(valor_entrada)       # asignaci\u00f3n\ndef nombre_funcion():\n    # rutina\n    return\n</code></pre>"},{"location":"contenido/decoradores/#concatenacion","title":"Concatenaci\u00f3n","text":"<p>Varios decoradores se pueden aplicar a la misma funci\u00f3n:</p> Asignaci\u00f3n de decoradores m\u00faltiples<pre><code>@nombre_decorador_1       # decorador externo\n@nombre_decorador_2       # decorador interno\ndef nombre_funcion():\n    # rutina\n    return\n</code></pre> <p>De esta manera el primer decorador se aplica alrededor del siguiente, \"rode\u00e1ndolo\". Esto se repite una y otra vez hasta acabar con los decoradores disponibles.</p>"},{"location":"contenido/decoradores/#atributos-internos","title":"Atributos internos","text":"<p>A la funci\u00f3n interna del decorador se le puede agregar atributos (variables asociadas) para mantener el registro.</p> <p>Por ejemplo, el siguiente decorador cuenta cu\u00e1ntas llamadas se hace sobre una misma funci\u00f3n.  Para ello crea un atributo llamado <code>conteo_llamadas</code> que queda enlazado a cada funci\u00f3n especificada:</p> <p>Decorador 'contador_llamados' - Definici\u00f3n<pre><code>def contador_llamados(funcion):\n    def contador_funcion(*args, **kwargs):\n        # incremento de atributo contador\n        contador_funcion.conteo_llamadas += 1\n        print(f\"La funci\u00f3n '{funcion.__name__}' se ha llamado {contador_funcion.conteo_llamadas} veces.\")\n        return funcion(*args, **kwargs)\n\n    # creacion e inicializacion de atributo contador\n    contador_funcion.conteo_llamadas = 0\n    return contador_funcion\n</code></pre> Dentro del decorador se lee tanto el atributo est\u00e1ndar <code>__name__</code> de la funci\u00f3n de entrada como el atributo inventado <code>conteo_llamadas</code>.</p> <p>Para probarlo el mismo decorador se usa con distintas funciones:</p> <p>Decorador 'contador_llamados' - Asignaci\u00f3n<pre><code>@contador_llamados\ndef funcion_1():\n    pass\n\n@contador_llamados\ndef funcion_2():\n    pass\n</code></pre> Como el atributo se asigna a cada funci\u00f3n que usa el decorador el conteo de llamadas a cada funci\u00f3n se mantiene independiente:</p> Decorador 'contador_llamados' - Uso<pre><code>funcion_1() # \"La funci\u00f3n 'funcion_1' se ha llamado 1 veces.\"\nfuncion_1() # \"La funci\u00f3n 'funcion_1' se ha llamado 2 veces.\"\nfuncion_1() # \"La funci\u00f3n 'funcion_1' se ha llamado 3 veces.\"\nfuncion_2() # \"La funci\u00f3n 'funcion_2' se ha llamado 1 veces.\"\nfuncion_2() # \"La funci\u00f3n 'funcion_2' se ha llamado 2 veces.\"\nfuncion_1() # \"La funci\u00f3n 'funcion_1' se ha llamado 4 veces.\"\n</code></pre>"},{"location":"contenido/decoradores/#decoradores-en-formato-de-clase","title":"Decoradores en formato de clase","text":"<p>Una forma alternativa de definir los decoradores es mediante el uso de clases:</p> Decorador - formato clase<pre><code>class nombre_decorador:\n    # Una instancia (una \"copia\" de la clase) para cada funcion asignada\n    def __init__(self, funcion_entrada):\n        # referencia a la funci\u00f3n de entrada\n        self.funcion = funcion_entrada\n\n    # Ejecucion de la funcion a traves del m\u00e9todo \n    def __call__(self, *args, **kargs):\n        # rutina previa\n        self.funcion(*args, **kargs)\n        # rutina posterior\n</code></pre> <p>El m\u00e9todo <code>__init__</code> crea una \"copia\" de la clase (una instancia) para cada funci\u00f3n que se le asigne el decorador, en tanto que el m\u00e9todo <code>__call__</code> llama internamente a dicha funci\u00f3n y ejecuta  el c\u00f3digo agregado.</p> <p>Ejemplo: decorador - formato clase</p> decorador debugger - formato clase<pre><code>class debugger:\n\n    # Una instancia (una \"copia\" de la clase) para cada funcion asignada\n    def __init__(self, funcion_entrada):\n        # Guardado de funci\u00f3n de entrada\n        self.funcion = funcion_entrada\n\n    # Ejecucion de la funcion a traves de clase\n    def __call__(self, *args, **kargs):\n        print(f\"Funcion '{self.funcion.__name__}'\")\n        print(f\"Argumentos entrada: '{args} , {kargs}'\")\n        retorno = self.funcion(*args, **kargs)\n        print(f\"Retorno: '{retorno}'\")\n</code></pre> <p>El uso y funcionamiento de estos decoradores es id\u00e9ntico al de los decoradores definidos mediante closures.</p>"},{"location":"contenido/decoradores/#ejemplos-aplicados","title":"Ejemplos aplicados","text":"<p>Un ejemplo aplicado de decorador es un medidor de tiempo de ejecuci\u00f3n como se muestra:</p> <p>TIP N\u00ba1 - medidor de tiempo de ejecuci\u00f3n</p> <p>Decorador 'intervalo' - Definicion<pre><code>from time import time, sleep\n\n# creaci\u00f3n del decorador\ndef intervalo(funcion):\n    def tiempo_ejecucion(*args, **kwargs):\n        inicio = time()\n        funcion(*args, **kwargs)  \n        fin    = time()\n        print(f\"Tiempo ejecuci\u00f3n: {(fin-inicio):.6} segundos\")\n\n    return tiempo_ejecucion\n</code></pre> Decorador 'intervalo' - Asignacion y uso<pre><code># Asignacion\n@intervalo\ndef esperar(n: int):\n    sleep(0.1*n)\n    return \n\n# Uso\nesperar(5)      # 'Tiempo ejecuci\u00f3n: 0.500126 segundos'\n</code></pre></p> <p>TIP N\u00ba2 - Decorador para argumentos y retorno de funciones</p> Decorador de argumentos y retorno - Definici\u00f3n<pre><code>def debugger(debug:bool=False):\n    def _debugger(funcion_entrada):\n        def funcion_envolvente(*args, **kargs):\n            if debug:\n                print(f\"Funcion '{funcion_entrada.__name__}'\")\n                print(f\"Argumentos entrada: '{args} , {kargs}'\")\n            retorno = funcion_entrada(*args, **kargs)\n            if debug:\n                print(f\"Retorno: '{retorno}'\")\n            return    \n        return funcion_envolvente\n    return _debugger\n</code></pre> Decorador de argumentos y retorno - Asignacion y uso<pre><code>@debugger(True)\ndef funcion_test(*args,**kargs):\n    pass\n</code></pre> <p>TIP N\u00ba3 - Decoradores de logging</p> <p>Con ayuda de decoradores se pueden implementar reportes (logs) para las funciones y m\u00e9todos de clase con facilidad, lo cual ayuda a detectar y corregir problemas. Ver capitulo de logging</p>"},{"location":"contenido/enlaces/","title":"Enlaces","text":""},{"location":"contenido/enlaces/#enlaces-oficiales","title":"Enlaces oficiales","text":"<p>Sitio Oficial (en ingles por defecto) Funciones Built-In Guia de Estilo: PEP8</p>"},{"location":"contenido/enlaces/#videos","title":"Videos","text":"<p>FreeCodeCamp - Aprende Python --&gt; Curso de Python desde Cero</p> <p>MoureDev - Curso de PYTHON desde CERO para PRINCIPIANTES (B\u00e1sico)</p> <p>MoureDev - Curso de PYTHON desde CERO para PRINCIPIANTES (Intermedio)</p> <p>SoyDalto - Curso de POO con PYTHON desde CERO (Completo)</p>"},{"location":"contenido/hilos/","title":"Paralelismo - Hilos","text":""},{"location":"contenido/hilos/#hilos-threads","title":"Hilos (threads)","text":"<p>Los threads (hilos, hebras, etc) son bifurcaciones internas de los procesos que el desarrollador realiza deliberadamente. Esta pr\u00e1ctica ayuda a que un mismo n\u00facleo del procesador modernos pueda ejecutar varios trozos de c\u00f3digo en simult\u00e1neo. </p> <p>Los hilos comparten el acceso a las variables y funciones globales del programa. Adem\u00e1s, el cambio de hilos en ejecuci\u00f3n por el proceso es bastante r\u00e1pido por no exigir el llamado al sistema operativo.</p> <p>Superescalabilidad</p> <p>Existe un mecanismo t\u00e1cito para aprovechar el paralelismo entre instrucciones de un mismo hilo llamado superescalabilidad, donde el hardware del procesador intenta detectar instrucciones independientes entre s\u00ed de la rutina actual y las ejecuta en paralelo. </p>"},{"location":"contenido/hilos/#importacion","title":"Importaci\u00f3n","text":"<p>Para poder crear nuevos hilos se requiere importar el m\u00f3dulo <code>threading</code>:</p> <pre><code>import threading\n</code></pre>"},{"location":"contenido/hilos/#uso-de-hilos","title":"Uso de hilos","text":""},{"location":"contenido/hilos/#creacion","title":"Creaci\u00f3n","text":"<p>El hilo se crea con la funci\u00f3n <code>Thread()</code>, el cual incluye como argumento la funci\u00f3n que engloba la rutina que debe ejecutarse: </p> <p>Creaci\u00f3n de threads<pre><code>def tarea():\n    return\n\n# creacion del hilo\nhilo = threading.Thread(target=tarea) \n</code></pre> Si la rutina / funci\u00f3n requiere valores de entrada estos se adjuntan como una lista o tupla dentro de la funci\u00f3n <code>Thread()</code>: </p> Creaci\u00f3n de threads - con argumentos<pre><code>def tarea(x,y):\n    return\n\n# argumentos = [x,y]      argumentos en formato lista\nargumentos = (x,y,)       #formato alternativo\n\n# creacion del hilo\nhilo = threading.Thread(target=tarea, args=argumentos) \n</code></pre>"},{"location":"contenido/hilos/#arranque","title":"Arranque","text":"<p>La ejecuci\u00f3n no comienza de inmediato sino que se ordena con el m\u00e9todo <code>start()</code>:</p> Arranque de threads<pre><code># orden de ejecucion del hilo\nhilo.start()    \n</code></pre>"},{"location":"contenido/hilos/#espera-al-cierre","title":"Espera al cierre","text":"<p>Si se necesita esperar a la finalizacion del hilo creado se recurre al m\u00e9todo <code>join()</code>. Con \u00e9l el hilo principal queda en espera hasta que que el hilo se cierre.</p> <p>Espera al cierre<pre><code># espera a la finalizacion del hilo para continuar\nhilo.join()     \n</code></pre> Puede definirse un tiempo de cierre m\u00e1ximo para la espera de la funci\u00f3n.</p> <p>Espera al cierre - con timeout<pre><code>hilo.join(timeout)     \n</code></pre> Si <code>timeout</code> es <code>None</code> entonces el tiempo de espera es indefinido.</p>"},{"location":"contenido/hilos/#intercambios-y-sincronizacion","title":"Intercambios y sincronizaci\u00f3n","text":""},{"location":"contenido/hilos/#variables-compartidas","title":"Variables compartidas","text":"<p>Los hilos de derivados de un hilo principal comparten con el mismo un mismo proceso , y por ello tienen acceso a todas sus variables globales y datos globales internos. Por ello, a diferencia de los subprocesos, no requieren en principio la creaci\u00f3n de variables ni datos compartidos.</p>"},{"location":"contenido/hilos/#bloqueos","title":"Bloqueos","text":"<p>Los hilos, al igual que los procesos, recurren al uso de bloqueos para sincronizar hilos, proteger recursos compartidos, evitar errores, etc.</p> <p>El m\u00f3dulo <code>threading</code> tiene su propia implementaci\u00f3n de los bloqueos: <code>threading.Lock()</code></p> Crear bloqueos<pre><code>bloqueo = threading.Lock()     \n</code></pre> <p>Los bloqueos pueden usarse con cierre y apertura manual , o bien con ayuda de la cl\u00e1usula <code>with</code></p> Uso bloqueos - manual<pre><code>bloqueo.adquire()     \n# Rutina protegida    \nbloqueo.release()     \n</code></pre> Uso bloqueos - cla\u00fasula with<pre><code>with bloqueo:\n    # Rutina protegida    \n</code></pre> <p>El estado actual del bloqueo se consulta con el m\u00e9todo <code>locked()</code>:</p> Uso bloqueos - estado actual<pre><code>estado = bloqueo.locked()  \n</code></pre>"},{"location":"contenido/hilos/#atributos-de-los-threads","title":"Atributos de los threads","text":""},{"location":"contenido/hilos/#estado","title":"Estado","text":"<p><code>is_alive()</code></p> <p><code>threading.active_count()</code></p> <p><code>threading.current_thread()</code></p>"},{"location":"contenido/hilos/#hilos-daemon","title":"Hilos 'daemon'","text":"<p>Los hilos daemonicos no admiten crear hilos derivados. Adem\u00e1s se cierran autom\u00e1ticamente cuando el hilo principal del proceso se cierra. Deben configurarse como tales antes de comenzar la ejecuci\u00f3n del hilo.</p> Configuracion como daemon<pre><code>hilo.daemon = True\n</code></pre>"},{"location":"contenido/hilos/#barreras-barrier","title":"Barreras (barrier)","text":"<p>Las barreras son primitivas sencillas para sincronizar un numero fijo de hilos. Los hilos se bloquean al invocarse en ellos el m\u00e9todo <code>wait()</code> hasta que todos ellos est\u00e9n bloqueados por dicho m\u00e9todo, liber\u00e1ndose entonces la ejecuci\u00f3n de todos ellos.</p> Barreras<pre><code>barrera = threading.Barrier( nro_hilos , timeout=None)\n\nTarea_1():\n\n    barrera.wait()\n\n\nTarea_2():\n\n    barrera.wait()\n</code></pre>"},{"location":"contenido/hilos/#referencias","title":"Referencias","text":"<p>Learn Tutorials - Procesos e hilos</p> <p>Documentaci\u00f3n oficial - Threading</p>"},{"location":"contenido/intercambio/","title":"Elementos de intercambio","text":""},{"location":"contenido/intercambio/#colas-queues","title":"Colas (Queues)","text":"<p>Las colas son objetos de intercambio del tipo FIFO (First In, First Out). Estas se caracterizan por ir borrando los datos internos que son leidos, los cuales siempre ser\u00e1n los primeros en haber entrado.</p> <pre><code>longitud_cola = cola.qsize()\n</code></pre>"},{"location":"contenido/intercambio/#tuberias-pipes","title":"Tuberias (Pipes)","text":""},{"location":"contenido/intercambio/#memorias-compartida","title":"memorias compartida","text":""},{"location":"contenido/modulos/","title":"M\u00f3dulos","text":"<p>Los programas a medida que crecen se dividen en m\u00f3dulos para facilitar el dise\u00f1o, el mantenimiento y la reutilizaci\u00f3n.  Un m\u00f3dulo es un archivo Python que contiene definiciones y sentencias relacionados. </p>"},{"location":"contenido/modulos/#importacion-de-modulo","title":"Importaci\u00f3n de m\u00f3dulo","text":"<p>La importaci\u00f3n es una sentencia que da acceso a las funciones y constantes definidas en el m\u00f3dulo especificado <pre><code>import modulo\n</code></pre> Las importaciones deben hacerse antes de usar sus componentes.  T\u00edpicamente se hacen al comienzo del archivo. </p>"},{"location":"contenido/modulos/#uso-de-componentes","title":"Uso de componentes","text":"<p>Las funciones del m\u00f3dulo importado se usan as\u00ed:</p> <p><pre><code>modulo.funcion(argumento)\n</code></pre> Las constantes se acceden as\u00ed:</p> <pre><code>modulo.constante\n</code></pre> <p>Ejemplo: modulo request</p> <p>El m\u00f3dulo request permite interactuar con API's de servidores remotos para hacer consultas.</p> <p><pre><code>import requests\n</code></pre> Con la funci\u00f3n <code>get()</code> se hace la petici\u00f3n al servidor.</p> <pre><code>respuesta = requests.get( \"https://pokeapi.co/api/v2/pokemon?limit=151\")\n</code></pre>"},{"location":"contenido/modulos/#alias-de-modulo","title":"Alias de m\u00f3dulo","text":"<p>Al m\u00f3dulo se lo puede importar y asignarle un nombre alternativo dentro del programa: <pre><code>import modulo as alias_modulo\n</code></pre> esto permite usar alias m\u00e1s cortos para usar sus componentes: <pre><code>alias.constante\nalias.funcion(argumento)\n</code></pre></p>"},{"location":"contenido/modulos/#importacion-de-elementos","title":"Importaci\u00f3n de elementos","text":"<p>Para importar un elemento espec\u00edfico de un m\u00f3dulo se puede usar la sentencia: <pre><code>from modulo import elemento\n</code></pre> Los elementos tambi\u00e9n se pueden importar con nuevo nombre: <pre><code>from modulo import elemento as alias_elemento\n</code></pre></p> <p>Importaci\u00f3n sin nombre</p> <p>Una mala pr\u00e1ctica muy habitual es importar un m\u00f3dulo con la sentencia: <pre><code>from modulo import *\n</code></pre> \u00c9sta permite llamar a todos los elementos del m\u00f3dulo pero sin mencionarlo. Puede dar lugar a conflictos al llamar a m\u00faltiples m\u00f3dulos.  Por ejemplo, tanto el m\u00f3dulo <code>pathlib</code> como el m\u00f3dulo <code>os</code> poseen una funci\u00f3n llamada <code>Path()</code>.</p>"},{"location":"contenido/modulos/#modulos-estandar","title":"M\u00f3dulos estandar","text":"<p>La Biblioteca Est\u00e1ndar de Python enumera y explica todos los m\u00f3dulos est\u00e1ndar del lenguaje Python.</p>"},{"location":"contenido/modulos/#modulos-locales","title":"M\u00f3dulos locales","text":""},{"location":"contenido/modulos/#crear-modulos-y-submodulos","title":"Crear m\u00f3dulos y subm\u00f3dulos","text":"<p>Los m\u00f3dulos se crean dentro de archivos con extensi\u00f3n `.py. Si estos archivos se ubican dentro de subdirectorios en tal caso se habla de subm\u00f3dulos </p> <p>Exportaci\u00f3n de elementos</p> <p>A diferencia de otros lenguajes, en Python todos los elementos internos son visibles y por eso no es necesario ordenar la exportaci\u00f3n de elementos para que \u00e9stos sean accesibles por fuera del m\u00f3dulo. </p> <p>Para reducir la visibilidad de los elementos internos se puede recurrir a los archivos init</p>"},{"location":"contenido/modulos/#sintaxis-de-importacion","title":"Sintaxis de importaci\u00f3n","text":"<p>Las barras(<code>/</code>) o barras invertidas (<code>\\</code>) de la ruta de archivo se reemplazan por puntos (<code>.</code>) y del nombre de archivo se omite la extensi\u00f3n.</p>"},{"location":"contenido/modulos/#importacion-absoluta","title":"Importaci\u00f3n absoluta","text":"<p>La importacion absoluta indica la ruta del archivo de m\u00f3dulo respecto al directorio ra\u00edz del proyecto.  Por ejemplo, si el archivo est\u00e1 adentro de un directorio interno del proyecto la importaci\u00f3n queda as\u00ed:</p> Importaci\u00f3n absoluta<pre><code>import directorio.archivo                                # importar modulo\nimport directorio.archivo as alias                       # importar modulo con alias\nfrom directorio.archivo import elemento, funcion, Clase  # importar elementos particulares\n</code></pre>"},{"location":"contenido/modulos/#importacion-relativa","title":"Importaci\u00f3n relativa","text":"<p>La importaci\u00f3n relativa se basa en definir la ruta del archivo de m\u00f3dulo respecto a la ruta del archivo actual:</p> Importaci\u00f3n relativa<pre><code>from . import modulo_A      # archivo en directorio actual\nfrom .. import modulo_B     # archivo en directorio padre\n</code></pre> <p>Rutas relativas</p> <p>El uso de importaciones relativas es motivo de debate respecto de las buenas pr\u00e1cticas y suele ser origen de m\u00faltiples problemas de dependencias.</p>"},{"location":"contenido/modulos/#ejecutar-modulo","title":"Ejecutar m\u00f3dulo","text":"<p>Si el archivo del m\u00f3dulo tiene c\u00f3digo para ejecutar (por ejemplo, un demo o un test) esto se realiza imitando la importaci\u00f3n absoluta, mediante la sintaxis:</p> Ejecuci\u00f3n de m\u00f3dulo<pre><code># ruta ra\u00edz del proyecto\npy -m directorio.archivo    # ejecucion m\u00f3dulo\n</code></pre>"},{"location":"contenido/modulos/#archivos-__init__py","title":"Archivos <code>__init__.py</code>","text":"<p>Es habitual colocar archivos llamados <code>__init__.py</code> al lado de los archivos de subm\u00f3dulo, los cuales permiten reducir la visibilidad de los mismos, acelerar la carga y prevenir errores. </p> Archivo __init__.py - ubicaci\u00f3n<pre><code>directorio\n    \u251c\u2500 submodulo1.py\n    \u251c\u2500 submodulo2.py\n    \u251c\u2500 submodulo3.py\n    \u251c\u2500 ....\n    \u251c\u2500 submoduloN.py\n    \u2514\u2500 __init__.py       \n</code></pre> <p>Para especificar qu\u00e9 subm\u00f3dulos deben ser accesibles se recurre al objeto <code>__all__</code> dentro de <code>__init__.py</code>:</p> <p>Archivo __init__.py - contenido<pre><code>## archivo '__init__.py'\n__all__ = [\n    \"submodulo1\",      # archivo 'submodulo1.py'\n    \"submodulo2\",      # archivo 'submodulo2.py'\n    ]\n</code></pre> De esta forma, si un archivo aleda\u00f1o intentara importar todo:</p> <p><pre><code>from directorio import *  # importa 'modulo1.py' y'modulo2.py'\n</code></pre> se importar\u00e1 solamente a estos dos subm\u00f3dulos especificados en <code>__init__.py</code> incluso si hay otros m\u00f3dulos en el directorio.</p> <p>init.py vac\u00edos</p> <p>Antiguamente era una pr\u00e1ctica muy popular crear archivos <code>__init__.py</code> vac\u00edos en cada subdirectorio, la cual era considerada necesaria.  Sin embargo, esto actualmente no es necesario y puede ser contraproducente. </p> <p>Por ejemplo, al intentar ejecutar programas compilados con PyInstaller \u00e9stos son incapaces de acceder a los m\u00f3dulos creados y por ello la ejecuci\u00f3n es abortada. </p>"},{"location":"contenido/modulos/#referencias","title":"Referencias","text":"<p>Documentacion oficial - M\u00f3dulos</p> <p>Hektorprofe - M\u00f3dulos</p>"},{"location":"contenido/paquetes/","title":"Paquetes","text":"<p>Los paquetes son similares a los m\u00f3dulos pero no son componentes oficiales de Python. Adem\u00e1s de la importaci\u00f3n, los m\u00f3dulos requieren instalaci\u00f3n previa para su uso. </p>"},{"location":"contenido/paquetes/#instalacion","title":"Instalaci\u00f3n","text":""},{"location":"contenido/paquetes/#pip-y-pypi","title":"PIP y Pypi","text":"<p>PIP es el instalador de Paquetes de Python. Se instala autom\u00e1ticamente con el int\u00e9rprete de Python.</p> <p>Primeros comandos de PIP:</p> PIP - Instalar y actualizar<pre><code>pip install pip             # instalar PIP (normalmente innecesario)\npip --version               # version PIP actual  \npip install --upgrade pip   # actualizar PIP\n</code></pre> <p>PyPi es el repositorio oficial para obtener y publicar los paquetes. Sitio oficial de PyPi</p>"},{"location":"contenido/paquetes/#instalacion-de-paquetes","title":"Instalaci\u00f3n de paquetes","text":"<p>Comandos \u00fatiles para manejar paquetes:</p> <p>PIP - Comandos b\u00e1sicos<pre><code>pip install paquete     # instalar paquete (m\u00e1s reciente)\npip show paquete        # mostrar data del paquete\npip uninstall paquete   # desinstalar paquete\npip list                # enumerar paquetes instalados \n</code></pre> Opciones para manejar versiones de paquetes: PIP - Comandos b\u00e1sicos<pre><code>pip install paquete==?          # consultar versiones online del paquete \npip install paquete==version    # instalar version especificada\npip install paquete&gt;=version    # instalar version especificada o m\u00e1s reciente\n</code></pre> Listado de dependencias e instalacion desde las mismas:</p> <pre><code># guardado en texto de paquetes actuales y su versi\u00f3n actual\npip freeze &gt; requirements.txt\n# instalacion desde archivo\npip install -r requirements.txt\n</code></pre>"},{"location":"contenido/paquetes/#actualizacion-de-paquetes","title":"Actualizaci\u00f3n de paquetes","text":"<p>Para actualizar los paquetes se puede usar el paquete auxiliar pip-review:</p> <pre><code>pip install pip-review\npip-review --local --interactive\n</code></pre> <p>Ubicacion de paquetes locales: <pre><code>python -m site --user-site\n</code></pre></p>"},{"location":"contenido/paquetes/#importacion","title":"Importaci\u00f3n","text":"<p>El manejo de los paquetes ya instalados es id\u00e9ntico al de los m\u00f3dulos. </p> <p>Para usar el paquete se importa haciendo:</p> <pre><code>import paquete\n</code></pre> <p>Si s\u00f3lo se necesita usar algunas funciones (o subm\u00f3dulos) del paquete se usa:</p> <pre><code>from paquete import &lt;mi_archivo_funciones&gt;\n</code></pre> <p>A los paquetes tambi\u00e9n se les puede poner alias en el programa:</p> <p><pre><code>import paquete as alias\n</code></pre> Ejemplo resumen: importando Rich (paquete de cosm\u00e9ticos para la consola).</p> <pre><code># alias para el paquete\nimport rich as r\nr.print(\"[bold yellow]Textos enriquecidos!\")\n\n# sustitucion de funciones\nfrom rich import print\nprint(\"[bold green]Funcion 'print' sustituida\")\n\n# renombrado funciones\nfrom rich import print as rprint\nrprint(\"[bold cyan]Funcion 'print' renombrada\")\n</code></pre>"},{"location":"contenido/paquetes/#crear-paquetes","title":"Crear paquetes","text":"<p>Para crear un paquete se puede crear una carpeta con el nombre del paquete e introducir: - Un archivo vac\u00edo llamado '__init__.py' dentro de cada subdirectorio incluido dentro del paquete; - Uno (o varios) archivos de Python con las funciones , constantes etc a\u00f1adidos; - Un archivo 'setup.py' para crear el archivo comprimido con el paquete, el cual tendr\u00e1 terminaci\u00f3n zip en Windows \u00f3 tar.gz en GNU/Linux.</p> <p>El proceso se explica m\u00e1s facilmente mediante ejemplos:</p> <ol> <li> <p>Supongamos la creaci\u00f3n de un paquete llamado \"mipak\" compuesto por un \u00fanico script. Para ello se colocan en un mismo directorio los siguientes tres archivos:</p> <pre><code>__init__.py     # archivo vac\u00edo\nmipak.py        # archivo con todo el contenido del paquete: funciones, clases, etc\nsetup.py        # archivo instalacion\n</code></pre> <p>El archivo de Python setup.py tendr\u00e1 todas las configuraciones pertinentes:</p> <p><pre><code># archivo 'setup.py' aleda\u00f1o al script 'mipak.py'\nfrom setuptools import setup\n\nsetup(\n    name=\"mipak\",    # nombre dek paquete, se usar\u00e1 para instalar e importar   \n    version=\"0.3\",   # numero de version, \u00fatil para gestionar las actualizaciones\n    # info para la publicaci\u00f3n online (opcional)\n    description=\"Paquete con script \u00fanico\",\n    author=\"Yo\",\n    author_email=\"yo@miserver.yo\",\n    url=\"http://miurl.com\",\n    # informacion de la composicion (importante)\n    packages=['.'],                 # Ruta del directorio del paquete\n    scripts=['mipak.py']            # Nombre script -- DEBE COINCIDIR con el nombre de paquete\n)\n</code></pre> El paquete comprimido se crea ejecutando el archivo de setup con la opcion sdist:  </p> <p><pre><code>python setup.py sdist \npy setup.py sdist           #version  abreviada\n</code></pre> Se crear\u00e1 un archivo comprimido (zip en Windows, tar.gz en Linux) con todo el contenido del paquete. \u00c9ste se encuentra en el subdirectorio /dist.</p> <p>La instalaci\u00f3n local del paquete se har\u00e1 con el comando pip install. En el ejemplo: <pre><code>pip install dist/mipak-0.3.tar.gz       # instalaci\u00f3n local\n</code></pre> Para poder usar este m\u00f3dulo en los scripts la importaci\u00f3n se hace como:</p> <pre><code>import mipak\n</code></pre> </li> <li> <p>T\u00f3mese por referencia el ejemplo online de Hektorprofe de un paquete con dos subm\u00f3dulos:</p> <p><pre><code>paquete/\n    __init__.py     # archivo vac\u00edo\n    hola/\n        __init__.py     # archivo vac\u00edo   \n        saludos.py \n    __init__.py     # archivo vac\u00edo\n    adios/\n        __init__.py     # archivo vac\u00edo   \n        despedidas.py   \n\nsetup.py        # archivo instalacion\n</code></pre> A este paquete le corresponde un 'setup.py' como el siguiente:</p> <p><pre><code>from setuptools import setup\n\nsetup(\n    name=\"paquete\",\n    version=\"0.1\",\n    description=\"Este es un paquete de ejemplo\",\n    packages=['paquete','paquete.hola','paquete.adios'], # Rutas del directorio y subdirectorios \n    scripts=[]                  # queda vac\u00edo\n)\n</code></pre> Los pasos siguientes son empaquetar e instalar, tal como antes: <pre><code>py setup.py sdist                       # crear paquete\npip install dist/paquete-0.1.tar.gz     # instalaci\u00f3n local\n</code></pre> En este caso la importaci\u00f3n deber\u00e1 dar cuenta de toda la ruta de archico. Por ejemplo: <pre><code>import paquete.hola.saludos     as saludos\nimport paquete.adios.despedidas as despedidas\n</code></pre> 3. Si del ejemplo previo se eliminaran las subcarpetas pero se dejaran ambos scripts: <pre><code>paquete/\n    __init__.py     # archivo vac\u00edo \n    saludos.py \n    despedidas.py   \n\nsetup.py        # archivo instalacion\n</code></pre> al paquete le corresponder\u00eda un 'setup.py' como el siguiente:</p> <p><pre><code>from setuptools import setup\n\nsetup(\n    name=\"paquete\",\n    version=\"0.2\",\n    description=\"Este es un paquete de ejemplo\",\n    packages=['paquete'],       # Ruta del directorio \n    scripts=[]                  # queda vac\u00edo\n)\n</code></pre> El empaquetado  e instalacion son analogos al caso previo: <pre><code>py setup.py sdist                       # crear paquete\npip install dist/paquete-0.2.tar.gz     # instalaci\u00f3n local\n</code></pre> Y la importaci\u00f3n queda como: <pre><code>import paquete.saludos    as saludos\nimport paquete.despedidas as despedidas\n</code></pre></p> </li> </ol> <p>Links \u00fatiles:</p> <p>https://docs.hektorprofe.net/python/modulos-y-paquetes/paquetes/</p>"},{"location":"contenido/procesos/","title":"Paralelismo - Procesos","text":""},{"location":"contenido/procesos/#procesos-proccess","title":"Procesos (proccess)","text":"<p>Los procesos (process) son \"programas\" unitarios cuya ejecuci\u00f3n es gestionada por el sistema operativo, el cual asigna cada proceso en activo a un n\u00facleo del procesador que est\u00e9 disponible para que se encargue de ejecutarlo. Los dem\u00e1s procesos quedan en espera hasta que el sistema operativo los ponga en activo de nuevo, los cierre o simplemente se terminen.</p> <p>Un programa completo puede estar compuesto por m\u00faltiples procesos vinculados entre s\u00ed. Esto permite:</p> <ul> <li>modularizar el programa al dividirlo en rutinas espec\u00edficas;</li> <li>mejorar los tiempos de ejecuci\u00f3n al repartir varios subprocesos del programa entre los n\u00facleos del procesador, permitiendo la ejecuci\u00f3n simult\u00e1nea.</li> </ul>"},{"location":"contenido/procesos/#importacion","title":"Importaci\u00f3n","text":"<p>Crear procesos requiere de importar el modulo <code>multiprocessing</code>:</p> <pre><code>import multiprocessing\n</code></pre>"},{"location":"contenido/procesos/#uso-de-procesos","title":"Uso de procesos","text":""},{"location":"contenido/procesos/#creacion","title":"Creaci\u00f3n","text":"<p>El nuevo proceso se crea con la funci\u00f3n <code>Process()</code>, al cual se le debe asignar el nombre de una funci\u00f3n o \"tarea\" a ejecutar en un nuevo proceso:</p> Creaci\u00f3n procesos<pre><code># rutina para el nuevo proceso\ndef tarea():\n    return\n\n# creacion del proceso\nproceso = multiprocessing.Process(target=tarea)\n</code></pre> <p>Si la rutina requiere argumentos de entrada estos se adjuntan como una lista o tupla dentro de la funci\u00f3n <code>Process()</code></p> Creaci\u00f3n procesos - con argumentos<pre><code>def tarea(x, y):\n    return\n\n# argumentos = [x,y]      # argumentos en formato lista\nargumentos = (x,y,)       # formato alternativo\n# creacion del proceso\nproceso = multiprocessing.Process(target=tarea, args=argumentos) \n</code></pre> <p>Proceso hijo</p> <p>El nuevo proceso creado es considerado como proceso hijo del proceso que lo cre\u00f3. Tambi\u00e9n se lo suele llamar subproceso.</p>"},{"location":"contenido/procesos/#arranque","title":"Arranque","text":"<p>El nuevo proceso queda en stand-by hasta que se ordene el arranque con el m\u00e9todo <code>start()</code>:</p> <pre><code># orden de ejecucion del proceso\nproceso.start()\n</code></pre>"},{"location":"contenido/procesos/#espera-al-cierre","title":"Espera al cierre","text":"<p>Si se requiere esperar el cierre del proceso creado para ejecutar m\u00e1s c\u00f3digo se recurre al m\u00e9todo <code>join()</code>. Con \u00e9l el proceso que llama al m\u00e9todo permanecer\u00e1 en espera hasta que el proceso se termine:</p> <p>Espera al cierre<pre><code># espera a que el proceso se cierre\nproceso.join()\n</code></pre> Al m\u00e9todo <code>join()</code> se le puede asignar un tiempo m\u00e1ximo de bloqueo como argumento: Espera al cierre - con timeout<pre><code># espera a que el proceso se cierre \ntiempo = 5\nproceso.join(tiempo)  # bloqueo por 5 segundos como m\u00e1ximo\n</code></pre></p>"},{"location":"contenido/procesos/#atributos","title":"Atributos","text":""},{"location":"contenido/procesos/#estado-actual","title":"Estado actual","text":"<p>El estado actual del proceso se consulta con el atributo <code>exitcode</code> o con el m\u00e9todo <code>is_alive()</code>: Estado de ejecuci\u00f3n<pre><code>proceso.exitcode   # codigo de salida del proceso; 'None' si sigue vivo\nproceso.is_alive() # booleano: 'True' si sigue vivo\n</code></pre></p>"},{"location":"contenido/procesos/#identificacion","title":"Identificaci\u00f3n","text":"<p>El nombre y el n\u00famero ID (identificador) del proceso hijo se consultan con los atributos <code>name</code> y <code>pid</code>:</p> Identificaci\u00f3n de subproceso<pre><code>proceso.name    # nombre del proceso\nproceso.pid     # numero identificador (ID) del proceso\n</code></pre> <p>En cambio, para conocer el identificador del proceso padre y el del proceso padre se recurre al m\u00f3dulo <code>os</code>(sistema operativo):</p> Identificaci\u00f3n de subproceso<pre><code>os.getpid()     # ID proceso actual\nos.getppid()    # ID proceso padre\n</code></pre> <p>Ejemplo</p> <pre><code>import multiprocessing\nimport os\nimport time\n\n# tareas de 1 segundo cada una\ndef tarea():\n    time.sleep(1)\n    # print(proceso.is_alive())\n    print(\"PID:  %s\" % (os.getpid(),))\n    print(\"El ID del proceso padre es: %s\" % (os.getppid()))\n\n\ninicio = time.time()\n# Creacion de lista de procesos en bucle\nprocesos = [multiprocessing.Process(target=tarea) for _ in range(4)]\n# llama a los procesos para ejecutar\nfor proceso in procesos:\n    proceso.start()\n# espera hasta que cada proceso termine\nfor proceso in procesos:\n    proceso.join()  \n\nfin = time.time()\n\nprint(\"Tiempo ejecuci\u00f3n: %.2f seg\" % (fin - inicio))    # 'Tiempo ejecuci\u00f3n: 1.04 seg'\n</code></pre>"},{"location":"contenido/procesos/#configuracion-como-daemon","title":"Configuraci\u00f3n como 'daemon'","text":"<p>El atributo <code>daemon</code> configura al proceso como 'daemonic'. Esto habilita el cierre automatico cuando el proceso padre sea cerrado e impide que el proceso 'daemonio' llame a sus propios subprocesos. Esta configuracion debe hacerse antes de llamar al metodo <code>start()</code>. </p> Configuracion como daemon<pre><code>proceso.daemon = True\n</code></pre>"},{"location":"contenido/procesos/#intercambios-y-sincronizacion","title":"Intercambios y sincronizaci\u00f3n","text":""},{"location":"contenido/procesos/#variables-compartidas","title":"Variables compartidas","text":"<p>Los procesos no comparten variables de manera predeterminada. Para crear variables y datos comunes a m\u00faltiples subprocesos se usan las funciones <code>Value()</code> y <code>Array()</code>:</p> Variables compartidas<pre><code>numero_compartido  = multiprocessing.Value('d', 0)  # variables\narreglo_compartido = multiprocessing.Array('i', range(10))  # datos\n</code></pre>"},{"location":"contenido/procesos/#bloqueos-lock","title":"Bloqueos (lock)","text":"<p>A menudo se requiere sincronizar varios procesos paralelos para poder presentar resultados, acceder a ciertos recursos compartidos, etc. Uno de los m\u00e9todos m\u00e1s habituales es el bloqueo o candado (lock), creado con la funci\u00f3n <code>Lock()</code>*</p> Creacion candados<pre><code>bloqueo = multiprocessing.Lock()\n</code></pre> <p>Una forma de usar el candado es mediante el uso manual del bloqueo con los m\u00e9todos <code>acquire()</code> y <code>release()</code>:</p> Uso candados<pre><code># bloqueo manual\nbloqueo.acquire()\n\n# recurso compartido\nnumero_compartido.value += 1\n\n# liberacion manual\nbloqueo.release()\n</code></pre> <p>Otra forma de usar el candado es con la ayuda de la cl\u00e1sula <code>with</code>:</p> Uso candados - con with<pre><code>with bloqueo:\n    # recurso compartido\n    numero_compartido.value += 1\n</code></pre> <p>Ejemplo: variables compartidas y bloqueo de recursos</p> <pre><code>import multiprocessing, time\n\nnumero_local = 0\nnumero_compartido = multiprocessing.Value('d', 0)\n\nbloqueo = multiprocessing.Lock()\n\ndef incremento():\n    global numero_local\n    with bloqueo:\n        # se simula un recurso ocupado o una rutina exigente\n        time.sleep(0.5)\n        # Los subprocesos modifican COPIAS de la variable local\n        numero_local += 1\n        # El numero conpartido S\u00cd es modificado por los subprocesos\n        numero_compartido.value += 1\n\n\ninicio = time.time()\nsubprocesos = [multiprocessing.Process(target=incremento) for n in range(4)]\nfor proceso in subprocesos:\n    proceso.start()\nfor proceso in subprocesos:\n    proceso.join()\nfin = time.time()\n\n\nprint(\"Tiempo ejecuci\u00f3n: %.2f seg\" % (fin - inicio)) \nprint(\"El numero local es %d; el numero compartido es %d\" % (numero_local, numero_compartido.value))\n</code></pre> <p>Resultado: <pre><code>Tiempo ejecuci\u00f3n: 2.01 seg\nEl numero local es 0; el numero compartido es 4\n</code></pre></p>"},{"location":"contenido/procesos/#reservas-pools","title":"Reservas (pools)","text":"<p>Las pools de procesos funcionan como una reserva de tareas a ejecutarse en procesos paralelos. </p> <p>La reserva se crea con la funci\u00f3n <code>Pool()</code>, al cual debe indic\u00e1rsele el m\u00e1ximo n\u00famero de procesos ejecutables en paralelo:</p> <p>Crear pool<pre><code>pool = multiprocessing.Pool(processes=nro_procesos_simultaneos)    \n</code></pre> El n\u00famero de procesos es t\u00edpicamente el n\u00famero de n\u00facleos disponibles del procesador a usar.</p> <p>Con el m\u00e9todo <code>map()</code> se ordena la ejecuci\u00f3n simult\u00e1nea de un grupo de tareas:</p> <p>Arrancar pool<pre><code>pool.map(funcion_tarea, argumentos) \n</code></pre> A medida que se termina una tarea se cierra su proceso y se arranca uno nuevo para ejecutar la pr\u00f3xima tarea pendiente. </p> <p>El cierre de la reserva se hace con el m\u00e9todo <code>terminate()</code>:</p> Cerrar pool<pre><code>pool.terminate()\n</code></pre> <p>Ejemplo: Pool de 4 procesos, 16 tareas</p> <pre><code>import random\nimport time\nfrom multiprocessing import Pool\n\n# tarea gen\u00e9rica con argumentos de entrada\ndef tarea(nombre: str) -&gt; None:\n    print(f'Started worker \"{nombre}\"')\n    tiempo_rutina = random.choice(range(1, 5))\n    time.sleep(tiempo_rutina )\n    print(f'Tarea \"{nombre}\" finalizada en {tiempo_rutina} segundos')\n\n\n# nombres para cada tarea \nnombres_proceso = [f'Tarea_{i}' for i in range(16)]\n\npool = Pool(processes=4)            # cuatro procesos simult\u00e1neos\npool.map(tarea, nombres_proceso)    # ejecuci\u00f3n de a grupos de 4\n\n# cierre de reserva\npool.terminate()\n</code></pre>"},{"location":"contenido/procesos/#bifurcaciones-forks","title":"Bifurcaciones (forks)","text":"<p>Un mecanismo antiguo para crear procesos es la bifurcaci\u00f3n. Consiste en hacer una r\u00e9plica exacta del proceso actual con ayuda de la funci\u00f3n <code>fork()</code>, cuyo retorno permite discernir entre el proceso original y su clon. Recurre al m\u00f3dulo <code>os</code>.</p> Bifurcaci\u00f3n (fork)<pre><code>retorno = os.fork()\n</code></pre> <p>El valor de retorno obtenido no es igual para el proceso original que para su clon, permitiendo diferenciarlos desde la rutina:</p> retorno significado <code>valor &gt; 0</code> Es original \\(\\rightarrow\\) ID proceso clon <code>valor == 0</code> Es clon del proceso original <code>valor &lt; 0</code> Error de bifurcaci\u00f3n \\(\\rightarrow\\)  clon fallido <p>Ejemplo: IDs de original y de clon</p> Forks<pre><code>import os\n\n# Rutina com\u00fan\nprint(\"\u00a1Vamos a hacer un fork de un proceso!\")\n\n# bifurcacion\nretorno = os.fork()\n\n# proceso padre: retorno = ID proceso hijo\nif retorno&gt;=0:\n    pid = os.getpid()\n    print(\"Rutina del proceso original\")\n    print(f\"pid: {pid}, retorno: {retorno}\")\n\n# proceso hijo : retorno = 0\nelif retorno==0:\n    pid = os.getpid()\n    print(\"Rutina del proceso hijo\")\n    print(f\"pid = {pid}, retorno: {retorno}\")\n\n# error : retorno &lt; 0\nelse:\n    print(\"Error de bifurcaci\u00f3n\")\n</code></pre>"},{"location":"contenido/procesos/#asincronos","title":"Asincronos","text":"<p>https://docs.python.org/es/3/library/asyncio-subprocess.html</p>"},{"location":"contenido/procesos/#referencias","title":"Referencias","text":"<p>Learn Tutorials - Procesos e hilos</p> <p>El Blog Python - Crea m\u00faltiples procesos en python</p> <p>Documentaci\u00f3n oficial - Multiprocessing</p>"},{"location":"miscelanea/buscar_archivos/","title":"Buscar Archivos y Carpetas","text":""},{"location":"miscelanea/buscar_archivos/#scandir","title":"scandir()","text":"<pre><code>from os import scandir, getcwd\n\nruta = getcwd()\nprint(ruta)\n\nrutas = scandir(ruta)\n\nfor r in rutas:\n    # print(r)\n    print(r.name, r.is_dir(), r.is_file())\n</code></pre> <p>La b\u00fasqueda es no recursiva</p>"},{"location":"miscelanea/buscar_archivos/#pathiterdir","title":"Path.iterdir()","text":"<p>El m\u00e9todo iterdir() de la funci\u00f3n Path() permite buscar archivos</p> <p><pre><code>from pathlib import Path\nruta = Path.cwd()\n\nrutas = Path(ruta).iterdir()\nprint(rutas)\nfor r in rutas:\n    # print(r)\n    print(r.name, r.is_dir(), r.is_file())\n</code></pre> La b\u00fasqueda es no recursiva</p>"},{"location":"miscelanea/buscar_archivos/#listdir","title":"listdir()","text":"<p>La funcion listdir() del m\u00f3dulo os </p> <pre><code>from os import listdir\n\nruta = \"./\"\nrutas =  listdir(ruta)\n</code></pre> <pre><code>from os.path import isfile, join\nfor r in rutas:\n    print(r, isfile(join(ruta, r)))\n</code></pre>"},{"location":"miscelanea/buscar_archivos/#walk-y-next","title":"walk() y next()","text":"<p><pre><code>from os import walk, getcwd\n\nruta = getcwd()     #ruta de b\u00fasqueda\n\ndir, lista_subdirs, lista_archivos = next(walk(ruta))   \n</code></pre> La funci\u00f3n walk() devuelve un objeto generador. La funci\u00f3n next() descompone el objeto en el directorio actual, la lista de subdirectorios y la lista de archivos.</p> <p>Esta b\u00fasqueda es no recursiva.</p>"},{"location":"miscelanea/buscar_archivos/#glob","title":"glob","text":"<p>La funci\u00f3n glob del m\u00f3dulo glob permite buscar rutas de archivo f\u00e1cilmente indicando la extensi\u00f3n deseada:</p> <p><pre><code>from glob import glob\n\nexpr = '**' #todo (incluye carpetas)\nexpr = '*.*' # archivos con cualquier extensi\u00f3n\nexpr = '*.txt' # archivos con extensi\u00f3n especifica\n\nlista_rutas = glob(expr)\n</code></pre> El retorno es una lista de strings.</p> <p>La b\u00fasqueda es no recursiva; sin embargo la recursividad se puede habilitar con el par\u00e1metro recursive:</p> <p><pre><code>lista_rutas = glob(expr, recursive = True)\n</code></pre> Tambi\u00e9n se puede habilitar la b\u00fasqueda de archivos ocultos con el par\u00e1metro:  <pre><code>lista_rutas = glob(expr, include_hidden = True)\n</code></pre></p>"},{"location":"miscelanea/buscar_archivos/#referencias","title":"Referencias","text":"<p>https://es.stackoverflow.com/questions/24278/c\u00f3mo-listar-todos-los-archivos-de-una-carpeta-usando-python</p> <p>https://www.delftstack.com/es/howto/python/python-directory-exists/#comprobar-si-el-directorio-existe-usando-el-m\u00e9todo-pathisdir-del-m\u00f3dulo-os-en-python</p>"},{"location":"miscelanea/cosas_extranias/","title":"5 COSAS EXTRA\u00d1AS en PYTHON","text":"<p>https://www.youtube.com/watch?v=0IjLBjatT5Y</p> <p>Conexion a bases de datos con SQL Server https://youtu.be/BzsF1cG6JJU?list=PLWYKfSbdsjJg9-Knrk6iKbM-u6Z33zavD REVISAR</p> <p>Se trabaja en base al paquete pyodbc. Tambi\u00e9n debe instalarse un driver del lenguaje de la base de datos elegida.</p> <p>Ejemplo: una rutina de lectura de base de datos ubicada localmente.</p> <pre><code>import pyodbc\n&lt;descriptor&gt; = pyodbc.connect( \n    'Driver={&lt;nombre_driver_base_datos&gt;}'; \n    'Server=localhost;'\n    'Database=&lt;nombre_base_datos&gt;;'\n    'UID=&lt;nombre_administrador&gt;;'\n    'PWD=&lt;contrase\u00f1a&gt;;')\ncursor = conn.cursor()\ncursor.execute(\u2018select * from persona\u2019)\n</code></pre>"},{"location":"modulos/asyncio/","title":"Ejecuci\u00f3n Asincr\u00f3nica - M\u00f3dulo Asyncio","text":"<p>Asyncio (asynchronous I/O) es el m\u00f3dulo encargado de implementar los mecanismos de ejecuci\u00f3n asincr\u00f3nica. La ejecuci\u00f3n asincr\u00f3nica consiste en repartir aquellas rutinas del programa que dependan de recursos no siempre disponibles (respuestas de servidores externos, entradas de usuario, etc) de modo que \u00e9stas puedan ejecutarse de manera independientes unas de otras a medida que los recursos est\u00e9n disponibles. De esta manera se aprovecha mejor el tiempo cuando los recursos requeridos est\u00e1n ocupados minimizando los tiempos muertos. </p> <p>Asyncio tambi\u00e9n incluye gesti\u00f3n de streams , manejo de colas ,etc.</p>"},{"location":"modulos/asyncio/#importacion","title":"Importacion","text":"<p>El m\u00f3dulo debe importarse cada vez que se requiera su uso:</p> <pre><code>import asyncio\n</code></pre>"},{"location":"modulos/asyncio/#corrutinas","title":"Corrutinas","text":"<p>La ejecuci\u00f3n as\u00edncrona se basa en corrutinas. Las corrutinas son funciones no bloqueantes, es decir que si no pueden continuar su ejecuci\u00f3n \u00e9stas quedan en suspenso y mientras tanto se pueden ejecutar otras corrutinas que s\u00ed dispongan de las condiciones para ejecutarse.</p>"},{"location":"modulos/asyncio/#definicion-y-ejecucion-simple","title":"Definici\u00f3n y ejecuci\u00f3n simple","text":"<p>Las corrutinas se definen como funciones comunes, excepto que son precedidas con la sentencia <code>async</code>:</p> <p>Corrutinas<pre><code>import asyncio\nfrom datetime import datetime\n\n# definicion de corrutina\nasync def corrutina(nombre :str , duracion: int):\n    print(f\"Nombre: {nombre}, inicio: {datetime.now()}, duracion: {duracion}s\")\n    await asyncio.sleep(duracion)   # NO bloquea la ejecucion de otras corrutinas\n    print(f\"Nombre: {nombre}, fin: {datetime.now()}\")\n\n\n# ejecucion de corrutina\nasyncio.run(corrutina(\"A\",1))\n</code></pre> La funci\u00f3n <code>run()</code> ordena la ejecuci\u00f3n de la corrutina desde la rutina principal del programa.</p>"},{"location":"modulos/asyncio/#ejecucion-secuencial","title":"Ejecuci\u00f3n secuencial","text":"<p>Si se intenta ejecutar varias corrutinas con la funci\u00f3n  <code>run()</code> entonces \u00e9stas se ejecutar\u00e1n en sucesi\u00f3n, es decir cada una esperar\u00e1 a la finaliazaci\u00f3n de la anterior para comenzar:</p> Corrutinas - Ejecuci\u00f3n sucesiva<pre><code>asyncio.run(corrutina(\"A\",1))\nasyncio.run(corrutina(\"B\",1))\nasyncio.run(corrutina(\"C\",1))\nasyncio.run(corrutina(\"D\",1))\n</code></pre> <p><code>run()</code> se recomienda para ejecutar los puntos de acceso de m\u00e1ximo nivel. Las corrutinas pueden ser ejecutadas dentro de otras corrutinas con ayuda de la sentencia <code>await</code>:</p> Corrutinas - Ejecuci\u00f3n sucesiva<pre><code>async def principal():\n    await corrutina(\"A\", 1)\n    await corrutina(\"B\", 1)\n    await corrutina(\"C\", 1)\n    await corrutina(\"D\", 1)\n\n\nasyncio.run(principal())\n</code></pre> <p>await</p> <p>La sentencia <code>await</code> (esperar) espera a que la corrutina indicada finalice y devuelva su retorno para poder continuar.</p> <p>La sentencia <code>await</code> s\u00f3lo puede usarse dentro de las corrutinas, en caso contrario se produce un <code>SyntaxError</code>.</p>"},{"location":"modulos/asyncio/#ejecucion-concurrente","title":"Ejecucion concurrente","text":"<p>La ejecuci\u00f3n concurrente hace que las corrutinas comiencen todas al mismo tiempo y se espere a que todas est\u00e9n completas para finalizar la ejecuci\u00f3n.</p> <p>Para poder ejecutar las corrutinas de forma concurrente se usa la funci\u00f3n <code>gather()</code>:</p> Corrutinas - Ejecuci\u00f3n concurrente<pre><code>async def corrutinas_concurrentes():\n    await asyncio.gather(\n        corrutina(\"A\", 1),\n        corrutina(\"B\", 2),\n        corrutina(\"C\", 3),\n        )\n\n\n# orden de ejecucion asincrona\nasyncio.run(corrutinas_concurrentes())\n</code></pre> <p>Con <code>await</code> se espera a que todas las corrutinas terminen de ejecutarse para poder continuar. </p> <p>Funci\u00f3n sleep()</p> <p>El \u1e3fodulo asyncio implementa su propia versi\u00f3n de la funci\u00f3n <code>sleep()</code>. Esta versi\u00f3n, a diferencia de la implementaci\u00f3n en el m\u00f3dulo time, no bloquea la ejecuci\u00f3n del programa sino que deja la corrutina en suspenso hasta el final del retardo. </p> <p>Funci\u00f3n sleep()<pre><code>await asyncio.sleep(tiempo)   \n</code></pre> Esta funci\u00f3n se usa siempre dentro de corrutinas y se invoca con la cl\u00e1usula <code>await</code> que permite el retorno a la corrutina tras la espera.</p>"},{"location":"modulos/asyncio/#tareas","title":"Tareas","text":"<p>Con la funci\u00f3n <code>create_task()</code> se pueden crear m\u00faltiples tareas, cada una de las cuales ejecutar\u00e1 una corrutina interna.</p> Tareas<pre><code>async def principal():\n\n    tarea1 = asyncio.create_task( corrutina(\"A\", 3) )\n    tarea2 = asyncio.create_task( corrutina(\"B\", 1) )\n\n    await tarea1\n    await tarea2\n\n\nasyncio.run(principal())\n</code></pre> <p>Las tareas son usadas para programar corrutinas concurrentemente. \u00c9stas se programan autom\u00e1ticamente para ser ejecutadas en breve.</p> <p>Las tareas deben ser esperadas con <code>await</code>. Si la corrutina interna levanta un error entonces \u00e9ste se propagar\u00e1 a la tarea. </p> <p>Las tareas se pueden cancelar con el metodo <code>cancel()</code>. Al interrumpirse la tarea se elevar\u00e1 un error del tipo <code>CancelledError</code>. Si una tarea ya est\u00e1 ejecut\u00e1ndose cuando se intenta cancelarla entonces \u00e9sta se interrumpir\u00e1 al llegar al pr\u00f3ximo <code>await</code>.</p>"},{"location":"modulos/asyncio/#taskgroup","title":"TaskGroup()","text":"<p>Con la clase <code>TaskGroup()</code> se pueden agrupar m\u00faltiples tareas en un unico grupo para ejecutarlas de forma concurrente:</p> Tareas con TaskGroup()<pre><code>async def principal():\n    async with asyncio.TaskGroup() as grupo:\n        # tareas internas - ejecucion concurrente\n        tarea1 = asyncio.create_task( corrutina(\"A\", 3) )\n        tarea2 = asyncio.create_task( corrutina(\"B\", 1) )\n\n        await tarea1\n        await tarea2\n\n\nasyncio.run(principal())\n</code></pre> <p>La cl\u00e1usula <code>with</code> asegura el cierre del grupo y la liberaci\u00f3n de recursos al terminar, lo cual es considerado una buena pr\u00e1ctica.</p>"},{"location":"modulos/asyncio/#timeouts-tiempo-limite","title":"Timeouts - tiempo limite","text":"<p><code>timeout()</code> pone un tope al tiempo de espera para completar las corrutinas internas, cuya ejecuci\u00f3n es concurrente.</p> <p>El tiempo de espera se indica en segundos.</p> Tareas con timeout()<pre><code>async def principal():\n    async with asyncio.timeout(5):  # tiempo espera m\u00e1ximo: 5 segundos\n        # tareas internas - ejecuci\u00f3n concurrente\n        tarea1 = asyncio.create_task( corrutina(\"A\",  3) )\n        tarea2 = asyncio.create_task( corrutina(\"B\",  1) )\n        tarea3 = asyncio.create_task( corrutina(\"C\", 10) ) # tiempo espera excesivo\n\n        await tarea1\n        await tarea2\n        await tarea3\n\n\nasyncio.run(principal())\n</code></pre> <p>Si las tareas internas no se ejecutan dentro del tiempo l\u00edmite \u00e9stas se cancelan y se eleva el error <code>TimeoutError</code>.  </p> <p>Si el tiempo especificado es <code>None</code> el tiempo de espera es indefinido. El tiempo puede redefinirse con <code>Timeout.reschedule()</code></p>"},{"location":"modulos/asyncio/#loop-de-eventos","title":"Loop de Eventos","text":"<p>Los bucles de eventos son APIs de bajo nivel del m\u00f3dulo, las cuales son la base de </p> <p>Este es un ejemplo de uso donde se usan varios m\u00e9todos habituales del loop de eventos:</p> Uso del loop de eventos<pre><code>from datetime import datetime\nimport asyncio\n\nasync def corrutina(nombre :str , duracion: int):\n    # consulta del loop actual\n    bucle = asyncio.get_event_loop()\n    print(bucle)\n\n    print(f\"Nombre: {nombre}, inicio: {datetime.now()}, duracion: {duracion}s\")\n    await asyncio.sleep(duracion)   \n    print(f\"Nombre: {nombre}, fin: {datetime.now()}\")\n\n# nuevo bucle as\u00edncrono\nloop = asyncio.new_event_loop()\n\n# ejecucion secuencial, hasta terminar\nloop.run_until_complete(corrutina(\"A\", 1))\nloop.run_until_complete(corrutina(\"B\", 3))\n\n# Cierre de bucle manual\nloop.close()\n</code></pre> <p>M\u00e1s del buvle de eventos de Python: documentacion oficial</p>"},{"location":"modulos/asyncio/#multithreading","title":"Multithreading","text":"<p>Supongase el ejemplo de la siguiente funci\u00f3n:</p> <pre><code>from datetime import datetime\nimport time\n\ndef rutina(nombre :str , duracion: int=4):\n\n    print(f\"Nombre: {nombre}, inicio: {datetime.now()}, duracion: {duracion}s\")\n    time.sleep(duracion)      # bloquea la ejecucion concurrente\n    print(f\"Nombre: {nombre}, fin: {datetime.now()}\")\n    return duracion\n</code></pre> <p>\u00c9sta puede ser llamada desde una corrutina de varias maneras. Una de ellas es mediante la funci\u00f3n <code>to_thread()</code>:</p> Multithreading - to_thread()<pre><code># definicion de corrutina\nasync def principal():\n    resultado = await asyncio.to_thread(rutina, nombre=\"Y\", duracion=2) \n    print(resultado)    # '2'\n\n\n# ejecucion de corrutina\nasyncio.run(principal())\n</code></pre> <p>Otra forma es el m\u00e9todo <code>run_in_executor()</code> del la clase <code>get_event_loop()</code>:</p> Multithreading - run_in_executor()<pre><code># definicion de corrutina\nasync def principal():\n    bucle = asyncio.get_event_loop()    # bucle actual\n    resultado = await bucle.run_in_executor(None, rutina, \"X\", 3)   \n    print(resultado)    # '3'\n\n\n# ejecucion de corrutina\nasyncio.run(principal())\n</code></pre> <p>Asimismo ambas formas pueden usarse juntas dentro de <code>gather()</code>:</p> Multithreading - gather<pre><code># definicion de corrutina\nasync def principal():\n    resultado = await asyncio.gather(\n        bucle.run_in_executor(None, rutina, \"X\", 3),     \n        asyncio.to_thread(rutina, nombre=\"Y\", duracion=2) \n        )\n    print(resultado)        # '[3,2]'\n\n\n# ejecucion de corrutina\nasyncio.run(principal())\n</code></pre> <p>El m\u00e9todo <code>run_in_executor()</code>delega la ejecuci\u00f3n a otro thread, lo cual permite activar el procesamiento paralelo por parte del procesador. La funci\u00f3n de entrada no debe ser corrutina sino que debe ser una funci\u00f3n normal.</p>"},{"location":"modulos/asyncio/#manejo-de-errores","title":"Manejo de errores","text":"<p>Se usan habitualmente las cl\u00e1usulas <code>try</code> y <code>except</code> dentro de las corrutinas.</p> <p>En caso de manejarse un bucle de eventos, el m\u00e9todo <code>set_exception_handler()</code> del loop de eventos permite tambi\u00e9n el manejo de todas las corrutinas dentro del loop.</p> <p>Propagaci\u00f3n de errores</p> <p>Los errores producidos en las corrutinas se propagan a las rutinas y corrutinas superiores. Por ello es fundamental implementar el manejo de errores para evitar errores y fallos cr\u00edticos en el programa.</p>"},{"location":"modulos/asyncio/#limitaciones-de-asyncio","title":"Limitaciones de asyncio","text":"<ul> <li>No es apta para tareas con uso intensivo de CPU.</li> <li>Las excepciones no manejadas dentro de las corrutinas no obligan a la salida inmediata del sistema, por ello suelen ser dif\u00edciles de debuggear.</li> <li>Las corrutinas usan un \u00fanico hilo y no admiten por s\u00ed mismas el uso de multiples hilos.</li> </ul>"},{"location":"modulos/asyncio/#buenas-practicas","title":"Buenas Pr\u00e1cticas","text":"<ul> <li>Usar <code>asyncio.run()</code> es la forma recomendada de ejecutar funciones de alto nivel debido a su simplicidad.</li> <li>Manejar las excepciones previene que los errores se propaguen a la rutina principal</li> <li><code>async with</code> para manejo de recursos.</li> <li>Limitar tareas concurrentes: funciones <code>asyncio.Semaphore</code> y <code>asyncio.BoundedSemaphore</code>.</li> <li>Usar  <code>asyncio.gather()</code> para ejecutar m\u00faltiples corrutinas simult\u00e1neas.</li> </ul>"},{"location":"modulos/asyncio/#referencias","title":"Referencias","text":"<p>Documentacion oficial de Python</p> <p>Gyata AI - Mastering Asyncio in Python</p> <p>MoureDev TV - Asincron\u00eda</p>"},{"location":"modulos/logging/","title":"Modulo Logging - Informacion de Errores","text":"<p>Los logs o reportes funcionan como una alternativa superadora al uso de la funci\u00f3n <code>print()</code> para dar informaci\u00f3n acerca del funcionamiento del sistema, permitiendo registrar valores de par\u00e1metros, registrar fallos de programa, fecha y hora de eventos, etc. creando mensajes con jerarqu\u00edas asignables. Tambi\u00e9n habilita la creaci\u00f3n de archivos de logs, env\u00edo de reportes al sistema operativo, etc.</p>"},{"location":"modulos/logging/#importacion","title":"Importaci\u00f3n","text":"Importaci\u00f3n del m\u00f3dulo<pre><code>import logging\n</code></pre>"},{"location":"modulos/logging/#configuracion-de-logs","title":"Configuraci\u00f3n de logs","text":"<p>Los reportes deben configurarse antes de su uso. Para ello se recurre la funci\u00f3n <code>basicConfig()</code>. </p> Configuraci\u00f3n de reportes - A consola<pre><code>logging.basicConfig(\n    level=logging.INFO, # m\u00ednimo nivel de log a publicar\n    format=\"%(asctime)s - %(levelname)s - %(message)s\", #info incorporada\n    )\n</code></pre> <p><code>level</code> es el argumento que indica el m\u00ednimo nivel de reporte a presentar de ah\u00ed en adelante, en tanto que <code>format</code> define qu\u00e9 informaci\u00f3n incluir en el reporte: </p> <ul> <li><code>%(asctime)s</code>     : fecha y hora local del reporte</li> <li><code>%(levelname)s</code>   : nivel de error reportado</li> <li><code>%(message)s</code>     : reporte explicativo del desarrollador (ver m\u00e1s adelante)</li> </ul> <p>Se presupone la salida de los reportes por terminal. Esto puede reemplazarse indicando par\u00e1metros de archivo de salida:</p> Configuraci\u00f3n de reportes - A archivo<pre><code>logging.basicConfig(\n    level=logging.INFO, # m\u00ednimo nivel de log a publicar\n    format=\"{asctime} - {levelname} - {message}\",\n    filename=\"app.log\", # nombre archivo\n    encoding=\"utf-8\",   # codificacion\n    filemode=\"a\",       # modo agregado\n    style=\"{\",\n    datefmt=\"%Y-%m-%d %H:%M\",\n    )\n</code></pre> <p>Orden de configuraci\u00f3n</p> <p>Si hay varios llamados sucesivos a <code>basicConfig()</code> entonces el primer llamado es el que define el  comportamiento del logger.</p>"},{"location":"modulos/logging/#opciones-de-salida-manejadores","title":"Opciones de salida - manejadores","text":"<p>Hay un par\u00e1metro adicional que permite configurar m\u00faltiples salidas en simult\u00e1neo llamado <code>handlers</code>, al cual se le asignan todos los manejadores de inter\u00e9s:</p> <p>Configuraci\u00f3n de reportes - Multiples salidas<pre><code>logging.basicConfig(\n    level=logging.INFO, # m\u00ednimo nivel de log a publicar\n    format=\"%(asctime)s - %(levelname)s - %(message)s\", #info incorporada\n    handlers=[\n         # salida por consola\n        logging.StreamHandler(), \n        # salida por archivo\n        logging.FileHandler(\n            filename=\"reporte.log\",\n            mode=\"a\",\n            encoding=\"utf-8\",\n            delay=True,\n            ),  \n        ],\n\n    )\n</code></pre> El m\u00f3dulo <code>logging</code> ofrece para manejar reportes por consola la funci\u00f3n <code>StreamHandler()</code>, en tanto que para manejar archivos ofrece <code>FileHandler()</code>. Hay otras funciones para manejar reportes mediante sockets (<code>SocketHandler</code> y <code>DatagramHandler</code> ), mediante colas (<code>QueueHandler</code>), etc.</p> <p>M\u00e1s sobre los handlers disponibles y sus opciones: documentacion oficial </p>"},{"location":"modulos/logging/#niveles-de-logs","title":"Niveles de logs","text":"<p>Los niveles de reportes permiten clasificar los mensajes de reportes en base a una jerarqu\u00eda de eventos, permitiendo filtrar los reportes en base al objetivo del reporte. Por ejemplo, para desarrollo es \u00fatil crear un reporte completo donde se incorporen mensajes informativos que releven incluso el buen funcionamiento del programa, en tanto que para el uso por el usuario final conviene reportar solamente los fallos ya producidos y posiblemente tambi\u00e9n las advertencias lanzadas preventivamente.</p> <p>Los niveles de reportes implementados son los siguientes:</p> opci\u00f3n valor num\u00e9rico descripci\u00f3n NOTSET 0 (Se consulta a loggers previos para definir el comportamiento) DEBUG 10 Informaci\u00f3n detallada, normalmente usada para debug. INFO 20 Confirmaci\u00f3n de funcionamiento esperado. WARNING 30 El software funciona a\u00fan, pero puede haber problemas a futuro. ERROR 40 Problema serio que anula una funcionalidad del software. CRITICAL 50 Error serio que impide al software continuar funcionando."},{"location":"modulos/logging/#creacion-de-logs","title":"Creaci\u00f3n de logs","text":"<p>Cada nivel de reporte tiene su propia funci\u00f3n emisora, al que se le puede asignar un mensaje explicativo. Uso b\u00e1sico: </p> Creaci\u00f3n de reportes<pre><code>logging.debug(\"Texto de DEBUG\")\nlogging.info(\"Texto de INFO\")\nlogging.warning(\"Texto de WARNING\")\nlogging.error(\"Texto de ERROR\")\nlogging.critical(\"Texto de CRITICAL\")\n</code></pre> <p>Cabe resaltarse que los logs se emiten al llamar a la funci\u00f3n emisora elegida.</p> Creaci\u00f3n de reportes<pre><code>retorno = funcion()\nif retorno == None:\n    logging.info(f\"Sin valor de retorno - OK\")\nelse:\n    logging.error(f\"Tipo de dato recibido: {type(retorno)}\")\n</code></pre>"},{"location":"modulos/logging/#uso-aplicado-decoradores-de-logging","title":"Uso aplicado: decoradores de logging","text":"<p>Una forma c\u00f3moda de aplicar el logging a las funciones es mediante el uso de decoradores, lo cual permite usar la misma rutina de logging a m\u00faltiples funciones. M\u00e1s sobre decoradores</p> <p>TIP N\u00ba1: Decorador logger para excepciones</p> <p>Este primer ejemplo usa un decorador simple, dentro del cual se hace manejo de excepciones mediante <code>try</code> - <code>except</code>.</p> Definici\u00f3n<pre><code>def logger_excepcion(funcion_entrada):\n    def funcion_envolvente(*args, **kwargs):\n        try:\n            retorno = funcion_entrada(*args, **kwargs)\n            logging.info(f\"Funcion '{funcion_entrada.__name__}' - Sin excepciones producidas\")\n        except Exception as ex:\n            logging.error(f\"Funcion '{funcion_entrada.__name__}' - Excepci\u00f3n: '{type(ex).__name__}'\")\n    return funcion_envolvente\n</code></pre> Uso<pre><code>@logger_excepcion\ndef dividir(a, b):\n    return(a / b)\n\n\ndividir( 4, 7)\ndividir( 7, 4)\ndividir( 1, 0.5 )\ndividir( 1, 0)      # \"ERROR - Funcion 'dividir' - Excepci\u00f3n: 'ZeroDivisionError'\"\n</code></pre> <p>TIP N\u00ba2: Decorador logger para verificar tipos de retorno</p> <p>Este segundo ejemplo usa un decorador con argumentos, de manera de poder especificar el tipo de retorno deseado para cada funci\u00f3n.</p> Definici\u00f3n<pre><code>def logger_retorno(tipo:type=None):\n    def _logger_retorno(funcion_entrada):\n        def funcion_envolvente(*args, **kwargs):\n            retorno = funcion_entrada(*args, **kwargs)\n            if type(retorno) == tipo:\n                logging.info(f\"Funcion '{funcion_entrada.__name__}' - Sin problemas de retorno\")\n            else:\n                logging.warning(f\"Funcion '{funcion_entrada.__name__}' - Tipo de retorno incorrecto: '{type(retorno).__name__}'\")\n        return funcion_envolvente\n    return _logger_retorno\n</code></pre> Uso<pre><code>@logger_retorno(int)\ndef suma(x, y):\n    return x + y\n\n\nsuma(1, 1)\nsuma(3,2)\nsuma(\"hola\", \"mundo\")   # \"WARNING - Funcion 'suma - Tipo de retorno incorrecto: 'str'\"\nsuma(9.2 , 7)           # \"WARNING - Funcion 'suma - Tipo de retorno incorrecto: 'float'\"\n</code></pre>"},{"location":"modulos/logging/#referencias","title":"Referencias","text":"<p>Documentacion oficial</p>"},{"location":"modulos/os/","title":"M\u00f3dulo OS - Comandos del Sistema Operativo","text":"<p>El m\u00f3dulo de interacci\u00f3n con el sistema operativo se llama os. \u00c9ste debe importarse para su uso:</p> importaci\u00f3n<pre><code>import os\n</code></pre>"},{"location":"modulos/os/#tratar-con-directorios","title":"Tratar con directorios","text":"<p>\u00c9ste incluye un surtido de funciones predeterminadas para ejercer acciones con ayuda del sistema operativo.</p> <p>Ejemplo:</p> Operaciones con rutas de archivo<pre><code>os.getcwd()     # Ver directorio actual de trabajo\nos.chdir( ruta )    # Cambiar directorio actual de trabajo\nos.listdir()    # Archivos y subcarpetas del directorio actual\n</code></pre>"},{"location":"modulos/os/#ejecutar-comandos","title":"Ejecutar comandos","text":"<p>Tambi\u00e9n incluye la funci\u00f3n system() que permite ejecutar los comandos de la terminal, pero su funcionamiento depende del sistema operativo. Ejemplo con comandos Linux /Bash:</p> Comandos con os.system()<pre><code>os.system(\u201cls -l\u201d)  # Da una lista de todos los archivos y carpetas visibles\nos.system(\u201cls -la\u201d) # Lista tambi\u00e9n todos los archivos y carpetas ocultos\n</code></pre>"},{"location":"modulos/os/#eliminar-archivos","title":"Eliminar archivos","text":"<p>Se puede pedir la eliminaci\u00f3n de un archivo mediante la funci\u00f3n remove(): eliminar archivo<pre><code>os.remove(ruta_archivo)\n</code></pre></p>"},{"location":"modulos/pathlib/","title":"Pathlib","text":""},{"location":"modulos/pathlib/#introduccion","title":"Introducci\u00f3n","text":"<p>El m\u00f3dulo pathlib facilita el manejo de rutas de archivo y tambi\u00e9n permite interactuar con archivos y directorios reales del sistema de archivos.</p> importacion<pre><code>import pathlib\n</code></pre> <p>Hay seis funciones/clases disponibles para trabajar con las rutas, que pueden ordenarse en funcionalidad como sigue:  </p> <ul> <li>Path() <ul> <li>PosixPath()       : s\u00f3lo rutas Posix (UINIX, Linux, etc)</li> <li>WindowsPath()     : s\u00f3lo rutas Windows</li> </ul> </li> <li>PurePath()<ul> <li>PurePosixPath()   : s\u00f3lo rutas Posix (UINIX, Linux, etc)</li> <li>PureWindowsPath() : s\u00f3lo rutas Windows</li> </ul> </li> </ul> <p>La funci\u00f3n m\u00e1s importante es Path(), que es la m\u00e1s versatil y permite tanto trabajar con strings que representan rutas arbitrarias como tambi\u00e9n alterar archivos y carpetas reales del sistema, en tanto que PurePath() es la versi\u00f3n recortada de Path() que s\u00f3lo permite manejar strings a modo de rutas. Ambas funciones aceptan rutas de Windows y de sistemas POSIX (UNIX, Linux, etc). Estas dos funciones tienen tambi\u00e9n sus versiones recortadas para uso exclusivo con rutas POSIX y Windows, respectivamente.</p> <p>Estas funciones pueden importarse de forma aislada para su uso:</p> importaci\u00f3n de m\u00f3dulo<pre><code>from pathlib import Path, PurePath  # todo tipo de rutas\nfrom pathlib import WindowsPath, PureWindowsPath    # solo rutas Windows\nfrom pathlib import PosixPath, PurePosixPath    # solo rutas Linux/MAC/etc\n</code></pre> <p>Importante: Los resultados de usar algunos m\u00e9todos de Path() y de PurePath() pueden variar en funci\u00f3n del sistema operativo anfitri\u00f3n. En tal caso es conveniente usar sus versiones exclusivas de Windows o de POSIX, seg\u00fan sea la ruta a trabajar (ver m\u00e1s adelante).</p> <p>Importante 2: varias de las funciones del m\u00f3dulo pathlib coinciden en nombre con las funciones del modulo os, las cuales no necesariamente se usan igual.  </p>"},{"location":"modulos/pathlib/#objetos-path","title":"Objetos Path","text":"<p>La funciones del m\u00f3dulo pathlib crean objetos para cada ruta que se le indique:</p> Objetos Path<pre><code>ruta: str \nobjeto_ruta      = pathlib.Path(ruta)       # funcionalidad completa\nobjeto_ruta_pura = pathlib.PurePath(ruta)   # funcionalidad recortada\n</code></pre> <p>Estos objetos incluir\u00e1n los m\u00e9todos necesarios para trabajar con las rutas.</p> <p>Como alternativa se pueden usar los m\u00e9todos como si fueran funciones.</p>"},{"location":"modulos/pathlib/#analisis-de-rutas","title":"Analisis de rutas","text":""},{"location":"modulos/pathlib/#nombre-y-extensiones-de-archivos-name-suffix-suffixes-stem","title":"Nombre y extensi\u00f3n(es) de archivos - name, suffix, suffixes, stem","text":"Archivo en ruta<pre><code># Objetos 'Path' y 'PurePath'\nnombre_archivo = objeto_ruta.name       # nombre completo\nnombre_archivo = objeto_ruta.suffix     # extension archivo\nnombre_archivo = objeto_ruta.suffixes   # lista extensiones (usuales en POSIX)\nnombre_archivo = objeto_ruta.stem       # nombre sin extensi\u00f3n archivo\n</code></pre>"},{"location":"modulos/pathlib/#recorrido-de-ruta-parent-parents-y-parts","title":"Recorrido de ruta - parent, parents y parts","text":"Carpetas de ruta<pre><code># Objetos 'Path' y 'PurePath'\nruta_carpeta_superior = objeto_ruta.parent     # carpeta inmediatamente superior de la ruta\nrutas_carpetas_superiores = objeto_ruta.parents    # todas las carpetas superiores que conforman la ruta \nlista_partes = objeto_ruta.parts       # descomposicion en partes\n</code></pre>"},{"location":"modulos/pathlib/#rutas-absolutas-y-relativas-is_absolute","title":"Rutas absolutas y relativas - is_absolute()","text":"Verificaci\u00f3n rutas absolutas<pre><code>absoluta = PurePosixPath(\"/\").is_absolute()     # 'True'\nabsoluta = PurePosixPath(\"../\").is_absolute()   # 'False'\n\nabsoluta = PureWindowsPath(\"c:\\\\\").is_absolute()    # 'True'\nabsoluta = PureWindowsPath(\"..\\\\Documentos\").is_absolute() # 'False'\n\n# ....\nabsoluta = PurePath(ruta).is_absolute() # (depende del sistema operativo local)\n</code></pre> <p>Si se usa Path() o PurePath() hay que tener cuidado con el sistena operativo anfitrion porque en base a \u00e9ste se puede descartar rutas absolutas de otros sistemas operativos</p> Problemas de verificacion<pre><code># POSIX: MAC, UNIX, LINUX\nruta=\"/home\"\nabsoluta = PureWindowsPath(ruta).is_absolute()   # 'False'\nabsoluta = PurePosixPath(ruta).is_absolute()     # 'True'\nabsoluta = PurePath(ruta).is_absolute() # 'True' solo en POSIX, 'False' en caso contrario\n\n# WINDOWS\nruta=\"c:\\\\windows\"\nabsoluta = PureWindowsPath(ruta).is_absolute()   # 'True'\nabsoluta = PurePosixPath(ruta).is_absolute()     # 'False'\nabsoluta = PurePath(ruta).is_absolute()     # 'True' solo en Windows, 'False' en caso contrario\n</code></pre>"},{"location":"modulos/pathlib/#relacion-entre-rutas-is_relative_to","title":"Relacion entre rutas - is_relative_to()","text":"Verificaci\u00f3n rutas relativas<pre><code># Rutas POSIX exclusivamente\nrelativos = PurePosixPath(\"home/user\").is_relative_to(\"home\")    # 'True'\nrelativos = PurePosixPath(\"home/user\").is_relative_to(\"user\")    # 'False'\n\n# Rutas Windows exclusivamente\nx = PureWindowsPath(\"c:\\\\windows\\\\win32\").is_relative_to(\"c:\\\\\")    # 'True'\nx = PureWindowsPath(\"c:\\\\windows\\\\win32\").is_relative_to(\"windows\") # 'False'\n\n# Caso general\nrelativos = PurePath(\"home/user\").is_relative_to(\"home\")    # S\u00f3lo da 'True' en POSIX \nx = PurePath(\"c:\\\\windows\\\\win32\").is_relative_to(\"c:\\\\\")    # S\u00f3lo da 'True' en Windows\n</code></pre>"},{"location":"modulos/pathlib/#composicion-de-rutas-path-purepath-y-joinpath","title":"Composicion de rutas - Path(), PurePath() y joinpath()","text":"Composici\u00f3n rutas<pre><code>ruta_A: str = \"home\"\nruta_B: str = \"user\"\n\nobjeto_compuesto = PurePath(ruta_A, ruta_B)\nobjeto_compuesto = PurePath(ruta_A).joinpath(ruta_B)\n\n# conversion a texto\nruta_compuesta = str(objeto_compuesto)  # '/home/user'\n</code></pre>"},{"location":"modulos/pathlib/#interaccion-con-el-sistema-de-archivos","title":"Interaccion con el sistema de archivos","text":""},{"location":"modulos/pathlib/#buscar-y-comprobar-archivos-y-directorios","title":"Buscar y comprobar archivos y directorios","text":""},{"location":"modulos/pathlib/#busqueda-de-archivos-y-carpetas-iterdir","title":"Busqueda de archivos y carpetas - iterdir()","text":"B\u00fasqueda simple<pre><code>ruta_carpeta: str\nobjeto_ruta = Path(ruta_carpeta)\n\nobjeto_busqueda = objeto_ruta.iterdir()\nrutas_internas = list(objeto_busqueda)\n</code></pre>"},{"location":"modulos/pathlib/#explorar-todo-walk","title":"Explorar todo - walk()","text":"B\u00fasqueda recursiva<pre><code>ruta_carpeta: str\nobjeto_ruta = Path(ruta_carpeta)\n\nobjeto_exploracion = objeto_ruta.walk(top_down=True)\nobjeto_directorios = list(objeto_exploracion)\n# descomposicion en sus partes m\u00e1s elementales\nfor directorio in objeto_directorios:\n    [ruta, subdirectorios, archivos ] = list(directorio)\n    print(ruta)\n    print(subdirectorios)\n    print(archivos)\n</code></pre>"},{"location":"modulos/pathlib/#busqueda-de-patrones-glob-y-rglob","title":"Busqueda de patrones - glob() y rglob()","text":"B\u00fasqueda por patr\u00f3n<pre><code>ruta:_directorio: str\npatron: str\n\nobjeto = pathlib.Path(ruta_directorio).glob(patron)    # busqueda \nobjeto = pathlib.Path(ruta_directorio).rglob(patron)   # busqueda recursiva\n\nlista_rutas = list(objeto)      # resultado\n</code></pre> <p>Ejemplo de uso: busqueda recursiva de imagenes .png y .PNG</p> Ejemplo: b\u00fasqueda de imagenes .png y .PNG<pre><code>objeto = pathlib.Path(ruta).rglob(\"*.png\", case_sensitive=False)\nlista_imagenes = list(objeto) \n</code></pre>"},{"location":"modulos/pathlib/#comparar-rutas-samefile","title":"Comparar rutas - samefile()","text":"<p>Comparar rutas<pre><code># rutas del sistema (DEBEN existir o da error)\nruta_A: str = \"/home\"\nruta_B: str = \"/etc\"\n\n# compara\nmismo_ruta = pathlib.Path(ruta_A).samefile(ruta_B) # 'False'   \nmisma_ruta = pathlib.Path(ruta_A).samefile(ruta_A) # 'True'\n</code></pre> N\u00f3tese que samefile() sirve tambi\u00e9n para directorios.</p> <p>Este metodo es pr\u00e1ctico para comparar rutas relativas con rutas absolutas. </p> <p>Ejemplos:</p> Ejemplo: comparando rutas<pre><code># comparando directorio actual\nruta_actual = pathlib.Path().cwd()\niguales = pathlib.Path(ruta_actual).samefile(\"\")  # 'True'\n\n# comparando directorio padre\nruta_padre = pathlib.Path().cwd().parent\niguales = pathlib.Path(ruta_padre).samefile(\"../\") # 'True'\n</code></pre>"},{"location":"modulos/pathlib/#estadisticas-de-archivo-stat","title":"Estadisticas de archivo - stat()","text":"<p>Provee informaci\u00f3n variada sobre la ruta: fechas de creacion y modificacion, espacio en disco, identificadores de usuario y de grupo, etc. </p> <p>Uso: Estadisticas de archivo<pre><code>estadisticas = Path(ruta).stat()\n</code></pre> Algunos atributos internos:</p> Datos de archivo<pre><code># identificadores (ID)\nestadisticas.st_uid     # identificador d usuario\nestadisticas.st_gid     # identificador de grupo\n# espacio disco (si es carpeta no incluye contenido)\nestadisticas.st_size    # espacio disco en bytes \n# fechas - formato POSIX\nestadisticas.st_ctime   # creacion\nestadisticas.st_mtime   # ultima modificacion\nestadisticas.st_atime   # ultimo acceso\n</code></pre>"},{"location":"modulos/pathlib/#convertir-rutas-absolute","title":"Convertir rutas - absolute()","text":"Conversi\u00f3n a ruta absoluta<pre><code># Objeto 'Path'\nnombre_archivo = objeto_ruta.absolute() # conversion a ruta absoluta\n</code></pre> <p>Ejemplo de uso: ruta del directorio con el ejecutable Ruta absoluta actual<pre><code># ruta directorio de ejecuci\u00f3n actual\nnombre_archivo = Path(\"\").absolute()\n</code></pre></p>"},{"location":"modulos/pathlib/#usuarios-y-grupos-owner-y-group","title":"Usuarios y grupos - owner() y group()","text":"Propietario y Grupo<pre><code>usuario_propietario         = objeto_ruta.owner()\ngrupo_usuario_propietario   = objeto_ruta.group()\n</code></pre>"},{"location":"modulos/pathlib/#verificar-existencia-exists","title":"Verificar existencia - exists()","text":"Verificar<pre><code>existe = Path(ruta).exists()\n</code></pre>"},{"location":"modulos/pathlib/#cambio-permisos-chmod","title":"Cambio permisos - chmod()","text":"Cambiar permisos<pre><code>numero_permisos: int    # numero en octal o hexadecimal\nPath(ruta).chmod(numero_permisos)       # ver anexo sobre permisos\n</code></pre> <p>Ejemplo uso: Ejemplo: cambiar permisos<pre><code># Usuario actual: leer y escribir\n# otros: solo leer\nPath(ruta).chmod(0o644)\n</code></pre></p>"},{"location":"modulos/pathlib/#archivos","title":"Archivos","text":""},{"location":"modulos/pathlib/#objeto-para-ruta-archivo","title":"Objeto para ruta archivo","text":"Path archivo<pre><code>ruta_archivo: str \n# Objeto 'Path'\nobjeto_archivo = pathlib.Path(ruta_archivo)\n</code></pre>"},{"location":"modulos/pathlib/#crear-verificar-y-eliminar-touch-is_file-y-unlink","title":"Crear, verificar y eliminar - touch(), is_file() y unlink()","text":"Manipular archivos<pre><code># crea archivo vacio (puede dar error)\nobjeto_archivo.touch()       \nobjeto_archivo.touch(\n    mode=0o666,     # permisos de usuarios: lectura y escritura por defecto (ver anexo)\n    exist_ok=True   # omite error si el archivo ya existe\n    )     \n# verifica que exista el archivo\nexistencia = objeto_archivo.is_file()   \nif existencia:\n    objeto_archivo.unlink() # elimina archivo\n\nobjeto_archivo.unlink(missing_ok=True) # elimina archivo si existe\n</code></pre>"},{"location":"modulos/pathlib/#lectura-y-escritura-de-texto-read_text-y-write_text","title":"Lectura y escritura de texto - read_text() y write_text()","text":"Leer y escribir texto<pre><code># lectura\ntexto = objeto_archivo.read_text()\n# escritura/sobreescritura\nnro_caracteres = objeto_archivo.write_text('contenido de archivo.')\n</code></pre>"},{"location":"modulos/pathlib/#lectura-y-escritura-binaria-read_bytes-y-write_bytes","title":"Lectura y escritura binaria - read_bytes() y write_bytes()","text":"Leer y escribir bytes<pre><code># lectura\ndata_binarios = objeto_archivo.read_bytes()\n# escritura/sobreescritura\nnro_bytes = objeto_archivo.write_bytes(b'contenido de archivo.')\n</code></pre>"},{"location":"modulos/pathlib/#directorios","title":"Directorios","text":""},{"location":"modulos/pathlib/#objeto-para-ruta-de-directorio","title":"Objeto para ruta de directorio","text":"Path directorio<pre><code>ruta_directorio: str \n# Objeto 'Path'\nobjeto_directorio = Path(ruta_directorio)\n</code></pre>"},{"location":"modulos/pathlib/#manipular-carpetas-mkdir-is_dir-y-rmdir","title":"Manipular carpetas - mkdir(), is_dir() y rmdir()","text":"Manipular carpetas<pre><code># crea directorio vacio, opciones predefinidas (puede dar error)\nobjeto_directorio.mkdir()\n# crea directorio vacio\nobjeto_directorio.mkdir(\n    mode=0o777,     # permisos de usuario: todos por defecto (ver anexo)\n    parents=True,   # crea los directorios padre si \u00e9stos no existen\n    exist_ok=True   # evita error por sobreeescritura\n    )\n# verifica que exista el directorio\nexistencia = objeto_directorio.is_dir()   \nif existencia:\n    objeto_directorio.rmdir() # elimina directorio (debe estar vacio)\n</code></pre>"},{"location":"modulos/pathlib/#carpeta-usuario-home","title":"Carpeta Usuario - home()","text":"ruta 'home'<pre><code>carpeta_usuaurio = pathlib.Path().home()   # carpeta personal del usuario actual\n</code></pre>"},{"location":"modulos/pathlib/#carpeta-actual-del-programa-cwd","title":"Carpeta actual del programa - cwd()","text":"ruta actual<pre><code>carpeta_programa = pathlib.Path().cwd()   # carpeta actual del programa\n</code></pre>"},{"location":"modulos/pathlib/#pendiente-explorar-los-symlinks","title":"Pendiente: explorar los symlinks","text":"<p>los symilnks son los enlaces simb\u00f3licos de Linux. Son similares a los accesos directos de Windows</p>"},{"location":"modulos/pathlib/#anexo-permisos-de-usuario-en-linux","title":"Anexo - permisos de usuario en linux","text":"<p>Los permisos de usuario se asignan mediante por un numero binario / octal / hexadecimal de tres digitos. </p>"},{"location":"modulos/pathlib/#permisos-para-acciones","title":"Permisos para acciones","text":"<p>Cada d\u00edgito es una composici\u00f3n de banderines que otorgan permisos para leer, escribir y ejecutar. Los valores num\u00e9ricos equivalentes para cada permiso aslado son:</p> Permiso binario octal hexadecimal Leer  (r) 0b100 0o4 0h4 Escribir (w) 0b10 0o2 0h2 Ejecutar (x) 0b1 0o1 0h1 <p>Los numeros de los permisos se construyen combinando los numeros previos.</p> <p>Ejemplos:</p> Permiso combinado binario octal hexadecimal S\u00f3lo lectura (r) 0b100 0o4 0h4 Lectura y escritura (r+w) 0b110 0o6 0h6 Lectura, escritura y ejecucion  (r+w+x) 0b111 0o7 0h7 S\u00f3lo ejecucion  (x) 0b001 0o1 0h1"},{"location":"modulos/pathlib/#permisos-para-usuarios","title":"Permisos para usuarios","text":"<p>Los digitos con los permisos se asignan con el siguiente orden de usuarios:</p> <ul> <li>usuario actual;</li> <li>grupo del usuario actual;</li> <li>todos los usuarios.</li> </ul> <p>Notacion resumida:</p> Usuario Grupo Todos rwx rwx rwx <p>Info</p> <p>Importante: el usuario administrador ('root') del sistema siempre tiene todos los derechos posibles, por ello no se lo especifica.</p> <p>Ejemplo 1: Permisos diferenciados</p> <ul> <li>usuario propietario con todos los permisos; </li> <li>grupo del propietario con lectura y escritura;  </li> <li>accesos de s\u00f3lo lectura para terceros.</li> </ul> <p>Numero permisos:</p> <p>0o 111 110 100 (binario)  | 0o764 (octal)  | 0x764 (hexadecimal)</p> <p>Ejemplo 2: Todos los permisos para todos los ususarios (mala pr\u00e1ctica)</p> <p>Numero permisos:</p> <p>0o 111 111 111 (binario)  | 0o777 (octal)  | 0x777 (hexadecimal)</p>"},{"location":"modulos/pathlib/#referencias","title":"Referencias","text":"<p>Documentacion oficial del m\u00f3dulo Pathlib</p> <p>FreeCodeCamp - crear y remover enlaces simb\u00f3licos</p>"},{"location":"modulos/regex/","title":"Expresiones Regulares (RegEx) - Modulo RE","text":""},{"location":"modulos/regex/#modulo-re","title":"Modulo re","text":"<p>Python tiene un m\u00f3dulo dedicado para detectar y trabajar con secuencias llamado re. Este m\u00f3dulo debe importarse para su uso:</p> <pre><code>import re\n</code></pre>"},{"location":"modulos/regex/#funciones","title":"Funciones","text":"<p>El modulo re incluye m\u00faltiples funciones para trabajar con la detecci\u00f3n de patrones, las cuales se explican a continuaci\u00f3n. Estas funciones aceptan tanto el uso de secuencias fijas como de patrones regulares.</p>"},{"location":"modulos/regex/#sintaxis-y-opciones","title":"Sintaxis y opciones","text":"<p>La mayor\u00eda de las funciones del m\u00f3dulo tienen el siguiente formato: <pre><code>&lt;retorno&gt; = re.&lt;funcion&gt;(&lt;patron&gt;, &lt;texto&gt;, &lt;opcion&gt;)\n</code></pre> El pat</p> <p>La opci\u00f3n de entrada agrega modificaciones a la detecci\u00f3n del patr\u00f3n. Su indicaci\u00f3n no es obligatoria y puede tomar varios valores predefinidos por el m\u00f3dulo. Por ejemplo, la opci\u00f3n <code>re.I</code> (re.IGNORECASE) no distingue mayusculas de min\u00fasculas.</p> <p>Opciones habituales:</p> Opcion significado <code>re.A</code> s\u00f3lo compara caracteres ASCII <code>re.I</code> no discrimina mayusculas de minusculas <code>re.L</code> depende de la configuraci\u00f3n regional <code>re.M</code> varias lineas <code>re.S</code> si el patron incluye puntos estos son opcionales <code>re.U</code> compara caracteres Unicode <code>re.X</code> (verbose)  (?) <p>A continuaci\u00f3n se explican las funciones del m\u00f3dulo. </p>"},{"location":"modulos/regex/#match","title":"<code>match()</code>","text":"<p><code>match()</code> busca una secuencia justo al comienzo de un string:</p> <p>match() - uso<pre><code>&lt;retorno&gt; = re.match(&lt;patron&gt;, &lt;texto&gt;, &lt;opcion&gt;)\n</code></pre> <code>match()</code> devuelve un objeto <code>re.Match()</code> cuando encuentra el patr\u00f3n y sino devuelve <code>None</code>.  <code>re.Match()</code> tiene un m\u00e9todo llamado <code>span()</code> que indica los indices de inicio a fin de la secuencia en forma de tupla.  Se lo llama as\u00ed:</p> match() - indices de secuencia<pre><code>&lt;retorno&gt;.span()\n</code></pre> <p>Ejemplo: <pre><code>import re\n\npatron = \"leccion\"\n\ntexto1 = \"leccion 1: regex\"\ntexto2 = \"esta no es la leccion 1 sino la leccion 3\"\n\nretorno1 = re.match(patron, texto1, re.I)    # Devuelve 're.Match()'\nretorno2 = re.match(patron, texto2, re.I)    # Devuelve None\n</code></pre></p> <p>Si el patr\u00f3n fue detectado el retorno de la funcion <code>match()</code> ser\u00e1 un objeto de tipo <code>re.Match</code> y de \u00e9l se puede leer el resultado y su ubicaci\u00f3n con ayuda de los m\u00e9todos <code>group()</code> y <code>span()</code>.  El m\u00e9todo <code>span()</code> devuelve los indices de inicio y fin del primer patr\u00f3n detectado, en tanto que el m\u00e9todo <code>group()</code> devuelve el segmento del texto que cumple con el patr\u00f3n.</p> <pre><code>print(retorno1.group())     # patron detectado: leccion\nprint(retorno1.span())      # rango letras: (0,7)\n</code></pre> <p>Si en cambio el patr\u00f3n no fue detectado el retorno de <code>match()</code> ser\u00e1 <code>None</code> e intentar usar los m\u00e9todos <code>group()</code> y <code>span()</code> dar\u00e1 error.  Por ello es importante verificar el tipo de datos que arroja la funci\u00f3n antes de intentar extraer una secuencia  de salida. </p> <p>Continuando con el ejemplo previo: <pre><code>retorno = retorno1      # hay coincidencia\n# retorno = retorno2    # no hay coincidencia\n\nif type(retorno)==re.Match:\n    print(\"patron encontrado!\")\n    print(\"valor:    \",retorno.group())     # da 'leccion'\n    print(\"ubicacion:\" ,retorno.span())     # da '(0, 7)'\nelse:\n    print(\"patron no detectado\")    \n</code></pre></p>"},{"location":"modulos/regex/#search","title":"<code>search()</code>","text":"<p>Busca la primera coincidencia de una secuencia en cualquier lugar del string indicado:</p> search()<pre><code>&lt;retorno&gt; = re.search(&lt;patron&gt;, &lt;texto&gt;, &lt;opcion&gt;)\n</code></pre> <p><code>search()</code> devuelve un objeto <code>re.Match()</code> cuando encuentra el patr\u00f3n (igual que la funcion <code>match()</code>) y sino devuelve None.</p> <p>Ejemplo:</p> <p><pre><code>import re\n\npatron = \"leccion\"\n\ntexto1 = \"leccion 1: regex\"\ntexto2 = \"esta no es la leccion 1 sino la leccion 3\"\ntexto3 = \"aqui no se ense\u00f1a nada\"\n\nretorno1 = re.search(patron, texto1, re.I)    # Devuelve 're.Match()'\nretorno2 = re.search(patron, texto2, re.I)    # Devuelve 're.Match()'\nretorno3 = re.search(patron, texto3, re.I)    # Devuelve 'None'\n</code></pre> Al igual que con la funci\u00f3n <code>match()</code>, con el m\u00e9todo <code>span()</code> se obtienen los indices de inicio y fin del primer patr\u00f3n detectado, en tanto que con el m\u00e9todo <code>group()</code> se devuelve el resultado de la busqueda:</p> <p><pre><code>print(retorno1.span()  )  # '(0, 7)'\nprint(retorno1.group() )  # 'leccion'\nprint(retorno2.span()  )  # '(14, 21)'\nprint(retorno2.group() )  # 'leccion'\n</code></pre> Nuevamente hay que prestar atenci\u00f3n al tipo de retorno de la funci\u00f3n <code>search()</code> para evitar errores en la ejecuci\u00f3n en caso de no detectarse el patr\u00f3n buscado.</p>"},{"location":"modulos/regex/#findall","title":"<code>findall()</code>","text":"<p>Busca todas las coincidencias  de una secuencia en un string findall()<pre><code>&lt;retorno&gt; = re.findall(&lt;patron&gt;, &lt;texto&gt;, &lt;opcion&gt;)\n</code></pre> Devuelve una lista con todas coincidencias con el patr\u00f3n indicado. Si no hay coincidencias la lista queda vac\u00eda.</p> <p>Ejemplo: <pre><code>import re\n\npatron = \"leccion\"\n\ntexto1 = \"leccion 1: regex\"\ntexto2 = \"esta no es la leccion 1 sino la leccion 3\"\ntexto3 = \"aqui no se ense\u00f1a nada\"\n\nretorno1 = re.findall(patron, texto1, re.I)  # devuelve '['leccion']'\nretorno2 = re.findall(patron, texto2, re.I) # devuelve '['leccion', 'leccion']'\nretorno3 = re.findall(patron, texto3, re.I) # devuelve '[]'\n</code></pre></p>"},{"location":"modulos/regex/#split","title":"<code>split()</code>","text":"<p>Parte un string en trozos limitados por un caracter o secuencia patr\u00f3n indicado: split()<pre><code>&lt;retorno&gt; = re.split(&lt;patron&gt;, &lt;texto&gt;,&lt;opcion&gt;)\n</code></pre> El valor de retorno es una lista con el texto dividido y el patr\u00f3n eliminado. <pre><code>import re\n\npatron = \"leccion\"\n\ntexto1 = \"leccion 1: regex\"\ntexto2 = \"esta no es la leccion 1 sino la leccion 3\"\n\nretorno1 = re.split(patron, texto1, re.I)    # Devuelve \"['', ' 1: regex']\"\nretorno2 = re.split(patron, texto2, re.I)    # Devuelve \"['esta no es la ', ' 1 sino la ', ' 3']\"\n</code></pre> N\u00f3tese c\u00f3mo la palabra \"leccion\" fue eliminada y como en la lista de retorno puede haber textos vac\u00edos.</p>"},{"location":"modulos/regex/#sub","title":"<code>sub()</code>","text":"<p>Reemplaza una secuencia por otra dentro de un string todas las veces que aparezca. <pre><code>&lt;retorno&gt; = re.sub(&lt;patron&gt;, &lt;sustituto&gt;,&lt;texto&gt;)\n</code></pre> Ejemplo:</p> <pre><code>import re\n\ntexto1 = \"leccion 1: regex\"\ntexto2 = \"esta no es la leccion 1 sino la leccion 3.1\"\ntexto3 = \"leccion 2.UNO\"\n\nretorno1 = re.sub(\"1\", \"UNO\", texto1) # Devuelve \"leccion UNO: regex\"\nretorno2 = re.sub(\"1\", \"UNO\", texto2) # Devuelve \"esta no es la leccion UNO sino la leccion 3.UNO\"\nretorno3 = re.sub(patron , sustituto , texto3) # Devuelve \"leccion 2.UNO\"  (No cambia nada)\n</code></pre>"},{"location":"modulos/regex/#patrones-regulares","title":"Patrones regulares","text":"<p>Los patrones regulares son expresiones que sirven para describir combinaciones gen\u00e9ricas de caracteres que cumplan ciertas condiciones. Las expresiones tienen una notaci\u00f3n estandarizada por lo que pueden aplicarse en distintos lenguajes de programaci\u00f3n con iguales resultados.</p> <p>En el caso de Python los patrones regulares se definen antecedidos por la letra 'r':</p> <p><pre><code>&lt;patron&gt; = r\"&lt;patron_regex&gt;\"\n</code></pre> Estos patrones se ingresan en las funciones explicadas previamente como argumento para modificar los datos de entrada: filtrar, cortar , reemplazar, etc.</p>"},{"location":"modulos/regex/#patron-para-cifras-numericas","title":"Patr\u00f3n para cifras num\u00e9ricas","text":"<p>Este patr\u00f3n sirve para detectar una o varias cifras num\u00e9ricas contiguas <pre><code>patron_cifras = r\"[0-9]+\" \n</code></pre></p> <p>Uso: aislar el primer n\u00famero de un texto</p> <pre><code>entrada = \"imag_025\"\n\npatron_cifras  = r\"[0-9]+\" \n\nretorno = re.search(patron_cifras, entrada)\ndetectado= retorno.group()      # devuelve '025'\nrango = retorno.span()          # indices: '(5, 8)'\n</code></pre>"},{"location":"modulos/regex/#patron-para-fotos-digitales","title":"Patr\u00f3n para fotos digitales","text":"<p>Este patr\u00f3n sirve para filtrar archivos de c\u00e1maras digitales , smartphones, etc. </p> <p><pre><code>patron_foto = r\"^[0-9]+_[0-9]+\\.[A-Za-z]+$\"\n</code></pre> El nombre de archivo suele ser  un numero compuesto por la fecha con un gui\u00f3n bajo en el medio. Por ejemplo, una foto hecha el 23 de junio del 2022 , hora 06:59:12 probablemente tendr\u00e1 por nombre de archivo: <pre><code>archivo = \"20220623_065912.jpg\" #foto camara digital /smartphone\n</code></pre></p> <p>Uso: filtrar nombres de archivo de c\u00e1maras (sin renombrar)</p> <pre><code>import re\n\narchivo1 = \"20220623_065912.jpg\" #foto camara digital /smartphone\narchivo2 = \"20220623065912.jpg\" # falta el guion\narchivo3 = \"RTY220623_A65912.jpg\" # hay letras\narchivo4 = \"/carpetaPOSIX/20220623_065912.jpg\" # ruta POSIX (Unix / Linux)\narchivo5 = \"\\carpetaWINDOWS\\20220623_065912.jpg\" # ruta Windows\n\npatron_foto = r\"^[0-9]+_[0-9]+\\.[A-Za-z]+$\"\n# partes (en orden):\n# '[0-9]'   : s\u00f3lo numeros\n# '_'       : guion\n# '[0-9]'   : s\u00f3lo numeros\n# '.'       : un punto\n# '[A-Za-z]': s\u00f3lo letras may\u00fasculas y min\u00fasculas\n\nprint(re.findall(patron_foto, archivo1))    # ['20220623_065912.jpg']\nprint(re.findall(patron_foto, archivo2))    # []\nprint(re.findall(patron_foto, archivo3))    # []\nprint(re.findall(patron_foto, archivo4))    # []\nprint(re.findall(patron_foto, archivo5))    # []\n</code></pre>"},{"location":"modulos/regex/#patron-para-e-mails","title":"Patr\u00f3n para E-mails","text":"<pre><code>patron_email = r\"^[A-Za-z0-9_.+-]+@[A-Za-z0-9]+\\.[A-Za-z0-9-.]+$\"\n</code></pre> <p>Uso: filtrado de direcciones de correo inv\u00e1lidas</p> <pre><code>import re\n\nemail1 = \"yo@miserver.net\" \nemail2 = \"yo@miserver\" \nemail3 = \"yo_miserver.net\" \nemail4 = \"no_responder@spammers.net\" \nemail5 = \"no_responder.mi_spam@spammers.net\" \n\npatron_email = r\"^[A-Za-z0-9_.+-]+@[A-Za-z0-9]+\\.[A-Za-z0-9-.]+$\"\n\nprint(re.findall(patron_email, email1))    # ['yo@miserver.net']\nprint(re.findall(patron_email, email2))    # []\nprint(re.findall(patron_email, email3))    # []\nprint(re.findall(patron_email, email4))    # ['no_responder@spammers.net']\nprint(re.findall(patron_email, email5))    # ['no_responder.mi_spam@spammers.net']\n</code></pre>"},{"location":"modulos/regex/#referencias","title":"Referencias","text":"<p>M\u00f3dulo RE - Documentacion oficial</p> <p>Regex101: Dise\u00f1o y an\u00e1lisis interactivo</p> <p>Cheat Sheet</p> <p>RegEx 101: Gu\u00eda de supervivencia para entender y usar expresiones regulares</p>"},{"location":"modulos/sys/","title":"Sys - Par\u00e1metros y funciones del sistema","text":"<p>En este resumen se explican algunas de las funcionalidades del m\u00f3dulo sys.</p>"},{"location":"modulos/sys/#importacion","title":"Importaci\u00f3n","text":"<p>El m\u00f3dulo debe ser importado para su uso:</p> Importaci\u00f3n<pre><code>import sys\n</code></pre>"},{"location":"modulos/sys/#interprete-python-sistema-operativo","title":"Int\u00e9rprete Python, sistema operativo","text":""},{"location":"modulos/sys/#platform","title":"<code>platform</code>","text":"<p>Indica el sistema operativo detectado:</p> Identificar plataforma<pre><code>plataforma = sys.platform\n</code></pre> <p>Valores posibles:</p> Sistema operativo valor Windows <code>win32</code> Windows/Cygwin <code>cygwin</code> Linux <code>linux</code> AIX <code>aix</code> macOS <code>darwin</code>"},{"location":"modulos/sys/#platformstartwith","title":"<code>platform.startwith()</code>","text":"<p>Este subm\u00e9todo permite confinar c\u00f3digo espec\u00edfico para cada plataforma posible:</p> C\u00f3digo exclusivo por plataforma<pre><code>if sys.platform.startswith('freebsd'):\n    # rutina especifica para FreeBSD\nelif sys.platform.startswith('linux'):\n    # rutina especifica para Linux\nelif sys.platform.startswith('aix'):\n    # rutina especifica para AIX\n</code></pre>"},{"location":"modulos/sys/#version-version_info","title":"<code>version</code> , <code>version_info</code>","text":"<p>Dan informaci\u00f3n completa sobre el actual int\u00e9rprete de Python: versi\u00f3n, fecha, licencia, etc. Data de versi\u00f3n<pre><code># info de version de Python \nsys.version         # data en string\nsys.version_info    # data en tupla \n</code></pre></p>"},{"location":"modulos/sys/#platlibdir","title":"<code>platlibdir</code>","text":"<p>Devuelve las rutas a las bibliotecas del sistema: Ruta a las bibliotecas especificas<pre><code>sys.platlibdir  # ruta a las bibliotecas especificas de la plataforma\n</code></pre></p>"},{"location":"modulos/sys/#path-exec_prefix-executable-prefix","title":"<code>path</code>, <code>exec_prefix</code>, <code>executable</code>, <code>prefix</code>","text":"<p>Devuelven las rutas del entorno Python que se est\u00e1 ejecutando actualmente, el cual puede ser el global del sistema (el predefinido del sistema) o un entorno virtual: <pre><code>sys.path    # variable de entorno PYTHONPATH  actual (lista de rutas) \nsys.exec_prefix     # directorio de los archivos Python usados \nsys.executable      # ruta del ejecutable Python actual\nsys.prefix    # directorio para archivos Python independientes de la plataforma\n</code></pre></p>"},{"location":"modulos/sys/#hilos","title":"Hilos","text":""},{"location":"modulos/sys/#thread_info","title":"<code>thread_info</code>","text":"Data de hilos<pre><code># Informacion del hilo actual: tipo hilo, tipo bloqueo, etc\nsys.thread_info\n</code></pre>"},{"location":"modulos/sys/#argumentos-de-entrada","title":"Argumentos de entrada","text":"<p>Los argumentos de entrada son los valores que se asignan a continuaci\u00f3n del nombre del programa al llamarlo: Ventana de comandos<pre><code>py nombre_programa  argumento_1  argumento_2  ...\n</code></pre> En tanto que los banderines (flags) se asignan luego del nombre del programa en la ventana de comandos:</p> Banderines en ventana de comandos<pre><code>py nombre_programa -FLAG1 -FLAG2 ...\n</code></pre>"},{"location":"modulos/sys/#argv","title":"<code>argv</code>","text":"<p>Los argumentos de entrada se leen con el metodo <code>argv</code>:</p> <p>Lectura de argumentos<pre><code>argumentos = sys.argv  # 'argument values'\n\nargumentos          # (lista completa)\nargumentos[0]       # (nombre del script Python)\nargumentos[1]       # 1\u00ba argumento\nargumentos[2]       # 2\u00ba argumento\n</code></pre> Todos los argumentos recibidos se leen como variables string.</p>"},{"location":"modulos/sys/#flags","title":"<code>flags</code>","text":"<p>Los flags recibidos se leen con el objeto de solo lectura <code>flags</code>: Lectura de banderines (todos)<pre><code>sys.flags           # diccionario con todos los flags detectables\n</code></pre> Dicho objeto tiene un flag espec\u00edfico para cada opci\u00f3n de entrada posible: Lectura de banderines espec\u00edficos<pre><code># banderines especificos \nsys.flags.debug     # s\u00f3lo flag de debugueo\nsys.flags.inspect   # s\u00f3lo flag de inspeccion\nsys.flags.optimize  # s\u00f3lo flag de optimizacion\n# (etc)\n</code></pre></p> <p>REVISAR --&gt; flags insensibles</p>"},{"location":"modulos/sys/#uso-de-memoria","title":"Uso de memoria","text":""},{"location":"modulos/sys/#getsizeof","title":"<code>getsizeof()</code>","text":"<p>La funci\u00f3n <code>getsizeof()</code> mide la longitud en bytes del objeto que se le asigne como argumento, sean variables, datos, etc:</p> Bytes de datos<pre><code>texto = \"soy un texto\"\npeso_bytes = sys.getsizeof(texto) \n</code></pre>"},{"location":"modulos/sys/#getallocatedblocks","title":"<code>getallocatedblocks()</code>","text":"<p><code>getallocatedblocks()</code> indica cu\u00e1ntos bloques de memoria RAM le fueron asignados al programa actual por parte del int\u00e9rprete. Bloques de RAM<pre><code># bloques de memoria asignados al programa actual\nprint(sys.getallocatedblocks())\n</code></pre></p>"},{"location":"modulos/sys/#salida-del-programa","title":"Salida del programa","text":""},{"location":"modulos/sys/#exit","title":"<code>exit()</code>","text":"<p>La funci\u00f3n <code>exit()</code> ordena el cierre del proceso actual.  Cierre de proceso<pre><code>sys.exit() \n</code></pre> Puede asignarse un n\u00famero entero como retorno para comunicarle a los programas externos. Por ejemplo: el <code>-1</code> suele ser indicativo de error. Cierre de programa con valor de retorno<pre><code>retorno: int = -1       # uso  clasico: -1 -&gt; error del programa\nsys.exit([retorno]) \n</code></pre> Para funcionar correctamente el llamado debe hacerse desde el hilo principal del proceso actual. Esto es pertinente cuando se divide la rutina actual en varios hilos o threads para la ejecuci\u00f3n paralela del c\u00f3digo.</p>"},{"location":"modulos/sys/#is_finalizing","title":"<code>is_finalizing()</code>","text":"<p>La funci\u00f3n <code>is_finalizing()</code> verifica si el programa ya se est\u00e1 cerrando.</p> Verificaci\u00f3n de cierre<pre><code>cerrando = sys.is_finalizing()  \n</code></pre>"},{"location":"modulos/sys/#hooks-trace-profile","title":"Hooks, trace , profile","text":"<p>PENDIENTE</p>"},{"location":"modulos/sys/#referencias","title":"Referencias","text":"<p>Documentaci\u00f3n oficial</p>"},{"location":"modulos/tempfile/","title":"Tempfile - Archivos Temporales","text":"<p>Python tiene un m\u00f3dulo espec\u00edfico para manejar archivos y directorios temporales. Este m\u00f3dulo se llama temptfile, el cual debe ser importado para su uso: </p> <pre><code>import tempfile\n</code></pre>"},{"location":"modulos/tempfile/#archivos-con-nombre","title":"Archivos con nombre","text":"<p>Los archivos temporales se crean con la funci\u00f3n NamedTemporaryFile():</p> <p><pre><code># Crear un archivo temporal con nombre \narchivo_temporal = tempfile.NamedTemporaryFile( \n        mode   = \"w+b\", # modo de apertura\n        prefix = \"\",    # parte del nombre de archivo\n        suffix = \"\",    # extensi\u00f3n de archivo\n        delete = True   # si se cierra el archivo se elimina el archivo\n        )\n</code></pre> Esta funcion crea un descriptor de archivo , el cual no tiene contenido. Los par\u00e1metros mode, delete y prefix son opcionales y se pueden omitir. En cambio suffix puede ser necesario para especificar el formato de los datos mediante la extensi\u00f3n de archivo.</p> <p>Para conocer el nombre de archivo asignado  y poder interactuar con \u00e9l se usa el m\u00e9todo  .name:</p> <p><pre><code>nombre_archivo = archivo_temporal.name\n</code></pre> Cabe se\u00f1alar que el nombre de archivo incluye caracteres aleatorios entre lso campos prefix y suffix, por ello \u00e9stos no son obligatorios. El archivo no puede ser renombrado una vez creado.</p> <p>La asignaci\u00f3n de datos se realiza con el m\u00e9todo .write(): <pre><code>nombre_archivo.write( contenido)\n</code></pre></p> <p>El archivo temporal se elimina tan pronto se produzca el cierre del archivo temporal. Para alterar este comportamiento existe el par\u00e1metro delete:</p> <p><pre><code># Crear un archivo temporal con nombre \narchivo_temporal = tempfile.NamedTemporaryFile(delete = False)\n</code></pre> En este caso el archivo temporal seguir\u00e1 existiendo hasta su eliminaci\u00f3n por el sistema operativo o hasta el reinicio del sistema. Para programar la eliminaci\u00f3n del archivo se puede recurrir a la funcion unlink() del m\u00f3dulo os: <pre><code>import os\n\nos.unlink(archivo_temporal.name)\n</code></pre></p> <p>Ejemplo aplicado: guardar un archivo de imagen PNG como archivo temporal</p> <ol> <li> <p>Creaci\u00f3n de archivo temporal</p> <pre><code># Crear un archivo temporal con nombre \narchivo_temporal = tempfile.NamedTemporaryFile( prefix=\"\", suffix=\".png\")\n</code></pre> </li> <li> <p>Asignaci\u00f3n de datos</p> <p>A. Uso de la funci\u00f3n open() para leer data binaria:</p> <pre><code># apertura archivo en modo lectura binaria\narchivo_disco = open('imagen.png', \"rb\")\ndata = archivo_disco.read()\n\n# Asignacion de data al archivo\narchivo_temporal.write( data )\narchivo_temporal.seek(0)\n</code></pre> <p>B. Delegar la transferencia de datos a bibliotecas espec\u00edficas. Ejemplo: OpenCV <pre><code>import cv2 as cv    # importacion OpenCV\n\nimg = cv.imread('imagen.png') #lectura desde disco\ncv.imwrite(archivo_temporal.name, img) # escritura en RAM\n</code></pre> Importante: Para usar esta opci\u00f3n se necesita especificar correctamente el par\u00e1metro suffix al crear el archivo temporal</p> </li> </ol>"},{"location":"modulos/tempfile/#ubicacion-de-archivos-temporales-en-el-sistema","title":"Ubicacion de archivos temporales en el sistema","text":"<p>En GNU/Linux los archivos temporales se encuentran dentro del directorio /tmp. \u00c9stos pueden listarse en consola con dos comandos:</p> <pre><code>cd  /tmp\nls\n</code></pre> <p>En el caso de Windows los archivos temporales sol\u00edan encontrarse en la carpeta 'Temp' dentro de la carpeta de Windows. La lista desde consola se hace con:</p> <p><pre><code>cd 'C:\\Windows\\Temp'\nls\n</code></pre> Windows 10 movi\u00f3 la ruta de los archivos temporales a la carpeta '\\AppData\\Local' dentro de la carpeta del usuario actual:  <pre><code>C:\\Users\\nombre_usuario\\AppData\\Local\\Temp\n</code></pre></p>"},{"location":"modulos/tempfile/#enlaces-utiles","title":"Enlaces \u00fatiles:","text":"<p>Documentaci\u00f3n oficial - Modulo Tempfile</p> <p>DelfStack - C\u00f3mo crear archivos temporales en Python</p> <p>Aprender Linux - directorio TMP de Linux todo lo que necesita saber</p>"},{"location":"modulos/unittest/","title":"UnitTest - Tests unitarios","text":""},{"location":"modulos/unittest/#importacion","title":"Importaci\u00f3n","text":"<pre><code>import unittest\n</code></pre>"},{"location":"modulos/unittest/#definir-tests","title":"Definir tests","text":"<p>Para evaluar la funci\u00f3n se crea una clase hija de la clase <code>TestCase</code> y se le asigna un m\u00e9todo por cada test unitario que se requiera hacer. </p> <p>La clase <code>TestCase</code> proporciona a sus clases hijas una serie de m\u00e9todos predefinidos para verificar el buen funcionamiento de las funciones: valores y tipos de retorno correctos, excepciones disparadas ante ciertas condiciones, etc.</p> <p>El formato b\u00e1sico es el siguiente:</p> Sintaxis de test<pre><code># clase para preparar los tests\nclass TestComponente(unittest.TestCase):\n\n\n    def test_primero(self):\n        pass\n\n\n    def test_segundo(self):\n        pass\n</code></pre> <p>Nombres de tests</p> <p>Los nombres de m\u00e9todos que implementan los test unitarios siempre deben comenzar con la palabra <code>test</code>, de otra manera no ser\u00e1n ejecutados al final. </p>"},{"location":"modulos/unittest/#test-de-funciones","title":"Test de funciones","text":"<p>Sup\u00f3ngase que se busca poner a prueba una funci\u00f3n como la que sigue:</p> Funcion bajo prueba<pre><code># funcion bajo prueba\ndef suma(a,b):\n    # Excepciones ante tipos de entrada incorrectos \n    if not  isinstance(a, (int, float)) or not isinstance(b, (int, float)):\n        raise ValueError(\"Los argumentos deben ser enteros o decimales\")\n    # retorno num\u00e9rico\n    return a + b\n</code></pre> <p>En este caso interesa verificar que algunas sumas de ejemplo dan valores correctos y que ante tipos de entrada incorrectos (textos, booleanos, etc ) se produce la excepci\u00f3n <code>ValueError</code>. Entonces se crea una clase con dos tests para verificar cada comportamiento por separado</p> <pre><code>class TestSuma(unittest.TestCase):\n\n    # Primer test: resultados correctos \n    def test_suma(self):\n        self.assertEqual(suma(5, 7), 12)\n        self.assertEqual(suma(-3, -9), -12)\n\n\n    # Segundo test: excepciones disparadas ante tipos de entrada err\u00f3neas\n    def test_excepciones(self):\n        with self.assertRaises(ValueError):\n            suma(\"5\", 7)\n        with self.assertRaises(ValueError):\n            suma(5, \"7\")\n        with self.assertRaises(ValueError):\n            suma(None, 7)\n</code></pre>"},{"location":"modulos/unittest/#test-de-datos","title":"Test de datos","text":"<p>Sup\u00f3ngase que se busca verificar la estructura y valores de un dicionario:</p> <pre><code>diccionario = { \n    \"id\": 31416,\n    \"user\" : \"yo\"\n    }\n</code></pre> <p>En este caso la clase requiere del m\u00e9todo de inicializaci\u00f3n <code>setUp()</code>, donde se agrega una referencia al diccionario bajo prueba. Esto permite que los tests puedan acceder a la data desde adentro del test.</p> <pre><code>class TestDiccionario(unittest.TestCase):\n\n    # Inicializacion\n    def setUp(self)-&gt;None:\n        # cargar data de entrada\n        self.data = diccionario\n\n    # primer test\n    def test_campo_existente(self):\n        # test de claves\n        self.assertIn(\"id\"  , self.data)\n        self.assertIn(\"user\", self.data)\n        # self.assertIn(\"nombre\", self.data)    # MAL: campo inexistente\n\n    # segundo test\n    def test_data_correcta(self):\n        # test de valores\n        self.assertEqual(self.data[\"id\"], 31416)\n        self.assertEqual(self.data[\"user\"], \"yo\")\n        # test de tipos\n        self.assertIsInstance(self.data[\"id\"],  int)\n        self.assertIsInstance(self.data[\"user\"], str)\n</code></pre> <p>Esta forma permite poner a prueba clases</p>"},{"location":"modulos/unittest/#ejecucion","title":"Ejecuci\u00f3n","text":"<p>La ejecuci\u00f3n de todos los tests definidos se realiza con la funci\u00f3n <code>main()</code>:</p> Ejecucion test<pre><code>unittest.main()\n</code></pre> <p>Por defecto la ejecuci\u00f3n del programa se interrumpe al ejecutar esta funci\u00f3n. Para ejecutar el test \u00fanicamente cuando la rutina se ejecute como rutina principal se agrega el condicional:</p> Ejecucion test - desde main()<pre><code>if __name__ == '__main__':\n    unittest.main()\n</code></pre> <p>Si se desea continuar la ejecuci\u00f3n de la rutina tras los test se hace el argumento <code>exit=False</code> :</p> Ejecucion test - Sin interrupci\u00f3n<pre><code>unittest.main(exit=False)\n\n# Codigo adicional\nprint(\"Test exitoso\")\n</code></pre>"},{"location":"modulos/unittest/#decoradores","title":"Decoradores","text":"<p>El m\u00f3dulo <code>unittest</code> proporciona decoradores para saltear tests o para omitir errores esperables. Los decoradores implementados en el m\u00f3dulo son los siguientes:</p> Decorador Uso <code>skip( razon )</code> Omite el test <code>skipIf( condicion , razon )</code> Omite el test s\u00f3lo si se cumple cierta condicion <code>skipUnless( condicion, razon )</code> Omite el test a menos que se cumpla cierta condicion <code>expectedFailure</code> Verifica que el error se produzca, de otro modo falla el test <p>Los decoradores del m\u00f3dulo se usan agreg\u00e1ndolos justo arriba de la definici\u00f3n del test elegido.</p> <p>Por ejemplo, si en el test de la funci\u00f3n <code>suma()</code> hay error, con el decorador <code>expectedFailure</code> se verifica que el error siga existiendo:</p> <pre><code>class TestSuma(unittest.TestCase):\n\n    @unittest.expectedFailure\n    def test_suma(self):\n        # tests con resultados correctos \n        self.assertEqual(suma( 5,  7),  12)\n        self.assertEqual(suma(-3, -9), -12)\n        self.assertEqual(suma( 2,  3),  -6)        # Error de resultado\n</code></pre> <p>Da como resultado el mensaje:</p> <pre><code>OK (expected failures=1)\n</code></pre>"},{"location":"modulos/unittest/#metodos-de-test","title":"M\u00e9todos de test","text":""},{"location":"modulos/unittest/#uso-general","title":"Uso general","text":"M\u00e9todo Expresion equivalente <code>assertEqual(a, b)</code> <code>a == b</code> <code>assertNotEqual(a, b)</code> <code>a != b</code> <code>assertTrue(x)</code> <code>bool(x) is True</code> <code>assertFalse(x)</code> <code>bool(x) is False</code> <code>assertIs(a, b)</code> <code>a is b</code> <code>assertIsNot(a, b)</code> <code>a is not b</code> <code>assertIsNone(x)</code> <code>x is None</code> <code>assertIsNotNone(x)</code> <code>x is not None</code> <code>assertIn(a, b)</code> <code>a in b</code> <code>assertNotIn(a, b)</code> <code>a not in b</code>"},{"location":"modulos/unittest/#numeros","title":"N\u00fameros","text":"M\u00e9todo Expresion equivalente Explicaci\u00f3n <code>assertAlmostEqual(a, b)</code> <code>round(a-b, 7) == 0</code> Numeros (redondeados a 7 d\u00edgitos) iguales <code>assertNotAlmostEqual(a, b)</code> <code>round(a-b, 7) != 0</code> Numeros (redondeados a 7 d\u00edgitos) distintos <code>assertGreater(a, b)</code> <code>a &gt; b</code> <code>assertGreaterEqual(a, b)</code> <code>a &gt;= b</code> <code>assertLess(a, b)</code> <code>a &lt; b</code> <code>assertLessEqual(a, b)</code> <code>a &lt;= b</code>"},{"location":"modulos/unittest/#secuencias","title":"Secuencias","text":"M\u00e9todo Explicaci\u00f3n <code>assertRegex(s, r)</code> Patr\u00f3n encontrado en secuencia <code>assertNotRegex(s, r)</code> Patr\u00f3n no encontrado en secuencia"},{"location":"modulos/unittest/#datos-estandar","title":"Datos est\u00e1ndar","text":"M\u00e9todo Significado <code>assertMultiLineEqual(a, b)</code> strings iguales <code>assertSequenceEqual(a, b)</code> secuencias iguales <code>assertListEqual(a, b)</code> listas iguales <code>assertTupleEqual(a, b)</code> tuplas iguales <code>assertSetEqual(a, b)</code> conjuntos iguales <code>assertDictEqual(a, b)</code> diccionarios iguales <code>assertCountEqual(a, b)</code> mismos elementos en igual n\u00famero, sin importar el orden"},{"location":"modulos/unittest/#clases","title":"Clases","text":"M\u00e9todo Expresion equivalente <code>assertIsInstance(a, b)</code> <code>isinstance(a, b)</code> <code>assertNotIsInstance(a, b)</code> <code>not isinstance(a, b)</code>"},{"location":"modulos/unittest/#excepciones-warnings-logs","title":"Excepciones, warnings, logs","text":"M\u00e9todo Explicaci\u00f3n <code>assertRaises(excepcion, funcion, *args, **kargs)</code> La funci\u00f3n dispara la excepci\u00f3n <code>assertRaisesRegex(excepcion, patron, funcion, *args, **kargs)</code> La funci\u00f3n dispara la excepci\u00f3n y el mensaje coincide con el patron <code>assertWarns(warning, funcion, *args, **kargs)</code> La funci\u00f3n dispara la advertencia <code>assertWarnsRegex(warning, patron, funcion, *args, **kargs)</code> La funci\u00f3n dispara la advertencia y el mensaje coincide con el patr\u00f3n <code>assertLogs(logger, nivel)</code> El bloque <code>with</code> produce el log con nivel de al menos  el minimo indicado <code>assertNoLogs(logger, nivel)</code> El bloque <code>with</code> produce un log que no cumple con el nivel minimo indicado"},{"location":"modulos/unittest/#referencias","title":"Referencias","text":"<p>Documentacion oficial - Unittest</p> <p>MoureDev TV - Ruta de estudio programaci\u00f3n | 13 - TESTING</p>"},{"location":"paquetes/ffmpeg/","title":"ffmpeg-python","text":"<p>ffmpeg-python es un wrapper (un conector) para interactuar con el utilitario FFMPEG, el cual permite manipular video, audio e im\u00e1genes.</p> <p>GitHub del proyecto</p> <p>Documentaci\u00f3n del proyecto</p>"},{"location":"paquetes/ffmpeg/#instalar","title":"Instalar","text":"<p>Se necesita instalar el utilitario en el sistema operativo:</p> <p>Descargar FFmpeg</p> <p>El wrapper (conector) para Python se instala mediante PIP <pre><code>pip install ffmpeg-python\n</code></pre></p>"},{"location":"paquetes/ffmpeg/#importar","title":"Importar","text":"<pre><code>import ffmpeg\n</code></pre>"},{"location":"paquetes/ffmpeg/#ejemplos-de-uso","title":"Ejemplos de uso","text":""},{"location":"paquetes/ffmpeg/#cortar-clip-trim","title":"Cortar clip (trim)","text":"<pre><code># REVISAR: IMAGEN CONGELADA AL COMIENZO\nimport ffmpeg\n\nruta_entrada = \"demo.mp4\"\nruta_salida = \"clip.mp4\"\n\nvideo = ffmpeg.input(ruta_entrada)\nvideo = video.trim(start=20, duration=5)  # MAL\nvideo =  ffmpeg.output(video, ruta_salida) \n\nffmpeg.run(video)\n</code></pre> <p>Otra alternativa: <pre><code># ...\n# tiempo en segundos\ninicio = 10\nfin = 20\n\nvideo = ffmpeg.input(ruta_entrada, ss=inicio, to=fin) \nvideo =  ffmpeg.output(video, ruta_salida) \nffmpeg.run(video)\n</code></pre> ss es el tiempo de arranque, en tanto que to es el tiempo de parada.</p> <p>Notaci\u00f3n reducida:</p> <pre><code># ...\n# tiempo en segundos\ninicio = 10 \nfin = 20\n(\n    ffmpeg.input(ruta_entrada,ss=inicio, to=fin) \n    .output( ruta_salida) \n    .run()\n)\n</code></pre>"},{"location":"paquetes/ffmpeg/#dimensiones","title":"Dimensiones","text":"<pre><code>import ffmpeg\n\nruta_entrada = \"demo.mp4\"\n\nprobe = ffmpeg.probe(ruta_entrada)\n\nvideo = next(\n    (stream for stream in probe[\"streams\"] if stream[\"codec_type\"] == \"video\"), None\n)\n\nancho = int( video[\"width\"])\nalto = int(video[\"height\"])\n</code></pre>"},{"location":"paquetes/ffmpeg/#miniatura","title":"Miniatura","text":"<pre><code>import ffmpeg\n\nruta_entrada = \"demo.mp4\"\n\n# Ejemplo 1: PNG con anchura 500 px\nsalida_png = \"miniatura.png\"\n\ninstante = 4  # segundo 4\nancho = 500  # 500 px\nalto = -1  # automatico \n\nvideo = ffmpeg.input(ruta_entrada, ss=instante)\nvideo = video.filter(\"scale\", ancho, alto) # (mantiene proporcion)\nvideo = ffmpeg.output(video, salida_png , vframes=1)\n\n# orden de ejecucion\nffmpeg.run(video)\n</code></pre>"},{"location":"paquetes/ffmpeg/#invertir-imagen-flip","title":"Invertir imagen (flip)","text":"<pre><code>import ffmpeg\n\nruta_entrada = \"demo.mp4\"\nsalida_horizontal = \"horizontal.mp4\"\nsalida_vertical = \"vertical.mp4\"\n</code></pre> <p>Volteo horizontal</p> <pre><code># 'hflip': voltea de derecha a izquierda\nvideo = ffmpeg.input(ruta_entrada)\nvideo = ffmpeg.hflip(video)\nvideo = ffmpeg.output(video, salida_horizontal)\n# orden de ejecucion\nffmpeg.run(video)\n</code></pre> <p>Volteo vertical:</p> <pre><code># 'vflip' : voltea de arriba a abajo\nvideo = ffmpeg.input(ruta_entrada)\nvideo = ffmpeg.vflip(video)\nvideo = ffmpeg.output(video, salida_vertical)\n# orden de ejecucion\nffmpeg.run(video)\n</code></pre>"},{"location":"paquetes/ffmpeg/#convertir-video","title":"Convertir Video","text":"<pre><code>import ffmpeg\n\nruta_entrada = \"demo.mp4\"\nruta_salida  = \"demo.wmv\"\n\n(\n    ffmpeg.input(ruta_entrada)\n    .output(ruta_salida)\n    .run()\n)\n</code></pre>"},{"location":"paquetes/ffmpeg/#extraer-audio","title":"Extraer Audio","text":"<pre><code>import ffmpeg\n\nruta_entrada = \"demo.mp4\"\naudio_salida = \"audio.mp3\"\n\n(\n    ffmpeg.input(ruta_entrada)\n    .output(audio_salida)\n    # .output(audio_salida , acodec='libshine') # codec personalizado\n    .run()\n)\n</code></pre>"},{"location":"paquetes/ffmpeg/#extraer-frames-imagenes-del-video","title":"Extraer frames (imagenes del video)","text":"<ul> <li>N\u00famero fijo de frames, desde el comienzo del video:</li> </ul> <pre><code>import ffmpeg\n\nruta_entrada = \"demo.mp4\"\nframes_salida = \"frame_%d.png\" # formato para nombrar los frames de salida\n\nnro_frames = 500 # primeros 500 frames de video\n\n(\n    ffmpeg.input(ruta_entrada)\n    .output(frames_salida , vframes=nro_frames)      \n    .run()\n)\n</code></pre> <ul> <li>Tasa de frames por segundo a elecci\u00f3n, desde el comienzo:</li> </ul> <pre><code>import ffmpeg\n\nruta_entrada  = \"demo.mp4\"\nframes_salida = \"frame_%d.png\" # formato para nombrar los frames de salida\n\nfps = 0.1  # 1 frame cada 10 segundos\n\n(\n    ffmpeg.input(ruta_entrada)\n    .output(frames_salida , vf=f'fps={fps}')\n    .run()\n)\n</code></pre>"},{"location":"paquetes/ffmpeg/#thumbnails","title":"Thumbnails","text":"<ul> <li>Una captura, tiempo elegido por usuario:</li> </ul> <pre><code>import ffmpeg\n\nruta_entrada  = \"demo.mp4\"\nthumbnail_salida = \"thumbnail.png\" \n## instante fijo  \n(\n    ffmpeg.input(ruta_entrada, ss=\"00:00:15\")\n    .output(thumbnail_salida, vframes=1)\n    .run()\n)\n</code></pre> <ul> <li>Una captura, elegida autom\u00e1ticamente entre los 100 primeros frames (valor predefinido):</li> </ul> <pre><code>import ffmpeg\n\nruta_entrada  = \"demo.mp4\"\nthumbnail_salida = \"thumbnail.png\" \n# ventana seleccion 100 muestras (default)   \n(\n    ffmpeg.input(ruta_entrada)\n    .filter('thumbnail')\n    .output(thumbnail_salida, vframes=1)\n    .run()\n)\n</code></pre> <ul> <li>Una captura, elegida autom\u00e1ticamente entre los N primeros frames:</li> </ul> <pre><code>import ffmpeg\n\nruta_entrada  = \"demo.mp4\"\nthumbnail_salida = \"thumbnail.png\" \nnro_frames = 500\n# ventana seleccion 500 muestras  \n(\n    ffmpeg.input(ruta_entrada)\n    .filter('thumbnail', n=nro_frames)\n    .output(thumbnail_salida, vframes=1)\n    .run()\n)\n</code></pre>"},{"location":"paquetes/ffmpeg/#referencias","title":"Referencias","text":"<p>DelfStack - FFmpeg en script Python</p> <p>Bannerbear - How to Use FFMpeg in Python (with Examples)</p>"},{"location":"paquetes/numba/","title":"Numba - Optimizacion con Machine Learning","text":"<p>Numba permite compilar funciones de Python en tiempo de ejecuci\u00f3n con ayuda de algoritmos de Machine Learning. Esto suele ayudar a mejorar los tiempos de ejecucion de la funci\u00f3n.</p>"},{"location":"paquetes/numba/#instalacion-e-importacion","title":"Instalacion e importaci\u00f3n","text":"<p>El paquete numba se instala con PIP</p> <p>Instalaci\u00f3n<pre><code>pip install numba\n</code></pre> La importaci\u00f3n se requiere para su uso: Importaci\u00f3n<pre><code>import numba\n</code></pre></p>"},{"location":"paquetes/numba/#compilacion","title":"Compilacion","text":"<p>La compilacion se ordena de forma gen\u00e9rica con el decorador <code>@jit</code>:</p> <pre><code>import numba\n\n# funcion compilada\n@numba.jit\ndef funcion( arg):\n    # rutina\n    return \n</code></pre> <p>Sintaxis alternativa:  <pre><code>from numba import jit\n\n# funcion compilada\n@jit\ndef funcion( arg):\n    # rutina\n    return \n</code></pre></p> <p>Ejemplo aplicado: b\u00fasqueda de numeros primos. Se crean dos funciones iguales , pero una lleva el decorador jit y la otra no.</p> <p>Funci\u00f3n interpretada pura: Funci\u00f3n interpretada pura<pre><code>def numeros_primos(numero_maximo):\n    \"\"\"Devuelve una lista con los numeros primos encontrados con valor menor al indicado.\"\"\"\"\"\n    #esta funcion verifica qu\u00e9 numeros son primos descartando los numeros divisibles por enteros previos\n    #los numeros primos se guardan en una lista\n    primos = [2]\n    #se prueba cada numero candidato, uno a uno\n    #s\u00f3lo se verifican numeros impares: mejora casi imperceptible\n    for valor in range(3,numero_maximo+1,2):\n        divisible = False\n        # s\u00f3lo se divide por numeros primos ya encontrados \n        # los numeros no primos son redundantes\n        for indice in range(0,len(primos)):\n            divisor = primos[indice]\n            if valor % divisor == 0:\n                divisible = True\n                break\n        #si no es divisible se cuenta como primo\n        if divisible == False:\n            primos.append(valor)\n    return primos     \n</code></pre></p> <p>Funcion con compilacion:</p> Funci\u00f3n con compilacion - @jit<pre><code>@jit    # decorador de Numba\ndef numeros_primos_compilado(numero_maximo):\n    \"\"\"Devuelve una lista con los numeros primos encontrados con valor menor al indicado.\"\"\"\"\"\n    #esta funcion verifica qu\u00e9 numeros son primos descartando los numeros divisibles por enteros previos\n    #los numeros primos se guardan en una lista\n    primos = [2]\n    #se prueba cada numero candidato, uno a uno\n    #s\u00f3lo se verifican numeros impares: mejora casi imperceptible\n    for valor in range(3,numero_maximo+1,2):\n        divisible = False\n        # s\u00f3lo se divide por numeros primos ya encontrados \n        # los numeros no primos son redundantes\n        for indice in range(0,len(primos)):\n            divisor = primos[indice]\n            if valor % divisor == 0:\n                divisible = True\n                break\n        #si no es divisible se cuenta como primo\n        if divisible == False:\n            primos.append(valor)\n    return primos     \n</code></pre> <p>Se cre\u00f3 una rutina que ejecuta recursivamente estas funciones. Al requerir la b\u00fasqueda de numeros primos por debajo de 10 mil: </p> <p>Uso rutina - 10k n\u00fameros<pre><code>py primos_numba.py 10000\n</code></pre> se obtuvieron tiempos de ejecuci\u00f3n como estos:</p> Interpretado Compilado 92 mseg 560 mseg 90 mseg 4 mseg 89 mseg 4 mseg <p>La compilaci\u00f3n introdujo una penalizaci\u00f3n notable en el tiempo de la primera ejecuci\u00f3n; sin embargo a partir de la segunda ejecuci\u00f3n el tiempo se redujo m\u00e1s de veinte veces. </p> <p>Al repetir la b\u00fasqueda con tope en 40 mil:</p> <p>Uso rutina - 40k n\u00fameros<pre><code>py primos_numba.py 40000\n</code></pre> Los nuevos tiempos fueron los siguientes:</p> Interpretado Compilado 1162 mseg 660 mseg 1160 mseg 44 mseg 1156 mseg 44 mseg <p>En este caso de mayor demanda computacional se obtiene una mejora para todos los ciclos.</p> <p>Por tanto, debe analizarse en cada caso si es buena idea o no introducir la compilaci\u00f3n.</p>"},{"location":"paquetes/psutil/","title":"Psutil - Monitoreo del sistema","text":"<p>Psutil ayuda a monitorear los par\u00e1metros de funcionamiento del sistema operativo y de sus procesos, tales como el uso de memoria, frecuencia de trabajo, uso de redes, sensores internos, etc. </p>"},{"location":"paquetes/psutil/#primeros-pasos","title":"Primeros pasos","text":"<p>El paquete se instala desde el gestor PIP.</p> Instalaci\u00f3n<pre><code>pip install psutil\n</code></pre> <p>El nombre de m\u00f3dulo coincide con el del paquete , por ello se lo importa directamente:</p> importacion<pre><code>include psutil\n</code></pre>"},{"location":"paquetes/psutil/#parametros-de-sistema","title":"Par\u00e1metros de Sistema","text":"<p>Para consultar par\u00e1metros del sistema psutil incluye un juego de funciones</p>"},{"location":"paquetes/psutil/#cpu","title":"CPU","text":""},{"location":"paquetes/psutil/#frecuencias","title":"frecuencias","text":"<p>frecuencia procesadores<pre><code>frecuencia_procesadores = psutil.cpu_freq() \n</code></pre> Valores disponibles:</p> Valores disponibles campo valor current frecuencia de trabajo actual (en MHz) min frecuencia de trabajo m\u00ednima (en MHz) max frecuencia de trabajo m\u00e1xima (en MHz) <p>Caso Linux, FreeBSD: pueden monitorearse todos los procesadores:</p> frecuencias- todos los procesadores<pre><code>lista_frecuencias = psutil.cpu_freq(percpu=True) \n</code></pre>"},{"location":"paquetes/psutil/#nucleos","title":"nucleos","text":"<p>Cuenta cuantos n\u00facleos (cores) dispone el CPU:</p> n\u00ba nucleos<pre><code>nucleos_logicos = psutil.cpu_count()\nnucleos_fisicos = psutil.cpu_count(logical=False)\n</code></pre> <p>Hint: n\u00facleos f\u00edsicos y l\u00f3gicos</p> <p>La relaci\u00f3n entre n\u00facleos f\u00edsicos y n\u00facleos l\u00f3gicos es: <pre><code>nucleos_logicos = nucleos_fisicos * threads_simultaneos \n</code></pre></p> <p>Ejemplo: un CPU con 2 n\u00facleos f\u00edsicos e 'HiperThreading' de 2 hilos simult\u00e1neos por core da 4 n\u00facleos l\u00f3gicos.</p>"},{"location":"paquetes/psutil/#cpu_percent","title":"cpu_percent()","text":"<p>Permite calcular el porcentaje de uso promedio de todos los n\u00facleos del CPU :</p> porcentaje CPU<pre><code># porcentaje de exigencia del CPU\nporcentaje_total = psutil.cpu_percent(\n    interval=None,                      # tiempo de referencia\n    percpu=False                        #  resultado en lista de porcentajes , uno por *core* \n)  \n</code></pre> <p>Si no se indica un valor num\u00e9rico para interval se toma de referencia la anterior llamada del m\u00e9todo o en su defecto la importaci\u00f3n del m\u00f3dulo. Es conveniente que entre ambas llamadas hayan pasado al menos 0.1 segundos para mejor precisi\u00f3n.</p> <p>Ejemplo: demanda de CPU de una rutina completa</p> Porcentaje de CPU<pre><code>#punto de referencia\npsutil.cpu_percent()  # retorna '0.0'-&gt; IGNORAR\n# espera\nimport time\ntime.sleep(1)\n# medicion\nporcentaje = psutil.cpu_percent()               # promedio\nporcentajes = psutil.cpu_percent(percpu=True)   # por unidad\n</code></pre>"},{"location":"paquetes/psutil/#cpu_times","title":"cpu_times()","text":"<p>Calcula los tiempos acumulados de procesamiento de cada n\u00facleo l\u00f3gico.</p> Tiempo procesamiento<pre><code>data_tiempos = psutil.cpu_times()     # informacion de tiempo de procesamiento en segundos\n</code></pre> Campos m\u00e1s habituales campo valor user tiempo usado en modo usuario (segundos) system tiempo usado en modo kernel (segundos) <p>M\u00e1s informacion sobre cpu_times(): sitio oficial</p>"},{"location":"paquetes/psutil/#procesos","title":"Procesos","text":""},{"location":"paquetes/psutil/#listado-y-verificacion","title":"listado y verificacion","text":"<pre><code>lista_pids = psutil.pids()  # todos los PIDS activos encontrados\nexiste_proceso = psutil.pid_exists(pid) # verifica actividad\n</code></pre>"},{"location":"paquetes/psutil/#espera-y-eventos-al-cierre","title":"espera y eventos al cierre","text":"<pre><code># Espera al cierre de procesos indicados\npsutil.wait_procs(\n    lista_pids,         # lista de numeros de IDs\n    timeout=None,       # tiempo de espera m\u00e1ximo\n    callback=None       # manejador asignable -&gt; se dispara con cada cierre\n    )\n</code></pre>"},{"location":"paquetes/psutil/#memoria-ram","title":"Memoria RAM","text":"<pre><code>data_ram = psutil.virtual_memory()\n</code></pre> Campos principales: campo valor total memoria RAM total (en bytes) available memoria RAM actualmente disponible (en bytes) percent porcentaje de memoria usado"},{"location":"paquetes/psutil/#memoria-swap","title":"Memoria SWAP","text":"<pre><code>data_swap = psutil.swap_memory()\n</code></pre> Campos principales: campo valor total memoria swap total (en bytes) used memoria swap actualmente usado free memoria swap libre percent porcentaje de memoria swap usado sin data escrita en disco (acumulativa) sout data leida en disco (acumulativa)"},{"location":"paquetes/psutil/#discos","title":"Discos","text":""},{"location":"paquetes/psutil/#particiones","title":"particiones","text":"<pre><code>particiones_f\u00edsicas = psutil.disk_partitions() # lista de particiones\n\nfor particion in particiones:\n    print(particion)\n</code></pre> Contenido de listas: campo valor device ruta del dispositivo: 'C:\\', '/dev/hda1', etc mountpoint ruta montada_ '/', '/home', 'D:\\', etc fstype formato: NTFS, FAT, ext4, etc opt informacion extra (dependiente del SO)"},{"location":"paquetes/psutil/#espacio-en-disco","title":"espacio en disco","text":"<pre><code>uso_disco = psutil.disk_usage(ruta)\n</code></pre> Contenido: campo valor used espacio usado (en bytes) free espacio libre (en bytes) <p>Ejemplo: estad\u00edsticas del disco o particion</p> espacio en disco eb GiB<pre><code>ruta = \"/\"\nuso_disco = psutil.disk_usage(ruta)\nespacio_usado = uso_disco.used    # espacio usado (en bytes)\nespacio_libre = uso_disco.free    # espacio libre (en bytes)\nprint(f\"Ruta: {ruta}\")\nprint(f\"Espacio usado: {espacio_usado / (1000**3):.4} GiB\") \nprint(f\"Espacio libre: {espacio_libre / (1000**3):.4} GiB\") \n</code></pre>"},{"location":"paquetes/psutil/#estadisticas-de-lecturaescritura","title":"estadisticas de lectura/escritura","text":"<p>Las estad\u00edsticas de lectura y escritura se calculan con la funci\u00f3n disk_io_counters():</p> <pre><code>data_io = psutil.disk_io_counters()\n</code></pre> Campos m\u00e1s importantes campo valor read_count N\u00ba operaciones lectura write_count N\u00ba operaciones escritura read_bytes data total leida (en bytes) write_bytes data total escrita (en bytes) <p>La informaci\u00f3n puede fragmentarse por partici\u00f3n con ayuda del argumento perdisk:</p> <pre><code>lista_data_io = psutil.disk_io_counters(perdisk=True)\n</code></pre>"},{"location":"paquetes/psutil/#uso-de-red","title":"Uso de red","text":""},{"location":"paquetes/psutil/#estadisticas-globales","title":"estadisticas globales","text":"<p>La informaci\u00f3n se condensa con la funci\u00f3n net_io_counters():</p> <pre><code>io_global = psutil.net_io_counters()\n</code></pre> <p>Datos disponibles:</p> Campos disponibles campo valor bytes_sent bytes enviados bytes_recv bytes recibidos packets_sent paquetes enviados packets_recv paquetes recibidos errin errores enviados errout errores recibidos dropin paquetes descartados enviados dropout paquetes descartados recibidos <p>Ejemplo de uso: medicion del uso de datos por red</p> Data de red en MB<pre><code># Uso de red\nio_global = psutil.net_io_counters()\nenviados = io_global.bytes_sent\nrecibidos = io_global.bytes_recv\nprint(\"Uso de red\")\nprint(f\"Datos enviados: {enviados/(1024**2):.4} MB\") \nprint(f\"Datos recibidos: {recibidos/(1024**2):.4} MB\")\n</code></pre>"},{"location":"paquetes/psutil/#configuracion-local","title":"configuracion local","text":"<p>Data de direcion MAC, IP's, etc: funci\u00f3n net_if_addrs()</p> <pre><code>data_equipo = psutil.net_if_addrs()   \n</code></pre>"},{"location":"paquetes/psutil/#canales","title":"canales","text":"<p>Estado de conexiones, velocidades de transmisi\u00f3n, tipos de transmisi\u00f3n, etc: funci\u00f3n net_if_stats() </p> <pre><code>data_canales = psutil.net_if_stats()  \n</code></pre>"},{"location":"paquetes/psutil/#estadisticas-por-canal","title":"estad\u00edsticas (por canal)","text":"<p>Informaci\u00f3n de conexiones de socket local y remoto: IP's, puertos, tipo de socket, etc.</p> <pre><code>lista_conexiones = psutil.net_if_stats()  \n</code></pre>"},{"location":"paquetes/psutil/#sensores-y-ventiladores","title":"Sensores y ventiladores","text":"Temperaturas<pre><code># temperaturas del sistema en grados Celsius salvo indicacion contraria\ndata_temperatura = psutil.sensors_temperatures(fahrenheit=False)  \n</code></pre> Ventiladores<pre><code># velocidad de ventiladores en RPM\ndata_ventiladores = psutil.sensors_fans()    # '{}' si no hay informaci\u00f3n\n</code></pre> Bater\u00eda<pre><code>data_bateria = psutil.sensors_battery() # 'None' si no se detecta\n</code></pre>"},{"location":"paquetes/psutil/#procesos-especificos","title":"Procesos espec\u00edficos","text":"<p>La data de proceso se gestiona con la clase Process: <pre><code>proceso  = psutil.Process()     # proceso actual\nproceso  = psutil.Process(pid)  # PID especificado\n</code></pre> Esta clase asigna una serie de m\u00e9todos para obtener la inforncion relevante del proceso: uso de memoria, procesamiento de CPU, conexiones IP, etc.</p>"},{"location":"paquetes/psutil/#estadisticas-de-memoria","title":"Estadisticas de memoria","text":"<p>El m\u00e9todo memory_info() da informaci\u00f3n sobre el consumo de memoria del proceso actua:</p> <pre><code>info_memoria = proceso.memory_info()\n</code></pre> <p>Campos m\u00e1s comunes:</p> Campos m\u00e1s habituales campo informaci\u00f3n rss uso de RAM en bytes vms uso de SWAP en bytes <p>Ejemplo de uso: uso de memoria por el proceso actual</p> <pre><code>proceso  = psutil.Process() \ninfo_memoria = proceso.memory_info()\ninfo_memoria.rss    # uso de RAM en bytes\ninfo_memoria.vms    # uso de SWAP en bytes\n</code></pre> <p>Estos campos son comunes para todos los sistemas operativos implementados. Los otros campos de informaci\u00f3n tienen nombres y disponibilidad que dependen del sistema operativo anfitri\u00f3n. </p> <p>Ver m\u00e1s informaci\u00f3n sobre memory_info(): sitio oficial </p>"},{"location":"paquetes/psutil/#estadisticas-del-procesamiento","title":"Estadisticas del procesamiento","text":"<p>Estado del proceso, n\u00facleo ejecutante y n\u00facleos habilitados para ejecutar:</p> <pre><code>proceso.status()        # estado actual\nproceso.cpu_num()       # N\u00ba procesador ejecutando el proceso\nproceso.cpu_affinity()  # N\u00ba procesadores habilitados para ejecutar este proceso\n</code></pre>"},{"location":"paquetes/psutil/#prioridad-del-proceso","title":"Prioridad del proceso","text":"<p>La prioridad de los procesos son n\u00fameros que el sistema operativo tiene en cuenta a la hora de repartir el tiempo de ejecuci\u00f3n de los n\u00facleos del CPU entre los procesos activos.</p> <p>La prioridad del proceso actual es accesible y modificable con el m\u00e9todo nice(): <pre><code>numero_prioridad = proceso.nice()    # lectura\nproceso.nice(numero_prioridad)       # escritura\n</code></pre> En UNIX el valor va t\u00edpicamente desde -20 (prioridad m\u00e1xima) a 20(prioridad m\u00ednima).</p>"},{"location":"paquetes/psutil/#cpu_percent_1","title":"cpu_percent()","text":"<p>Permite calcular el porcentaje de uso de todos los CPUs por el programa actual (puede superar el 100%):</p> <p><pre><code># porcentaje de exigencia del CPU\nporcentaje_total = proceso.cpu_percent(interval=None, percpu=False)  #  (desde ultimo llamado)\n</code></pre> Par\u00e1metros  - interval: tiempo de referencia  - percpu: resultado en lista de porcentajes , uno por core (V6 en adelante)</p> <p>Si no se indica un valor num\u00e9rico para interval se toma de referencia la anterior llamada del m\u00e9todo o en su defecto la importaci\u00f3n del m\u00f3dulo. Es conveniente que entre ambas llamadas hayan pasado al menos 0.1 segundos para mejor precisi\u00f3n.</p> <p>Ejemplo uso: demanda de CPU de una rutina completa</p> Porcentaje CPU del proceso<pre><code>#punto de referencia\nproceso.cpu_percent()  # retorna '0.0'-&gt; IGNORAR\n#procesamiento\nRutina()\n# medicion\nporcentaje = proceso.cpu_percent()   \n</code></pre>"},{"location":"paquetes/psutil/#cpu_times_1","title":"cpu_times()","text":"<p>Calcula los tiempos acumulados de procesamiento que demand\u00f3 el proceso desde su inicio hasta el presente. <pre><code>data_tiempos = proceso.cpu_times()     # informacion de tiempo de procesamiento en segundos\n</code></pre> Campos m\u00e1s habituales:</p> Campos m\u00e1s habituales campo valor user tiempo usado en modo usuario (segundos) system tiempo usado en modo kernel (segundos) <p>M\u00e1s informacion sobre cpu_times(): sitio oficial</p>"},{"location":"paquetes/psutil/#arbol-de-procesos","title":"Arbol de procesos","text":"<pre><code># Identificador (ID)\npid  = proceso.pid             # ID del proceso \nppid = proceso.ppid()          # ID del proceso padre \n\n# data \ndata_padre   = proceso.parent()     # proceso padre\nlista_padres = proceso.parents()    # lista de procesos \"padres\"/\"abuelos\"/etc\nlista_hijos  = proceso.children(recursive=False)  # lista de procesos hijos\n</code></pre>"},{"location":"paquetes/psutil/#hilos-threads","title":"Hilos (threads)","text":"<pre><code># hilos\ndata_hilos = proceso.threads()       # informacion de los hilos 'namedtuple'\nnro_hilos  = proceso.num_threads()   # numero hilos\n</code></pre>"},{"location":"paquetes/psutil/#ruta-de-programa","title":"Ruta de programa","text":"<pre><code>ruta_programa   = proceso.cwd()           # directorio del programa\n</code></pre>"},{"location":"paquetes/psutil/#archivos","title":"Archivos","text":"<p>Da informacion de los archivos afectados por el proceso: <pre><code># archivos abiertos\nlista_archivos = proceso.open_files()    \n</code></pre></p> Campos habituales campo valor path ruta de archivo fd n\u00ba descriptor  (-1 en Windows) <p>M\u00e1s sobre open_files()</p>"},{"location":"paquetes/psutil/#variables-de-entorno","title":"Variables de entorno","text":"<pre><code># diccionario con variables de entorno\nlista_archivos = proceso.environ()    \n</code></pre>"},{"location":"paquetes/psutil/#usuario-y-grupo","title":"Usuario y Grupo","text":"<pre><code>nombre_usuario = proceso.username()     # usuario actual\ndata_usuario = proceso.uids()           # informacion de usuario \ndata_usuario = proceso.gids()           # informacion de grupo\n</code></pre>"},{"location":"paquetes/psutil/#conexiones-ip","title":"Conexiones IP","text":"<p>Da informaci\u00f3n de los sockets (\"z\u00f3calos\" de conexi\u00f3n) creados por el proceso para las conexiones: <pre><code># informaci\u00f3n de sockets usados - lista de 'namedtuple'\nlista_sockets = proceso.net_connections()       # V &gt; 0.6.0\nlista_sockets = proceso.connections()           # V &lt; 0.6.0\n</code></pre> El resultado es una lista de estadisticas de cada socket. Cada una incluye:</p> Campos disponibles campo informaci\u00f3n fd descriptor del socket ladr rutas IP del sistema radr ruta IP del destinatario family versi\u00f3n de rutas IP (\"familia\"): IPv4, IPv6, etc type tipo de direcci\u00f3n: TCP / UDP / etc status estado de la conexi\u00f3n <p>M\u00e1s informaci\u00f3n sobre net_connections(): sitio oficial</p>"},{"location":"paquetes/psutil/#manejo-de-senales","title":"Manejo de se\u00f1ales","text":"<p>M\u00e9todos disponibles</p> m\u00e9todo se\u00f1al equivalente uso send_signal( nro_signal) {SIG} le env\u00eda una se\u00f1al  al proceso suspend() SIGSTOP suspende el proceso (lo deja en espera) resume() SIGCONT reanuda el proceso wait(timeout=None) --- espera al cierre, tiempo de expiraci\u00f3n en segundos terminate() SIGTERM termina  el proceso kill() SIGKILL mata el proceso <p>Ejemplo: ordenar el cierre de un proceso y esperar a su cumplimiento</p> Cerrar por PID<pre><code>proceso = psutil.Process(nro_pid)\nproceso.terminate()\nproceso.wait()          # espera indefinidamente de ser necesario\n</code></pre>"},{"location":"paquetes/psutil/#referencias","title":"Referencias","text":"<p>Readthedocs - Documentacion oficial</p> <p>Codigos Python - Monitoreo del sistema con Psutil en python</p>"},{"location":"paquetes/python-i18n/","title":"Traducciones - python-i18n","text":""},{"location":"paquetes/python-i18n/#python-i18n","title":"python-i18n","text":"<p>i18n es una abreviaci\u00f3n de 'InternationalizatioN' (18 letras entre la I y la N). python-i18n es es una de las m\u00faltiples implementaciones de Python para las traducciones i18n.</p>"},{"location":"paquetes/python-i18n/#instalacion","title":"Instalaci\u00f3n","text":"<p>i18n se instala f\u00e1cilmente desde PIP:</p> instalaci\u00f3n<pre><code>pip install python-i18n\n</code></pre> <p>Si se prefiere guardar las traducciones en formato YAML el paquete requerido es el siguiente:</p> instalacion (con soporte YAML)<pre><code>pip install python-i18n[YAML]\n</code></pre>"},{"location":"paquetes/python-i18n/#importacion","title":"Importaci\u00f3n","text":"<p>El paquete debe importarse para su uso: importaci\u00f3n<pre><code>import i18n\n</code></pre></p>"},{"location":"paquetes/python-i18n/#traduccion-desde-script","title":"Traduccion desde script","text":"<p>Las traducciones se pueden cargar con la funci\u00f3n <code>add_tranlation()</code> en forma de pares campo - valor, ambos en formato string:</p> <p>Crear traducci\u00f3n<pre><code>i18n.add_translation('hello','hola')\n</code></pre> en tanto que las traducciones se realizan con la funci\u00f3n <code>t()</code>:</p> <p>Leer traducci\u00f3n<pre><code>campo = 'hello'\ntraducido = i18n.t(campo)\nprint(traducido)\n</code></pre> Para cada par campo-valor se puede asignar una abreviaci\u00f3n de lenguaje, de modo de permitir soporte simult\u00e1neo a m\u00faltiples idiomas: Traducciones en varios idiomas<pre><code>i18n.add_translation('hello','good morning', locale='en')   # 'en' : ingl\u00e9s (english) \ni18n.add_translation('hello','buenos d\u00edas', locale='es')    # 'es' : espa\u00f1ol\n</code></pre></p> <p>Las etiquetas 'es' y 'en' son etiquetas de idioma definidas por el desarrollador. \u00c9stas no vienen predefinidas por el paquete, aunque convencionalmente se usan las abreviaciones en ingl\u00e9s de los lenguajes. </p>"},{"location":"paquetes/python-i18n/#set-y-fallback","title":"Set y Fallback","text":"<p>El lenguaje prioritario se establece on la funci\u00f3n set(): Lenguaje preferido: set<pre><code># Lenguaje preferido\ni18n.set('locale', 'es')   # espa\u00f1ol\n</code></pre> en tanto que la opci\u00f3n alternativa se establece con la funci\u00f3n fallback():</p> Lenguaje de respaldo: fallback<pre><code># alternativa : 'fallback'\ni18n.set('fallback', 'en')  # ingl\u00e9s\n</code></pre> <p>Esto permite completar los campos para los cuales no existan traducciones en el lenguaje preestablecido. Como alternativa habitualmente se elige el ingl\u00e9s.</p>"},{"location":"paquetes/python-i18n/#traduccion-desde-archivos-yml","title":"Traduccion desde archivos YML","text":"<p>Las traducciones se guardan en archivos YML en una misma carpeta. El directorio se carga con el m\u00e9todo <code>append()</code> de la funci\u00f3n <code>load_path()</code>: </p> Carpeta de traducciones<pre><code># directorio con traducciones\ni18n.load_path.append('.')        # directorio actual\ni18n.load_path.append('local/')   # subdirectorio llamado 'local'\n</code></pre> <p>Los archivos YML tienen en su nombre un nombre de espacio (namespace), la abreviaci\u00f3n del idioma (locale) y el formato del archivo (format):</p> formato de nombres de archivo<pre><code>{namespace}.{locale}.{format}\n</code></pre> <p>Ejemplo: archivo para el ingl\u00e9s con los campos 'hi' y 'gb' traduccion al ingl\u00e9s<pre><code># archivo 'foo.en.yml' (ingl\u00e9s)\n# carpeta 'local'\nen: \n  hi: Hello Word!\n  gb: Goodbye!\n</code></pre> Ejemplo: archivo para el espa\u00f1ol con el campo \u00fanico 'hi' traduccion al espa\u00f1ol<pre><code># archivo 'foo.es.yml' (espa\u00f1ol)\n# carpeta 'local'\nes: \n  hi: Hola Mundo!\n    # campo 'gb' faltante\n</code></pre> Las traducciones de estos archivos se cargan con el nombre del descriptor de archivo y el nombre del campo elegido. </p> <p>Ejemplo: traducci\u00f3n faltante</p> <p>Si se necesita la traduccion al ingl\u00e9s:</p> traduccion al ingl\u00e9s<pre><code># traducci\u00f3n al ingles\ni18n.set('locale', 'en')    \ntraducido = i18n.t('foo.hi')\nprint(traducido)   \ntraducido = i18n.t('foo.gb')\nprint(traducido) \n</code></pre> <p>Si en cambio se necesita la traduccion al espa\u00f1ol (incompleta):</p> traduccion al espa\u00f1ol (incompleta)<pre><code># traducci\u00f3n al espa\u00f1ol\ni18n.set('locale', 'es')    \ntraducido = i18n.t('foo.hi')\nprint(traducido)    \n#campo faltante\ntraducido = i18n.t('foo.gb')\nprint(traducido)    # resultado en ingles\n</code></pre> <p>en este caso la traducci\u00f3n incluir\u00e1 los campos faltantes en ingl\u00e9s, por ser \u00e9ste el idioma alternativo elegido.</p> <p>Y si en cambio se necesita la traducci\u00f3n a un lenguaje no implementado, como por ejemplo el polaco:</p> traduccion al polaco (faltante)<pre><code># traducci\u00f3n al polaco (faltante)\ni18n.set('locale', 'pl')    \ntraducido = i18n.t('foo.hi')\nprint(traducido)   # resultado en ingles\n</code></pre> <p>en este caso simplemente se muestra todo en ingl\u00e9s.</p> <p>subdirectorios y namespaces</p> <p>Si los archivos de traducci\u00f3n se guardan en subdirectorios entonces los nombres de \u00e9stos tambi\u00e9n cuentan como nombre de espacio</p>"},{"location":"paquetes/python-i18n/#placeholders","title":"Placeholders","text":"<p>Se pueden implementar par\u00e1metros (campos variables) dentro de las traducciones, \u00e9stos son llamados placeholders o marcadores: placeholders: formato<pre><code># campo 'name' variable \ni18n.add_translation('hi', 'Hola %{name} !')\n</code></pre></p> <p>Los par\u00e1metros variables se asignan como argumento para la funci\u00f3n t() en el momento de traducir: placeholders: asignaci\u00f3n<pre><code>traducido = i18n.t('hi', name='Bob')    # 'Hola Bob!'\n</code></pre></p>"},{"location":"paquetes/python-i18n/#pluralizacion","title":"Pluralizacion","text":"<p>El placeholder, si \u00e9ste tiene valor num\u00e9rico, puede usarse para elegir entre varias traducciones posibles.</p> <p>El valor num\u00e9rico se pasa con la propiedad <code>count</code>. Las opciones de traducci\u00f3n se enmarcan entre llaves y hay cuatro opciones:</p> Opcion Valor <code>zero</code> 0 <code>one</code> 1 <code>few</code> 2 a 5 <code>many</code> 6 o mayor <p>Ejemplo: conteo de emails</p> <p>pluralizaci\u00f3n: formato<pre><code>i18n.add_translation('numero', {\n    'zero': 'No tienes ning\u00fan correo.',\n    'one': 'Tienes un nuevo correo.',\n    'few': 'S\u00f3lo tienes %{count} correos.',\n    'many': 'Tienes %{count} correos nuevos.'\n})\n</code></pre> La lectura de la traducci\u00f3n se hace asign\u00e1ndole el valor a la propiedad count:</p> pluralizaci\u00f3n: uso<pre><code>print( i18n.t('numero', count=0) )  # caso 'zero'(0)\nprint( i18n.t('numero', count=1) )  # caso 'one' (1)\nprint( i18n.t('numero', count=5) )  # caso 'few' (2 a 5)\nprint( i18n.t('numero', count=6) )  # caso 'many' (6 o mayor)\n</code></pre>"},{"location":"paquetes/python-i18n/#traduccion-desde-archivos-json","title":"Traduccion desde archivos JSON","text":"<p>Los archivos JSON deben ser habilitados para ser leidos por el paquete: habilitaci\u00f3n archivos JSON<pre><code># habilitar JSON\ni18n.set('file_format', 'json')\n</code></pre></p> <p>Los archivos de traducciones no siempre traen internamente indicado el campo locale (idioma). Para estos casos se habilita la opci\u00f3n 'skip_locale_root_data':</p> skip locale from root<pre><code>i18n.set('skip_locale_root_data', True)\n</code></pre>"},{"location":"paquetes/python-i18n/#ejemplo-aplicado-lectura-json","title":"Ejemplo aplicado - Lectura JSON","text":"<p>Archivo JSON de traducciones al ingl\u00e9s, carpeta 'local': archivo de traducci\u00f3n al ingl\u00e9s<pre><code>// archivo ingl\u00e9s: 'foo.en.json'\n// carpeta 'local'\n{\n   \"key-1\": \"Welcome %{firstname} %{lastname}!\",\n   \"key-2\": \"Good morning!\",\n   \"key-3\": \"Bye!\"\n}\n</code></pre> Archivo JSON de traducciones al espa\u00f1ol, carpeta 'local': archivo de traducci\u00f3n al espa\u00f1ol<pre><code>// archivo espa\u00f1ol: 'foo.es.json'\n// carpeta 'local'\n{\n    \"key-1\": \"Bienvenido %{firstname} %{lastname}!\",\n    \"key-2\": \"Buenos d\u00edas!\",\n    \"key-3\": \"Adi\u00f3s!\"\n}\n</code></pre> C\u00f3digo de aplicaci\u00f3n:</p> rutina de traducci\u00f3n<pre><code>i18n.set('file_format', 'json')\n\ni18n.load_path.append('local/')\n\ni18n.set('fallback', 'en')  # Ultima opcion\ni18n.set('skip_locale_root_data', True)\n\n\n# prueba espa\u00f1ol\ni18n.set('locale', 'es')  \nprint( i18n.t('foo.key-1',firstname='Aitor', lastname='Tilla'))\nprint( i18n.t('foo.key-2'))\nprint( i18n.t('foo.key-3'))\n\n# prueba espa\u00f1ol\ni18n.set('locale', 'en')  \nprint( i18n.t('foo.key-1',firstname='Aquiles', lastname='Brinco'))\nprint( i18n.t('foo.key-2'))\nprint( i18n.t('foo.key-3'))\n</code></pre>"},{"location":"paquetes/python-i18n/#referencias","title":"Referencias","text":"<p>Documentaci\u00f3n oficial</p>"},{"location":"paquetes/pyyaml/","title":"PyYAML","text":""},{"location":"paquetes/pyyaml/#yaml","title":"YAML","text":"<p>YAML (YAML Ain't Markup Language\u2122) es un formato de archivo muy popular para archivos de configuraciones y tambi\u00e9n se usa para intercambio de datos. Es un formato simple de leer aunque tambi\u00e9n es muy sensible respecto al indentado.</p> <p>P\u00e1gina oficial de YAML</p> <p>Este formato no est\u00e1 implementado de forma nativa en Python, por ello se requiere recurrir a paquetes externos. </p>"},{"location":"paquetes/pyyaml/#formato","title":"Formato","text":"<p>Los archivos YAML permiten guardar tanto listas como diccionarios. A continuaci\u00f3n se muestran algunos ejemplos</p>"},{"location":"paquetes/pyyaml/#listas","title":"Listas","text":"Lista de valores - YAML<pre><code>- 4\n- 9\n- -1\n</code></pre> Lista de valores - Python<pre><code>[4, 9, -1]\n</code></pre>"},{"location":"paquetes/pyyaml/#listas-de-diccionarios","title":"Listas de diccionarios","text":"Lista de diccionarios - YAML<pre><code>- x : 4\n- y : 9\n- z : -1\n</code></pre> Lista de diccionarios - Python<pre><code>[{'x': 4}, {'y': 9}, {'z': -1}]\n</code></pre>"},{"location":"paquetes/pyyaml/#diccionarios","title":"Diccionarios","text":"Diccionario - YAML<pre><code>debug: true     \n\ndata_numerica:   \n- x : 4\n- y : 9\n- z : -1\n</code></pre> Diccionario - Python<pre><code>{'debug': True, 'data_numerica': [{'x': 4}, {'y': 9}, {'z': -1}]}\n</code></pre> <p>N\u00f3tese que el valor <code>true</code> se convierte a booleano <code>True</code> autom\u00e1ticamente.</p>"},{"location":"paquetes/pyyaml/#multiples-objetos","title":"Multiples objetos","text":"<p>Un mismo archivo puede guardar varios objetos de datos: </p> Objetos m\u00faltiples - YAML<pre><code># objeto N\u00ba1 \ndata_numerica:   \n- x : 4\n- y : 9\n- z : -1\n\n---  # separador de objetos\n\n# objeto N\u00ba2 \ndebug: true\n</code></pre> <p>Por \u00faltimo YAML soporta comentarios internos, tal como se ve en el ejemplo previo.</p>"},{"location":"paquetes/pyyaml/#pyyaml_1","title":"PyYAML","text":"<p>PyYAML es el paquete m\u00e1s usado para dar soporte en Python. </p> <p>Sitio de PyYAML</p>"},{"location":"paquetes/pyyaml/#instalacion","title":"Instalacion","text":"Instalaci\u00f3n - PIP<pre><code>pip install pyyaml\n</code></pre>"},{"location":"paquetes/pyyaml/#importacion","title":"Importacion","text":"<p>El m\u00f3dulo debe importarse para su uso. Importaci\u00f3n<pre><code>import yaml\n</code></pre></p>"},{"location":"paquetes/pyyaml/#lectura-desde-archivo","title":"Lectura desde archivo","text":"<p>Para leer los archivos hay dos funciones espec\u00edficas llamadas <code>safe_load()</code> y <code>safe_load_all()</code>.</p> <p>Funcion load()</p> <p>La funci\u00f3n <code>load()</code> permite la ejecuci\u00f3n de c\u00f3digo malicioso guardado y por ello est\u00e1 marcada como obsoleta. <code>safe_load()</code> es su versi\u00f3n recortada, que tiene menos opciones pero que es mucho m\u00e1s segura de usar.</p>"},{"location":"paquetes/pyyaml/#objeto-unico","title":"Objeto \u00fanico","text":"<p>Para leer y decodificar archivos con un \u00fanico objeto de datos se usa la funci\u00f3n <code>safe_load()</code>:</p> lectura desde archivo - objeto unico<pre><code>ruta = \"data_simple.yml\"\nwith open(ruta,  'r') as archivo:\n    data_archivo = yaml.safe_load(archivo)\n\nprint(data_archivo)\nprint(type(data_archivo))   # 'dict'\n</code></pre> <p>Data \u00fanica</p> <p><code>safe_load()</code> no admite archivos con data m\u00faltiple, porque de intentarse el int\u00e9rprete dar\u00e1 error e interrumpir\u00e1 el programa.</p>"},{"location":"paquetes/pyyaml/#objetos-multiples","title":"Objetos m\u00faltiples","text":"<p>En caso deque el archivo contenga m\u00faltiples objetos de datos se usa la funci\u00f3n <code>safe_load_all()</code>.</p> <p>lectura desde archivo - objetos m\u00faltiples<pre><code>datos = []\nruta = \"data_doble.yml\"\nwith open(ruta,  'r') as archivo:\n    data_archivo = yaml.safe_load_all(archivo)  # tipo salida 'generator'\n    # la data debe extraerse antes de cerrar el archivo\n    for data in data_archivo:    \n        datos.append(data)\n\nprint(datos)\n</code></pre> Esta funci\u00f3n devuelve un objeto <code>generator</code> el cual debe recorrerse para rescatar la informaci\u00f3n antes de cerrar el archivo</p>"},{"location":"paquetes/pyyaml/#conversion-desde-strings","title":"Conversion desde strings","text":"<p>Las funciones <code>safe_load()</code> y <code>safe_load_all()</code> admiten a su entrada datos en formato texto simple.</p>"},{"location":"paquetes/pyyaml/#objeto-unico_1","title":"Objeto \u00fanico","text":"Lectura desde texto simple - objeto \u00fanico<pre><code>nombres_texto = \"\"\"\ndata_numerica:   \n- x : 4\n- y : 9\n- z : -1\n\"\"\"\n\ndata_nombres = yaml.safe_load(nombres_texto)  # diccionario\n</code></pre>"},{"location":"paquetes/pyyaml/#objetos-multiples_1","title":"Objetos m\u00faltiples","text":"Lectura desde texto simple - objetos m\u00faltiples<pre><code>datos_texto = \"\"\"\n# objeto N\u00ba1 \ndata_numerica:   \n    - x : 4\n    - y : 9\n    - z : -1\n---\n# objeto N\u00ba2\ndebug: true\n\"\"\"\n\ndata_nombres = []\ngenerador_data = yaml.safe_load_all(datos_texto)\n\nfor data in generador_data:\n    data_nombres.append(data)\n\n\nprint(data_nombres)\n</code></pre> <p>Indentado</p> <p>Hay que evitar a toda costa el tabular la secuencia <code>---</code> para evitar errores de lectura.</p>"},{"location":"paquetes/pyyaml/#guardado-de-datos","title":"Guardado de datos","text":"<p>Para el guardado de objetos en Python se usa la funci\u00f3n <code>dump()</code>:</p> guardado de datos<pre><code>data_nombres: dict|list\n\nruta_salida = \"data_salida.yml\"\nwith open(ruta_salida, 'w') as archivo:\n    yaml.dump(data_nombres, archivo)\n</code></pre> <p>Otras opciones: <pre><code>yaml.dump()\nyaml.dump_all()\nyaml.safe_dump()\nyaml.safe_dump_all()\n</code></pre></p>"},{"location":"paquetes/pyyaml/#referencias","title":"Referencias","text":"<p>Python Land - Python YAML: How to Load, Read, and Write YAML </p>"}]}